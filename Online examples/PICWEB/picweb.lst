CCS PCH C Compiler, Version 4.068, 61236               13-set-12 23:17

               Filename: D:\PICWEB\picweb.lst

               ROM used: 29256 bytes (89%)
                         Largest free fragment is 3510
               RAM used: 771 (38%) at main() level
                         958 (47%) worst case
               Stack:    15 worst case (14 in main + 1 for interrupts)

*
0000:  GOTO   6D3E
*
0008:  MOVWF  05
000A:  MOVFF  FD8,06
000E:  MOVFF  FE0,07
0012:  MOVLB  0
0014:  MOVFF  FE9,0D
0018:  MOVFF  FEA,08
001C:  MOVFF  FE1,09
0020:  MOVFF  FE2,0A
0024:  MOVFF  FD9,0B
0028:  MOVFF  FDA,0C
002C:  MOVFF  FF3,14
0030:  MOVFF  FF4,15
0034:  MOVFF  FFA,16
0038:  MOVFF  00,0F
003C:  MOVFF  01,10
0040:  MOVFF  02,11
0044:  MOVFF  03,12
0048:  MOVFF  04,13
004C:  BTFSS  FF2.5
004E:  GOTO   0058
0052:  BTFSC  FF2.2
0054:  GOTO   01F8
0058:  MOVFF  0F,00
005C:  MOVFF  10,01
0060:  MOVFF  11,02
0064:  MOVFF  12,03
0068:  MOVFF  13,04
006C:  BSF    0E.7
006E:  MOVFF  0D,FE9
0072:  MOVFF  08,FEA
0076:  MOVFF  09,FE1
007A:  MOVFF  0A,FE2
007E:  MOVFF  0B,FD9
0082:  MOVFF  0C,FDA
0086:  MOVFF  14,FF3
008A:  MOVFF  15,FF4
008E:  MOVFF  16,FFA
0092:  MOVF   05,W
0094:  MOVFF  07,FE0
0098:  MOVFF  06,FD8
009C:  RETFIE 0
....................  
....................  
.................... #define STACK_USE_ICMP  1 
.................... #define STACK_USE_ARP   1 
.................... #define STACK_USE_TCP   1 
.................... #define STACK_USE_HTTP  1 
.................... #include "ccstcpip.h" 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // ccstcpip.h - Common code shared among all Embedded Internet/Embedded 
.................... // Ethernet tutorial book examples. 
.................... // 
.................... // If you are using a CCS Embedded Ethernet Board (labeled PICENS, which 
.................... // has an MCP ENC28J60) then define STACK_USE_CCS_PICENS to TRUE. 
.................... // 
.................... // If you are using a CCS Embedded Internet Board (labeled PICNET, which 
.................... // has a Realtek RTL8019AS and a 56K Modem) then define STACK_USE_CCS_PICNET 
.................... // to TRUE. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // 10/25/06 
.................... //  - Added STACK_USE_CCS_PICEEC 
.................... //  - ExampleUDPPacket[] UDP header length fixed 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #define STACK_USE_CCS_PICENS   1 
.................... #define STACK_USE_MCPENC 1 
.................... #define STACK_USE_MAC 1 
....................  
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #DEVICE ADC=10 
.................... #use delay(clock=20000000) 
*
050E:  MOVLW  03
0510:  MOVWF  FEA
0512:  MOVLW  2F
0514:  MOVWF  FE9
0516:  MOVF   FEF,W
0518:  BZ    0534
051A:  MOVLW  06
051C:  MOVWF  01
051E:  CLRF   00
0520:  DECFSZ 00,F
0522:  BRA    0520
0524:  DECFSZ 01,F
0526:  BRA    051E
0528:  MOVLW  7B
052A:  MOVWF  00
052C:  DECFSZ 00,F
052E:  BRA    052C
0530:  DECFSZ FEF,F
0532:  BRA    051A
0534:  RETLW  00
.................... #fuses HS,NOWDT,NOPROTECT,NOLVP,NODEBUG,USBDIV,VREGEN,NOPBADEN,WRTB 
.................... #use rs232(baud=9600, xmit=PIN_C6, rcv=PIN_C7) 
....................  
.................... //#include "bootloader.c" 
.................... #include "tcpip/stacktsk.c"    //include Microchip TCP/IP Stack 
.................... /********************************************************************* 
....................  * 
....................  *               Microchip TCP/IP Stack FSM Implementation on PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.c 
....................  * Dependencies:    StackTsk.H 
....................  *                  ARPTsk.h 
....................  *                  MAC.h 
....................  *                  IP.h 
....................  *                  ICMP.h 
....................  *                  Tcp.h 
....................  *                  http.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/14/01  Original (Rev. 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Nilesh Rajbharti     12/5/02     Modified UDPProcess() and TCPProcess() 
....................  *                                  to include localIP as third param. 
....................  *                                  This was done to allow these functions 
....................  *                                  to calculate checksum correctly. 
....................  * Nilesh Rajbharti     7/26/04     Added code in StackTask() to not 
....................  *                                  clear statically IP address if link is 
....................  *                                  removed and DHCP module is disabled 
....................  *                                  at runtime. 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/11/04 A break; added to StackTask() after handling an ARP, else it would goto IP handler. 
....................  * Darren Rook (CCS)    06/28/04 Added 2.20 improvement that resets DHCP after unlink of ethernet 
....................  * Darren Rook (CCS)    06/29/04 A fix for 2.20 improvement (see above) if DHCP was dynamically disabled 
....................  * Darren Rook (CCS)    06/29/04 smStack no longer static 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    04/08/05 Task() and Init() execute any needed HTTP code 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #case 
....................  
.................... #define STACK_INCLUDE 
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  PIC18 SFR Definitions 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        pic18.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or later 
....................  * 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     11/14/01 Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  ********************************************************************/ 
.................... #ifndef COMPILER_H 
.................... #define COMPILER_H 
....................  
.................... #if !defined(__PCH__) 
.................... #error "This version only works with CCS PCH or PCWH" 
.................... #endif 
....................  
.................... // ** I/O PORT REGISTERS 
....................  
.................... #byte PORTA    =  0xF80 
.................... #byte PORTB    =  0xF81 
.................... #byte PORTC    =  0xF82 
.................... #byte PORTD    =  0xF83 
.................... #byte PORTE    =  0xF84 
.................... #byte PORTF    =  0xF85 
....................  
.................... #bit PORTA_RA5 =  0xF80.5 
.................... #bit PORTA_RA4 =  0xF80.4 
.................... #bit PORTA_RA3 =  0xF80.3 
.................... #bit PORTA_RA2 =  0xF80.2 
.................... #bit PORTA_RA1 =  0xF80.1 
.................... #bit PORTA_RA0 =  0xF80.0 
....................  
.................... #bit PORTB_RB7 =  0xF81.7 
.................... #bit PORTB_RB6 =  0xF81.6 
.................... #bit PORTB_RB5 =  0xF81.5 
.................... #bit PORTB_RB4 =  0xF81.4 
.................... #bit PORTB_RB3 =  0xF81.3 
.................... #bit PORTB_RB2 =  0xF81.2 
.................... #bit PORTB_RB1 =  0xF81.1 
.................... #bit PORTB_RB0 =  0xF81.0 
....................  
.................... #bit PORTC_RC7 =  0xF82.7 
.................... #bit PORTC_RC6 =  0xF82.6 
.................... #bit PORTC_RC5 =  0xF82.5 
.................... #bit PORTC_RC4 =  0xF82.4 
.................... #bit PORTC_RC3 =  0xF82.3 
.................... #bit PORTC_RC2 =  0xF82.2 
.................... #bit PORTC_RC1 =  0xF82.1 
.................... #bit PORTC_RC0 =  0xF82.0 
....................  
.................... #bit PORTD_RD7 =  0xF83.7 
.................... #bit PORTD_RD6 =  0xF83.6 
.................... #bit PORTD_RD5 =  0xF83.5 
.................... #bit PORTD_RD4 =  0xF83.4 
.................... #bit PORTD_RD3 =  0xF83.3 
.................... #bit PORTD_RD2 =  0xF83.2 
.................... #bit PORTD_RD1 =  0xF83.1 
.................... #bit PORTD_RD0 =  0xF83.0 
....................  
.................... #bit PORTE_RE7 =  0xF84.7 
.................... #bit PORTE_RE6 =  0xF84.6 
.................... #bit PORTE_RE5 =  0xF84.5 
.................... #bit PORTE_RE4 =  0xF84.4 
.................... #bit PORTE_RE3 =  0xF84.3 
.................... #bit PORTE_RE2 =  0xF84.2 
.................... #bit PORTE_RE1 =  0xF84.1 
.................... #bit PORTE_RE0 =  0xF84.0 
....................  
.................... #bit PORTF_RF7 =  0xF85.7 
.................... #bit PORTF_RF6 =  0xF85.6 
.................... #bit PORTF_RF5 =  0xF85.5 
.................... #bit PORTF_RF4 =  0xF85.4 
.................... #bit PORTF_RF3 =  0xF85.3 
.................... #bit PORTF_RF2 =  0xF85.2 
.................... #bit PORTF_RF1 =  0xF85.1 
.................... #bit PORTF_RF0 =  0xF85.0 
....................  
....................  
.................... // *** TRIS REGISTERS 
....................  
.................... #byte TRISA    =  0xF92 
.................... #byte TRISB    =  0xF93 
.................... #byte TRISC    =  0xF94 
.................... #byte TRISD    =  0xF95 
.................... #byte TRISE    =  0xF96 
.................... #byte TRISF    =  0xF97 
....................  
.................... #bit TRISA_RA7 =  0xF92.7 
.................... #bit TRISA_RA6 =  0xF92.6 
.................... #bit TRISA_RA5 =  0xF92.5 
.................... #bit TRISA_RA4 =  0xF92.4 
.................... #bit TRISA_RA3 =  0xF92.3 
.................... #bit TRISA_RA2 =  0xF92.2 
.................... #bit TRISA_RA1 =  0xF92.1 
.................... #bit TRISA_RA0 =  0xF92.0 
....................  
.................... #bit TRISB_RB7 =  0xF93.7 
.................... #bit TRISB_RB6 =  0xF93.6 
.................... #bit TRISB_RB5 =  0xF93.5 
.................... #bit TRISB_RB4 =  0xF93.4 
.................... #bit TRISB_RB3 =  0xF93.3 
.................... #bit TRISB_RB2 =  0xF93.2 
.................... #bit TRISB_RB1 =  0xF93.1 
.................... #bit TRISB_RB0 =  0xF93.0 
....................  
.................... #bit TRISC_RC7 =  0xF94.7 
.................... #bit TRISC_RC6 =  0xF94.6 
.................... #bit TRISC_RC5 =  0xF94.5 
.................... #bit TRISC_RC4 =  0xF94.4 
.................... #bit TRISC_RC3 =  0xF94.3 
.................... #bit TRISC_RC2 =  0xF94.2 
.................... #bit TRISC_RC1 =  0xF94.1 
.................... #bit TRISC_RC0 =  0xF94.0 
....................  
.................... #bit TRISD_RD7 =  0xF95.7 
.................... #bit TRISD_RD6 =  0xF95.6 
.................... #bit TRISD_RD5 =  0xF95.5 
.................... #bit TRISD_RD4 =  0xF95.4 
.................... #bit TRISD_RD3 =  0xF95.3 
.................... #bit TRISD_RD2 =  0xF95.2 
.................... #bit TRISD_RD1 =  0xF95.1 
.................... #bit TRISD_RD0 =  0xF95.0 
....................  
.................... #bit TRISE_RE7 =  0xF96.7 
.................... #bit TRISE_RE6 =  0xF96.6 
.................... #bit TRISE_RE5 =  0xF96.5 
.................... #bit TRISE_RE4 =  0xF96.4 
.................... #bit TRISE_RE3 =  0xF96.3 
.................... #bit TRISE_RE2 =  0xF96.2 
.................... #bit TRISE_RE1 =  0xF96.1 
.................... #bit TRISE_RE0 =  0xF96.0 
....................  
.................... #bit TRISF_RF7 =  0xF97.7 
.................... #bit TRISF_RF6 =  0xF97.6 
.................... #bit TRISF_RF5 =  0xF97.5 
.................... #bit TRISF_RF4 =  0xF97.4 
.................... #bit TRISF_RF3 =  0xF97.3 
.................... #bit TRISF_RF2 =  0xF97.2 
.................... #bit TRISF_RF1 =  0xF97.1 
.................... #bit TRISF_RF0 =  0xF97.0 
....................  
....................  
.................... // *** LAT REGISTERS 
.................... #byte LATA    =  0xF89 
.................... #byte LATB    =  0xF8A 
.................... #byte LATC    =  0xF8B 
.................... #byte LATD    =  0xF8C 
.................... #byte LATE    =  0xF8D 
.................... #byte LATF    =  0xF8E 
....................  
.................... #bit LATA_RA7 =  0xF89.7 
.................... #bit LATA_RA6 =  0xF89.6 
.................... #bit LATA_RA5 =  0xF89.5 
.................... #bit LATA_RA4 =  0xF89.4 
.................... #bit LATA_RA3 =  0xF89.3 
.................... #bit LATA_RA2 =  0xF89.2 
.................... #bit LATA_RA1 =  0xF89.1 
.................... #bit LATA_RA0 =  0xF89.0 
....................  
.................... #bit LATB_RB7 =  0xF8A.7 
.................... #bit LATB_RB6 =  0xF8A.6 
.................... #bit LATB_RB5 =  0xF8A.5 
.................... #bit LATB_RB4 =  0xF8A.4 
.................... #bit LATB_RB3 =  0xF8A.3 
.................... #bit LATB_RB2 =  0xF8A.2 
.................... #bit LATB_RB1 =  0xF8A.1 
.................... #bit LATB_RB0 =  0xF8A.0 
....................  
.................... #bit LATC_RC7 =  0xF8B.7 
.................... #bit LATC_RC6 =  0xF8B.6 
.................... #bit LATC_RC5 =  0xF8B.5 
.................... #bit LATC_RC4 =  0xF8B.4 
.................... #bit LATC_RC3 =  0xF8B.3 
.................... #bit LATC_RC2 =  0xF8B.2 
.................... #bit LATC_RC1 =  0xF8B.1 
.................... #bit LATC_RC0 =  0xF8B.0 
....................  
.................... #bit LATD_RD7 =  0xF8C.7 
.................... #bit LATD_RD6 =  0xF8C.6 
.................... #bit LATD_RD5 =  0xF8C.5 
.................... #bit LATD_RD4 =  0xF8C.4 
.................... #bit LATD_RD3 =  0xF8C.3 
.................... #bit LATD_RD2 =  0xF8C.2 
.................... #bit LATD_RD1 =  0xF8C.1 
.................... #bit LATD_RD0 =  0xF8C.0 
....................  
.................... #bit LATE_RE7 =  0xF8D.7 
.................... #bit LATE_RE6 =  0xF8D.6 
.................... #bit LATE_RE5 =  0xF8D.5 
.................... #bit LATE_RE4 =  0xF8D.4 
.................... #bit LATE_RE3 =  0xF8D.3 
.................... #bit LATE_RE2 =  0xF8D.2 
.................... #bit LATE_RE1 =  0xF8D.1 
.................... #bit LATE_RE0 =  0xF8D.0 
....................  
.................... #bit LATF_RF7 =  0xF8E.7 
.................... #bit LATF_RF6 =  0xF8E.6 
.................... #bit LATF_RF5 =  0xF8E.5 
.................... #bit LATF_RF4 =  0xF8E.4 
.................... #bit LATF_RF3 =  0xF8E.3 
.................... #bit LATF_RF2 =  0xF8E.2 
.................... #bit LATF_RF1 =  0xF8E.1 
.................... #bit LATF_RF0 =  0xF8E.0 
....................  
....................  
.................... // ** OTHER SPECIAL FILE REGISTERS USED BY SLIP 
....................  
.................... #bit  PIE1_TXIE       =  0xF9D.4 
.................... #bit  PIE1_RCIE       =  0xF9D.5 
.................... #bit  PIR1_TXIF       =  0xF9E.4 
.................... #bit  PIR1_RCIF       =  0xF9E.5 
.................... #byte TXSTA           =  0xFAC 
.................... #byte RCSTA           =  0xFAB 
.................... #bit  RCSTA_CREN      =  0xFAB.4 
.................... #byte RCREG           =  0xFAE 
.................... #byte SPBRG           =  0xFAF 
.................... #byte TXREG           =  0xFAD 
....................  
....................  
.................... #endif 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                         HARDWARE.H                                //// 
.................... ////                                                                   //// 
.................... //// Hardware I/O definitions and TCP/IP stack configuration settings. //// 
.................... ////                                                                   //// 
.................... //// These values will probably change with each application.          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// RELEASE HISTORY:                                                  //// 
.................... ////                                                                   //// 
.................... ////    Jan 15, 2004: MODEM_RESPONSE_TIMEOUT and MODEM_CONNECT_TIMEOUT //// 
.................... ////                  moved to here.                                   //// 
.................... ////                                                                   //// 
.................... ////    Jan 09, 2004: Initial Public Release                           //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2004 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF ___TCPIP_STACK_CONFIGURATION 
.................... #define ___TCPIP_STACK_CONFIGURATION 
....................  
....................  
.................... #ifndef STACK_USE_CCS_PICNET 
.................... #define STACK_USE_CCS_PICNET  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_CCS_PICENS 
.................... #define STACK_USE_CCS_PICENS  FALSE 
.................... #endif 
....................  
....................  
.................... //// SET TCP_NO_WAIT_FOR_ACK TO FALSE IF TCP STACK SHOULD WAIT FOR ACK FROM 
.................... //// REMOTE HOST BEFORE TRANSMITTING ANOTHER PACKET.  THIS MAY REDUCE THROUGHPUT. 
.................... //// DEFAULT VALUE (TRUE) GETS LOADED IN TCP.H IF THIS LINE IS REMOVED. 
....................    #define TCP_NO_WAIT_FOR_ACK   FALSE 
....................  
....................  
.................... ///DEFAULT HARDCODED IP ADDRESSES. 
.................... ///  FUTURE APPLICATIONS MAY WANT TO SAVE THESE TO AN EEPROM. 
.................... ///  OR USE AUTO IP ASSIGNMENT (DHCP). 
.................... ///  NO TWO DEVICES ON A NETwORK CAN HAVE THE SAME IP ADDRESS 
....................    #define MY_DEFAULT_IP_ADDR_BYTE1        192   //IP ADDRESS 
....................    #define MY_DEFAULT_IP_ADDR_BYTE2        168   // This unit's IP address. 
....................    #define MY_DEFAULT_IP_ADDR_BYTE3        1 
....................    #define MY_DEFAULT_IP_ADDR_BYTE4        10 
....................  
....................    #define MY_DEFAULT_MASK_BYTE1           0xff //NETMASK 
....................    #define MY_DEFAULT_MASK_BYTE2           0xff // Netmask tells the IP / ARP stack which 
....................    #define MY_DEFAULT_MASK_BYTE3           0xff // IP's are on your local network. 
....................    #define MY_DEFAULT_MASK_BYTE4           0x00 
....................  
....................    #define MY_DEFAULT_GATE_BYTE1           192  //GATEWAY IP ADDRESS 
....................    #define MY_DEFAULT_GATE_BYTE2           168  // Gateway acts as a conduit between two networks. 
....................    #define MY_DEFAULT_GATE_BYTE3           1 
....................    #define MY_DEFAULT_GATE_BYTE4           1 
....................  
.................... ///DEFAULT HARDCODED MAC ADDRESS. 
.................... ///  FUTURE APPLICATIONS MAY WANT TO SAVE THIS TO AN EEPROM, OR GENERATE 
.................... ///  A DYNAMIC ONE BASED UPON UNIT'S SERIAL NUMBER. 
.................... ///  NO TWO DEVICES ON THE SAME ETHERNET NETWORK CAN HAVE THE SAME MAC ADDRESS. 
.................... #define MY_DEFAULT_MAC_BYTE1            0x00 
.................... #define MY_DEFAULT_MAC_BYTE2            0x02 
.................... #define MY_DEFAULT_MAC_BYTE3            0xa3 
.................... #define MY_DEFAULT_MAC_BYTE4            0x04 
.................... #define MY_DEFAULT_MAC_BYTE5            0x05 
.................... #define MY_DEFAULT_MAC_BYTE6            0x06 
....................  
.................... ///Maximum sockets to be defined. 
.................... /// Note that each socket consumes 36 bytes of RAM. 
.................... /// If you remove this, a default value will be loaded in stacktsk.h 
....................    #ifndef MAX_SOCKETS 
....................    #define MAX_SOCKETS                     5 
....................    #endif 
....................  
.................... ///Avaialble UDP Socket 
.................... /// DCHP takes 1 socket. 
.................... /// If you remove this, a default value will be loaded in stacktsk.h 
....................    #ifndef MAX_UDP_SOCKETS 
....................    #define MAX_UDP_SOCKETS                 2 
....................    #endif 
....................  
.................... ///BUFFER SIZE DEFINITIONS 
.................... /// 
.................... /// For SLIP, there can only be one transmit and one receive buffer. 
.................... /// Both buffer must fit in one bank.  If bigger buffer is required, 
.................... /// you must manually locate tx and rx buffer in different bank 
.................... /// or modify your linker script file to support arrays bigger than 
.................... /// 256 bytes. 
.................... /// I think Microchip needs MAC_RX_BUFFER_SIZE to equal MAC_TX_BUFFER_SIZE 
.................... /// 
.................... /// For PPP, there can only be one transmit and one receive buffer. 
.................... /// You can receive messages larger than the receive buffer if your 
.................... /// routines are fast enough.  You cannot transmit messages larger 
.................... /// than the TX buffer.  The larger the buffer you can make, the better. 
.................... /// BUG: MAC_RX_BUFFER_SIZE must equal MAC_TX_BUFFER_SIZE 
.................... /// 
.................... /// For Ethernet, the Ethernet controler has many buffers that are 
.................... /// 1k in size.   Only one buffer is used for TX, rest are for RX. 
.................... /// Unlike SLIP and PPP, no RAM is used for these buffers. 
....................    #if STACK_USE_MAC 
....................        #define MAC_TX_BUFFER_SIZE          1024 //do not modify this line 
....................        #define MAC_TX_BUFFER_COUNT         1    //do not modify this line 
....................    #elif STACK_USE_PPP 
....................        #define MAC_TX_BUFFER_SIZE          1024 
....................        #define MAC_TX_BUFFER_COUNT         1 
....................    #elif STACK_USE_SLIP 
....................        #define MAC_TX_BUFFER_SIZE          250 
....................        #define MAC_TX_BUFFER_COUNT         1 
....................    #endif 
....................  
....................    #define MAC_RX_BUFFER_SIZE              MAC_TX_BUFFER_SIZE  //do not modify this line unless you are certain you know what you're doing 
....................  
.................... #endif 
....................  
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
*
46DC:  MOVFF  333,338
46E0:  MOVFF  332,337
....................    sc2=s2; 
46E4:  MOVFF  335,33A
46E8:  MOVFF  334,339
....................    if(sc2<sc1 && sc1 <sc2 +n) 
46EC:  MOVLB  3
46EE:  MOVF   x3A,W
46F0:  SUBWF  x38,W
46F2:  BNC   475A
46F4:  BNZ   46FC
46F6:  MOVF   x37,W
46F8:  SUBWF  x39,W
46FA:  BC    475A
46FC:  MOVF   x36,W
46FE:  ADDWF  x39,W
4700:  MOVWF  01
4702:  MOVLW  00
4704:  ADDWFC x3A,W
4706:  MOVWF  03
4708:  MOVF   x38,W
470A:  SUBWF  03,W
470C:  BNC   475A
470E:  BNZ   4716
4710:  MOVF   01,W
4712:  SUBWF  x37,W
4714:  BC    475A
....................       for(sc1+=n,sc2+=n;0<n;--n) 
4716:  MOVF   x36,W
4718:  ADDWF  x37,F
471A:  MOVLW  00
471C:  ADDWFC x38,F
471E:  MOVF   x36,W
4720:  ADDWF  x39,F
4722:  MOVLW  00
4724:  ADDWFC x3A,F
4726:  MOVF   x36,W
4728:  SUBLW  00
472A:  BC    4758
....................          *--sc1=*--sc2; 
472C:  MOVF   x37,W
472E:  BTFSC  FD8.2
4730:  DECF   x38,F
4732:  DECF   x37,F
4734:  MOVF   x39,W
4736:  BTFSC  FD8.2
4738:  DECF   x3A,F
473A:  DECF   x39,F
473C:  MOVFF  339,FE9
4740:  MOVFF  33A,FEA
4744:  MOVFF  FEF,33D
4748:  MOVFF  338,FEA
474C:  MOVFF  337,FE9
4750:  MOVFF  33D,FEF
4754:  DECF   x36,F
4756:  BRA    4726
....................    else 
4758:  BRA    4798
....................       for(;0<n;--n) 
475A:  MOVF   x36,W
475C:  SUBLW  00
475E:  BC    4798
....................          *sc1++=*sc2++; 
4760:  MOVFF  338,03
4764:  MOVF   x37,W
4766:  INCF   x37,F
4768:  BTFSC  FD8.2
476A:  INCF   x38,F
476C:  MOVWF  x3B
476E:  MOVFF  03,33C
4772:  MOVFF  33A,03
4776:  MOVF   x39,W
4778:  INCF   x39,F
477A:  BTFSC  FD8.2
477C:  INCF   x3A,F
477E:  MOVWF  FE9
4780:  MOVFF  03,FEA
4784:  MOVFF  FEF,33D
4788:  MOVFF  33C,FEA
478C:  MOVFF  33B,FE9
4790:  MOVFF  33D,FEF
4794:  DECF   x36,F
4796:  BRA    475A
....................   return s1; 
4798:  MOVFF  332,01
479C:  MOVFF  333,02
....................   } 
47A0:  MOVLB  0
47A2:  GOTO   4888 (RETURN)
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
4256:  MOVLB  3
4258:  MOVFF  311,FE9
425C:  MOVFF  312,FEA
4260:  MOVFF  FEF,315
4264:  MOVFF  314,03
4268:  MOVFF  313,FE9
426C:  MOVFF  314,FEA
4270:  MOVF   FEF,W
4272:  SUBWF  x15,W
4274:  BNZ   42A0
....................       if (*s1 == '\0') 
4276:  MOVFF  312,03
427A:  MOVFF  311,FE9
427E:  MOVFF  03,FEA
4282:  MOVF   FEF,F
4284:  BNZ   428C
....................          return(0); 
4286:  MOVLW  00
4288:  MOVWF  01
428A:  BRA    42CA
428C:  MOVFF  312,03
4290:  MOVF   x11,W
4292:  INCF   x11,F
4294:  BTFSC  FD8.2
4296:  INCF   x12,F
4298:  INCF   x13,F
429A:  BTFSC  FD8.2
429C:  INCF   x14,F
429E:  BRA    4258
....................    return((*s1 < *s2) ? -1: 1); 
42A0:  MOVFF  312,03
42A4:  MOVFF  311,FE9
42A8:  MOVFF  312,FEA
42AC:  MOVFF  FEF,315
42B0:  MOVFF  314,03
42B4:  MOVFF  313,FE9
42B8:  MOVFF  314,FEA
42BC:  MOVF   FEF,W
42BE:  SUBWF  x15,W
42C0:  BC    42C6
42C2:  MOVLW  FF
42C4:  BRA    42C8
42C6:  MOVLW  01
42C8:  MOVWF  01
.................... } 
42CA:  MOVLB  0
42CC:  RETLW  00
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
42CE:  MOVFF  362,364
....................    for(su=s;0<n;++su,--n) 
42D2:  MOVFF  361,366
42D6:  MOVFF  360,365
42DA:  MOVLB  3
42DC:  MOVF   x63,W
42DE:  SUBLW  00
42E0:  BC    4308
....................       if(*su==uc) 
42E2:  MOVFF  366,03
42E6:  MOVFF  365,FE9
42EA:  MOVFF  366,FEA
42EE:  MOVF   x64,W
42F0:  SUBWF  FEF,W
42F2:  BNZ   42FE
....................       return su; 
42F4:  MOVFF  365,01
42F8:  MOVFF  366,02
42FC:  BRA    430E
42FE:  INCF   x65,F
4300:  BTFSC  FD8.2
4302:  INCF   x66,F
4304:  DECF   x63,F
4306:  BRA    42DC
....................    return NULL; 
4308:  MOVLW  00
430A:  MOVWF  01
430C:  MOVWF  02
.................... } 
430E:  MOVLB  0
4310:  RETLW  00
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8 *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
412C:  MOVFF  31D,321
4130:  MOVFF  31C,320
4134:  MOVFF  321,03
4138:  MOVLB  3
413A:  MOVFF  320,FE9
413E:  MOVFF  321,FEA
4142:  MOVF   FEF,F
4144:  BZ    419A
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
4146:  MOVFF  31F,323
414A:  MOVFF  31E,322
414E:  MOVFF  323,03
4152:  MOVFF  322,FE9
4156:  MOVFF  323,FEA
415A:  MOVF   FEF,F
415C:  BZ    418E
....................          if (*sc1 == *sc2) 
415E:  MOVFF  320,FE9
4162:  MOVFF  321,FEA
4166:  MOVFF  FEF,324
416A:  MOVFF  323,03
416E:  MOVFF  322,FE9
4172:  MOVFF  323,FEA
4176:  MOVF   FEF,W
4178:  SUBWF  x24,W
417A:  BNZ   4186
....................             return(sc1); 
417C:  MOVFF  320,01
4180:  MOVFF  321,02
4184:  BRA    41A0
4186:  INCF   x22,F
4188:  BTFSC  FD8.2
418A:  INCF   x23,F
418C:  BRA    414E
418E:  INCF   x20,F
4190:  BTFSC  FD8.2
4192:  INCF   x21,F
4194:  MOVLB  0
4196:  BRA    4134
4198:  MOVLB  3
....................    return(0); 
419A:  MOVLW  00
419C:  MOVWF  01
419E:  MOVWF  02
.................... } 
41A0:  MOVLB  0
41A2:  GOTO   4218 (RETURN)
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8 *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
4098:  MOVFF  31D,321
409C:  MOVFF  31C,320
40A0:  MOVFF  321,03
40A4:  MOVLB  3
40A6:  MOVFF  320,FE9
40AA:  MOVFF  321,FEA
40AE:  MOVF   FEF,F
40B0:  BZ    4114
....................       for (sc2 = s2; ; sc2++) 
40B2:  MOVFF  31F,323
40B6:  MOVFF  31E,322
....................     if (*sc2 == '\0') 
40BA:  MOVFF  323,03
40BE:  MOVFF  322,FE9
40C2:  MOVFF  323,FEA
40C6:  MOVF   FEF,F
40C8:  BNZ   40E0
....................        return(sc1 - s1); 
40CA:  MOVF   x1C,W
40CC:  SUBWF  x20,W
40CE:  MOVWF  00
40D0:  MOVF   x1D,W
40D2:  SUBWFB x21,W
40D4:  MOVWF  03
40D6:  MOVFF  00,01
40DA:  MOVWF  02
40DC:  BRA    4126
....................          else if (*sc1 == *sc2) 
40DE:  BRA    4100
40E0:  MOVFF  320,FE9
40E4:  MOVFF  321,FEA
40E8:  MOVFF  FEF,324
40EC:  MOVFF  323,03
40F0:  MOVFF  322,FE9
40F4:  MOVFF  323,FEA
40F8:  MOVF   FEF,W
40FA:  SUBWF  x24,W
40FC:  BNZ   4100
....................             break; 
40FE:  BRA    4108
4100:  INCF   x22,F
4102:  BTFSC  FD8.2
4104:  INCF   x23,F
4106:  BRA    40BA
4108:  INCF   x20,F
410A:  BTFSC  FD8.2
410C:  INCF   x21,F
410E:  MOVLB  0
4110:  BRA    40A0
4112:  MOVLB  3
....................    return(sc1 - s1); 
4114:  MOVF   x1C,W
4116:  SUBWF  x20,W
4118:  MOVWF  00
411A:  MOVF   x1D,W
411C:  SUBWFB x21,W
411E:  MOVWF  03
4120:  MOVFF  00,01
4124:  MOVWF  02
.................... } 
4126:  MOVLB  0
4128:  GOTO   41D6 (RETURN)
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
*
41A6:  MOVLB  3
41A8:  MOVF   x14,W
41AA:  IORWF  x15,W
41AC:  BZ    41B6
41AE:  MOVFF  315,03
41B2:  MOVF   x14,W
41B4:  BRA    41BC
41B6:  MOVFF  4A,03
41BA:  MOVF   49,W
41BC:  MOVWF  x18
41BE:  MOVFF  03,319
....................    beg += strspn(beg, s2); 
41C2:  MOVFF  319,31D
41C6:  MOVFF  318,31C
41CA:  MOVFF  317,31F
41CE:  MOVFF  316,31E
41D2:  MOVLB  0
41D4:  BRA    4098
41D6:  MOVF   01,W
41D8:  MOVLB  3
41DA:  ADDWF  x18,F
41DC:  MOVF   02,W
41DE:  ADDWFC x19,F
....................    if (*beg == '\0') 
41E0:  MOVFF  319,03
41E4:  MOVFF  318,FE9
41E8:  MOVFF  319,FEA
41EC:  MOVF   FEF,F
41EE:  BNZ   4204
....................    { 
....................       *save = ' '; 
41F0:  MOVFF  49,FE9
41F4:  MOVFF  4A,FEA
41F8:  MOVLW  20
41FA:  MOVWF  FEF
....................       return(0); 
41FC:  MOVLW  00
41FE:  MOVWF  01
4200:  MOVWF  02
4202:  BRA    4252
....................    } 
....................    end = strpbrk(beg, s2); 
4204:  MOVFF  319,31D
4208:  MOVFF  318,31C
420C:  MOVFF  317,31F
4210:  MOVFF  316,31E
4214:  MOVLB  0
4216:  BRA    412C
4218:  MOVFF  02,31B
421C:  MOVFF  01,31A
....................    if (*end != '\0') 
4220:  MOVFF  31B,03
4224:  MOVLB  3
4226:  MOVFF  31A,FE9
422A:  MOVFF  31B,FEA
422E:  MOVF   FEF,F
4230:  BZ    4242
....................    { 
....................       *end = '\0'; 
4232:  MOVFF  31A,FE9
4236:  MOVFF  31B,FEA
423A:  CLRF   FEF
....................       end++; 
423C:  INCF   x1A,F
423E:  BTFSC  FD8.2
4240:  INCF   x1B,F
....................    } 
....................    save = end; 
4242:  MOVFF  31B,4A
4246:  MOVFF  31A,49
....................    return(beg); 
424A:  MOVFF  318,01
424E:  MOVFF  319,02
.................... } 
4252:  MOVLB  0
4254:  RETLW  00
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
46A0:  MOVFF  33F,341
46A4:  MOVFF  33E,340
46A8:  MOVFF  341,03
46AC:  MOVLB  3
46AE:  MOVFF  340,FE9
46B2:  MOVFF  341,FEA
46B6:  MOVF   FEF,F
46B8:  BZ    46C6
46BA:  INCF   x40,F
46BC:  BTFSC  FD8.2
46BE:  INCF   x41,F
46C0:  MOVLB  0
46C2:  BRA    46A8
46C4:  MOVLB  3
....................    return(sc - s); 
46C6:  MOVF   x3E,W
46C8:  SUBWF  x40,W
46CA:  MOVWF  00
46CC:  MOVF   x3F,W
46CE:  SUBWFB x41,W
46D0:  MOVWF  03
46D2:  MOVFF  00,01
46D6:  MOVWF  02
.................... } 
46D8:  MOVLB  0
46DA:  RETLW  00
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
*
48A2:  MOVLB  3
48A4:  MOVFF  32C,FE9
48A8:  MOVFF  32D,FEA
48AC:  MOVFF  FEF,330
48B0:  MOVFF  32F,03
48B4:  MOVFF  32E,FE9
48B8:  MOVFF  32F,FEA
48BC:  MOVF   FEF,W
48BE:  SUBWF  x30,W
48C0:  BZ    4952
48C2:  MOVFF  32D,03
48C6:  MOVFF  32C,FE9
48CA:  MOVFF  32D,FEA
48CE:  MOVFF  FEF,331
48D2:  MOVF   x31,W
48D4:  SUBLW  40
48D6:  BC    48DE
48D8:  MOVF   x31,W
48DA:  SUBLW  5A
48DC:  BC    48EA
48DE:  MOVF   x31,W
48E0:  SUBLW  60
48E2:  BC    497C
48E4:  MOVF   x31,W
48E6:  SUBLW  7A
48E8:  BNC   497C
48EA:  MOVFF  32F,03
48EE:  MOVFF  32E,FE9
48F2:  MOVFF  32F,FEA
48F6:  MOVFF  FEF,332
48FA:  MOVF   x32,W
48FC:  SUBLW  40
48FE:  BC    4906
4900:  MOVF   x32,W
4902:  SUBLW  5A
4904:  BC    4912
4906:  MOVF   x32,W
4908:  SUBLW  60
490A:  BC    497C
490C:  MOVF   x32,W
490E:  SUBLW  7A
4910:  BNC   497C
4912:  MOVFF  32C,FE9
4916:  MOVFF  32D,FEA
491A:  MOVFF  FEF,333
491E:  MOVFF  32F,03
4922:  MOVFF  32E,FE9
4926:  MOVFF  32F,FEA
492A:  MOVLW  20
492C:  ADDWF  FEF,W
492E:  SUBWF  x33,W
4930:  BZ    4952
4932:  MOVFF  32E,FE9
4936:  MOVFF  32F,FEA
493A:  MOVFF  FEF,335
493E:  MOVFF  32D,03
4942:  MOVFF  32C,FE9
4946:  MOVFF  32D,FEA
494A:  MOVLW  20
494C:  ADDWF  FEF,W
494E:  SUBWF  x35,W
4950:  BNZ   497C
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
4952:  MOVFF  32D,03
4956:  MOVFF  32C,FE9
495A:  MOVFF  32D,FEA
495E:  MOVF   FEF,F
4960:  BNZ   4968
....................        return(0); 
4962:  MOVLW  00
4964:  MOVWF  01
4966:  BRA    49A6
4968:  MOVFF  32D,03
496C:  MOVF   x2C,W
496E:  INCF   x2C,F
4970:  BTFSC  FD8.2
4972:  INCF   x2D,F
4974:  INCF   x2E,F
4976:  BTFSC  FD8.2
4978:  INCF   x2F,F
497A:  BRA    48A4
....................  return((*s1 < *s2) ? -1: 1); 
497C:  MOVFF  32D,03
4980:  MOVFF  32C,FE9
4984:  MOVFF  32D,FEA
4988:  MOVFF  FEF,330
498C:  MOVFF  32F,03
4990:  MOVFF  32E,FE9
4994:  MOVFF  32F,FEA
4998:  MOVF   FEF,W
499A:  SUBWF  x30,W
499C:  BC    49A2
499E:  MOVLW  FF
49A0:  BRA    49A4
49A2:  MOVLW  01
49A4:  MOVWF  01
.................... } 
49A6:  MOVLB  0
49A8:  RETLW  00
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float atof(char * s); 
....................  
....................  
.................... #if defined(__PCD__) 
....................  
.................... /* Standard template:  atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float32 atof(char * s); 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float48 atof48(char * s); 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float64 atof64(char * s); 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: float32 strtod(char * s,char *endptr) 
....................  * converts the initial portion of the string s to a float32 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
....................  // This function is called strtod in PCM/PCH 
....................  // This ensures compatibility between compilers 
.................... #if !defined(__PCD__) 
.................... float strtod(char *s,char *endptr);  
.................... #endif 
....................  
.................... /* Standart template: float32 strto(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... #if defined(__PCD__) 
.................... float32 strtof(char *s,char *endptr); 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #endif 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8 *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8 *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
.................... #if !defined(__PCD__) 
....................  
.................... float atof(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atof(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
....................  
....................  
.................... float48 atof48(char * s) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10;  
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... float64 atof64(char * s) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
4A72:  MOVLB  3
4A74:  CLRF   x31
....................    sign = 0; 
4A76:  CLRF   x2F
....................    base = 10; 
4A78:  MOVLW  0A
4A7A:  MOVWF  x30
....................    result = 0; 
4A7C:  CLRF   x2E
....................  
....................    if (!s) 
4A7E:  MOVF   x2C,W
4A80:  IORWF  x2D,W
4A82:  BNZ   4A8A
....................       return 0; 
4A84:  MOVLW  00
4A86:  MOVWF  01
4A88:  BRA    4C10
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
4A8A:  MOVF   x31,W
4A8C:  INCF   x31,F
4A8E:  CLRF   03
4A90:  ADDWF  x2C,W
4A92:  MOVWF  FE9
4A94:  MOVF   x2D,W
4A96:  ADDWFC 03,W
4A98:  MOVWF  FEA
4A9A:  MOVFF  FEF,332
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
4A9E:  MOVF   x32,W
4AA0:  SUBLW  2D
4AA2:  BNZ   4ABE
....................    { 
....................       sign = 1;         // Set the sign to negative 
4AA4:  MOVLW  01
4AA6:  MOVWF  x2F
....................       c = s[index++]; 
4AA8:  MOVF   x31,W
4AAA:  INCF   x31,F
4AAC:  CLRF   03
4AAE:  ADDWF  x2C,W
4AB0:  MOVWF  FE9
4AB2:  MOVF   x2D,W
4AB4:  ADDWFC 03,W
4AB6:  MOVWF  FEA
4AB8:  MOVFF  FEF,332
....................    } 
....................    else if (c == '+') 
4ABC:  BRA    4AD8
4ABE:  MOVF   x32,W
4AC0:  SUBLW  2B
4AC2:  BNZ   4AD8
....................    { 
....................       c = s[index++]; 
4AC4:  MOVF   x31,W
4AC6:  INCF   x31,F
4AC8:  CLRF   03
4ACA:  ADDWF  x2C,W
4ACC:  MOVWF  FE9
4ACE:  MOVF   x2D,W
4AD0:  ADDWFC 03,W
4AD2:  MOVWF  FEA
4AD4:  MOVFF  FEF,332
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
4AD8:  MOVF   x32,W
4ADA:  SUBLW  2F
4ADC:  BTFSC  FD8.0
4ADE:  BRA    4C00
4AE0:  MOVF   x32,W
4AE2:  SUBLW  39
4AE4:  BTFSS  FD8.0
4AE6:  BRA    4C00
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
4AE8:  MOVF   x32,W
4AEA:  SUBLW  30
4AEC:  BNZ   4B30
4AEE:  CLRF   03
4AF0:  MOVF   x31,W
4AF2:  ADDWF  x2C,W
4AF4:  MOVWF  FE9
4AF6:  MOVF   x2D,W
4AF8:  ADDWFC 03,W
4AFA:  MOVWF  FEA
4AFC:  MOVF   FEF,W
4AFE:  SUBLW  78
4B00:  BZ    4B16
4B02:  CLRF   03
4B04:  MOVF   x31,W
4B06:  ADDWF  x2C,W
4B08:  MOVWF  FE9
4B0A:  MOVF   x2D,W
4B0C:  ADDWFC 03,W
4B0E:  MOVWF  FEA
4B10:  MOVF   FEF,W
4B12:  SUBLW  58
4B14:  BNZ   4B30
....................       { 
....................          base = 16; 
4B16:  MOVLW  10
4B18:  MOVWF  x30
....................          index++; 
4B1A:  INCF   x31,F
....................          c = s[index++]; 
4B1C:  MOVF   x31,W
4B1E:  INCF   x31,F
4B20:  CLRF   03
4B22:  ADDWF  x2C,W
4B24:  MOVWF  FE9
4B26:  MOVF   x2D,W
4B28:  ADDWFC 03,W
4B2A:  MOVWF  FEA
4B2C:  MOVFF  FEF,332
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
4B30:  MOVF   x30,W
4B32:  SUBLW  0A
4B34:  BNZ   4B70
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
4B36:  MOVF   x32,W
4B38:  SUBLW  2F
4B3A:  BC    4B6E
4B3C:  MOVF   x32,W
4B3E:  SUBLW  39
4B40:  BNC   4B6E
....................             result = 10*result + (c - '0'); 
4B42:  MOVLW  0A
4B44:  MOVWF  x33
4B46:  MOVFF  32E,334
4B4A:  MOVLB  0
4B4C:  BRA    4A22
4B4E:  MOVLW  30
4B50:  MOVLB  3
4B52:  SUBWF  x32,W
4B54:  ADDWF  01,W
4B56:  MOVWF  x2E
....................             c = s[index++]; 
4B58:  MOVF   x31,W
4B5A:  INCF   x31,F
4B5C:  CLRF   03
4B5E:  ADDWF  x2C,W
4B60:  MOVWF  FE9
4B62:  MOVF   x2D,W
4B64:  ADDWFC 03,W
4B66:  MOVWF  FEA
4B68:  MOVFF  FEF,332
....................          } 
4B6C:  BRA    4B36
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
4B6E:  BRA    4C00
4B70:  MOVF   x30,W
4B72:  SUBLW  10
4B74:  BNZ   4C00
....................       { 
....................          c = toupper(c); 
4B76:  MOVF   x32,W
4B78:  SUBLW  60
4B7A:  BC    4B88
4B7C:  MOVF   x32,W
4B7E:  SUBLW  7A
4B80:  BNC   4B88
4B82:  MOVF   x32,W
4B84:  ANDLW  DF
4B86:  BRA    4B8A
4B88:  MOVF   x32,W
4B8A:  MOVWF  x32
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
4B8C:  MOVF   x32,W
4B8E:  SUBLW  2F
4B90:  BC    4B98
4B92:  MOVF   x32,W
4B94:  SUBLW  39
4B96:  BC    4BA4
4B98:  MOVF   x32,W
4B9A:  SUBLW  40
4B9C:  BC    4C00
4B9E:  MOVF   x32,W
4BA0:  SUBLW  46
4BA2:  BNC   4C00
....................             if (c >= '0' && c <= '9') 
4BA4:  MOVF   x32,W
4BA6:  SUBLW  2F
4BA8:  BC    4BC2
4BAA:  MOVF   x32,W
4BAC:  SUBLW  39
4BAE:  BNC   4BC2
....................                result = (result << 4) + (c - '0'); 
4BB0:  SWAPF  x2E,W
4BB2:  MOVWF  x33
4BB4:  MOVLW  F0
4BB6:  ANDWF  x33,F
4BB8:  MOVLW  30
4BBA:  SUBWF  x32,W
4BBC:  ADDWF  x33,W
4BBE:  MOVWF  x2E
....................             else 
4BC0:  BRA    4BD4
....................                result = (result << 4) + (c - 'A' + 10); 
4BC2:  SWAPF  x2E,W
4BC4:  MOVWF  x33
4BC6:  MOVLW  F0
4BC8:  ANDWF  x33,F
4BCA:  MOVLW  41
4BCC:  SUBWF  x32,W
4BCE:  ADDLW  0A
4BD0:  ADDWF  x33,W
4BD2:  MOVWF  x2E
....................  
....................             c = s[index++]; 
4BD4:  MOVF   x31,W
4BD6:  INCF   x31,F
4BD8:  CLRF   03
4BDA:  ADDWF  x2C,W
4BDC:  MOVWF  FE9
4BDE:  MOVF   x2D,W
4BE0:  ADDWFC 03,W
4BE2:  MOVWF  FEA
4BE4:  MOVFF  FEF,332
....................             c = toupper(c); 
4BE8:  MOVF   x32,W
4BEA:  SUBLW  60
4BEC:  BC    4BFA
4BEE:  MOVF   x32,W
4BF0:  SUBLW  7A
4BF2:  BNC   4BFA
4BF4:  MOVF   x32,W
4BF6:  ANDLW  DF
4BF8:  BRA    4BFC
4BFA:  MOVF   x32,W
4BFC:  MOVWF  x32
....................          } 
4BFE:  BRA    4B8C
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
4C00:  DECFSZ x2F,W
4C02:  BRA    4C0C
4C04:  MOVF   x30,W
4C06:  SUBLW  0A
4C08:  BNZ   4C0C
....................        result = -result; 
4C0A:  NEGF   x2E
....................  
....................    return(result); 
4C0C:  MOVFF  32E,01
.................... } 
4C10:  MOVLB  0
4C12:  RETLW  00
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
4D74:  MOVLB  3
4D76:  CLRF   x18
....................    sign = 0; 
4D78:  CLRF   x16
....................    base = 10; 
4D7A:  MOVLW  0A
4D7C:  MOVWF  x17
....................    result = 0; 
4D7E:  CLRF   x15
4D80:  CLRF   x14
....................  
....................    if (!s) 
4D82:  MOVF   x12,W
4D84:  IORWF  x13,W
4D86:  BNZ   4D90
....................       return 0; 
4D88:  MOVLW  00
4D8A:  MOVWF  01
4D8C:  MOVWF  02
4D8E:  BRA    4F62
....................    c = s[index++]; 
4D90:  MOVF   x18,W
4D92:  INCF   x18,F
4D94:  CLRF   03
4D96:  ADDWF  x12,W
4D98:  MOVWF  FE9
4D9A:  MOVF   x13,W
4D9C:  ADDWFC 03,W
4D9E:  MOVWF  FEA
4DA0:  MOVFF  FEF,319
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
4DA4:  MOVF   x19,W
4DA6:  SUBLW  2D
4DA8:  BNZ   4DC4
....................    { 
....................       sign = 1;         // Set the sign to negative 
4DAA:  MOVLW  01
4DAC:  MOVWF  x16
....................       c = s[index++]; 
4DAE:  MOVF   x18,W
4DB0:  INCF   x18,F
4DB2:  CLRF   03
4DB4:  ADDWF  x12,W
4DB6:  MOVWF  FE9
4DB8:  MOVF   x13,W
4DBA:  ADDWFC 03,W
4DBC:  MOVWF  FEA
4DBE:  MOVFF  FEF,319
....................    } 
....................    else if (c == '+') 
4DC2:  BRA    4DDE
4DC4:  MOVF   x19,W
4DC6:  SUBLW  2B
4DC8:  BNZ   4DDE
....................    { 
....................       c = s[index++]; 
4DCA:  MOVF   x18,W
4DCC:  INCF   x18,F
4DCE:  CLRF   03
4DD0:  ADDWF  x12,W
4DD2:  MOVWF  FE9
4DD4:  MOVF   x13,W
4DD6:  ADDWFC 03,W
4DD8:  MOVWF  FEA
4DDA:  MOVFF  FEF,319
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
4DDE:  MOVF   x19,W
4DE0:  SUBLW  2F
4DE2:  BTFSC  FD8.0
4DE4:  BRA    4F46
4DE6:  MOVF   x19,W
4DE8:  SUBLW  39
4DEA:  BTFSS  FD8.0
4DEC:  BRA    4F46
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
4DEE:  MOVF   x19,W
4DF0:  SUBLW  30
4DF2:  BNZ   4E36
4DF4:  CLRF   03
4DF6:  MOVF   x18,W
4DF8:  ADDWF  x12,W
4DFA:  MOVWF  FE9
4DFC:  MOVF   x13,W
4DFE:  ADDWFC 03,W
4E00:  MOVWF  FEA
4E02:  MOVF   FEF,W
4E04:  SUBLW  78
4E06:  BZ    4E1C
4E08:  CLRF   03
4E0A:  MOVF   x18,W
4E0C:  ADDWF  x12,W
4E0E:  MOVWF  FE9
4E10:  MOVF   x13,W
4E12:  ADDWFC 03,W
4E14:  MOVWF  FEA
4E16:  MOVF   FEF,W
4E18:  SUBLW  58
4E1A:  BNZ   4E36
....................       { 
....................          base = 16; 
4E1C:  MOVLW  10
4E1E:  MOVWF  x17
....................          index++; 
4E20:  INCF   x18,F
....................          c = s[index++]; 
4E22:  MOVF   x18,W
4E24:  INCF   x18,F
4E26:  CLRF   03
4E28:  ADDWF  x12,W
4E2A:  MOVWF  FE9
4E2C:  MOVF   x13,W
4E2E:  ADDWFC 03,W
4E30:  MOVWF  FEA
4E32:  MOVFF  FEF,319
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
4E36:  MOVF   x17,W
4E38:  SUBLW  0A
4E3A:  BNZ   4E84
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
4E3C:  MOVF   x19,W
4E3E:  SUBLW  2F
4E40:  BC    4E82
4E42:  MOVF   x19,W
4E44:  SUBLW  39
4E46:  BNC   4E82
....................             result = 10*result + (c - '0'); 
4E48:  CLRF   x61
4E4A:  MOVLW  0A
4E4C:  MOVWF  x60
4E4E:  MOVFF  315,363
4E52:  MOVFF  314,362
4E56:  MOVLB  0
4E58:  CALL   4312
4E5C:  MOVLW  30
4E5E:  MOVLB  3
4E60:  SUBWF  x19,W
4E62:  ADDWF  01,W
4E64:  MOVWF  x14
4E66:  MOVLW  00
4E68:  ADDWFC 02,W
4E6A:  MOVWF  x15
....................             c = s[index++]; 
4E6C:  MOVF   x18,W
4E6E:  INCF   x18,F
4E70:  CLRF   03
4E72:  ADDWF  x12,W
4E74:  MOVWF  FE9
4E76:  MOVF   x13,W
4E78:  ADDWFC 03,W
4E7A:  MOVWF  FEA
4E7C:  MOVFF  FEF,319
....................          } 
4E80:  BRA    4E3C
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
4E82:  BRA    4F46
4E84:  MOVF   x17,W
4E86:  SUBLW  10
4E88:  BNZ   4F46
....................       { 
....................          c = toupper(c); 
4E8A:  MOVF   x19,W
4E8C:  SUBLW  60
4E8E:  BC    4E9C
4E90:  MOVF   x19,W
4E92:  SUBLW  7A
4E94:  BNC   4E9C
4E96:  MOVF   x19,W
4E98:  ANDLW  DF
4E9A:  BRA    4E9E
4E9C:  MOVF   x19,W
4E9E:  MOVWF  x19
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
4EA0:  MOVF   x19,W
4EA2:  SUBLW  2F
4EA4:  BC    4EAC
4EA6:  MOVF   x19,W
4EA8:  SUBLW  39
4EAA:  BC    4EB8
4EAC:  MOVF   x19,W
4EAE:  SUBLW  40
4EB0:  BC    4F46
4EB2:  MOVF   x19,W
4EB4:  SUBLW  46
4EB6:  BNC   4F46
....................             if (c >= '0' && c <= '9') 
4EB8:  MOVF   x19,W
4EBA:  SUBLW  2F
4EBC:  BC    4EF0
4EBE:  MOVF   x19,W
4EC0:  SUBLW  39
4EC2:  BNC   4EF0
....................                result = (result << 4) + (c - '0'); 
4EC4:  RLCF   x14,W
4EC6:  MOVWF  x1A
4EC8:  RLCF   x15,W
4ECA:  MOVWF  x1B
4ECC:  RLCF   x1A,F
4ECE:  RLCF   x1B,F
4ED0:  RLCF   x1A,F
4ED2:  RLCF   x1B,F
4ED4:  RLCF   x1A,F
4ED6:  RLCF   x1B,F
4ED8:  MOVLW  F0
4EDA:  ANDWF  x1A,F
4EDC:  MOVLW  30
4EDE:  SUBWF  x19,W
4EE0:  ADDWF  x1A,W
4EE2:  MOVWF  01
4EE4:  MOVLW  00
4EE6:  ADDWFC x1B,W
4EE8:  MOVFF  01,314
4EEC:  MOVWF  x15
....................             else 
4EEE:  BRA    4F1C
....................                result = (result << 4) + (c - 'A' + 10); 
4EF0:  RLCF   x14,W
4EF2:  MOVWF  x1A
4EF4:  RLCF   x15,W
4EF6:  MOVWF  x1B
4EF8:  RLCF   x1A,F
4EFA:  RLCF   x1B,F
4EFC:  RLCF   x1A,F
4EFE:  RLCF   x1B,F
4F00:  RLCF   x1A,F
4F02:  RLCF   x1B,F
4F04:  MOVLW  F0
4F06:  ANDWF  x1A,F
4F08:  MOVLW  41
4F0A:  SUBWF  x19,W
4F0C:  ADDLW  0A
4F0E:  ADDWF  x1A,W
4F10:  MOVWF  01
4F12:  MOVLW  00
4F14:  ADDWFC x1B,W
4F16:  MOVFF  01,314
4F1A:  MOVWF  x15
....................  
....................             c = s[index++];c = toupper(c); 
4F1C:  MOVF   x18,W
4F1E:  INCF   x18,F
4F20:  CLRF   03
4F22:  ADDWF  x12,W
4F24:  MOVWF  FE9
4F26:  MOVF   x13,W
4F28:  ADDWFC 03,W
4F2A:  MOVWF  FEA
4F2C:  MOVF   FEF,W
4F2E:  MOVWF  x19
4F30:  SUBLW  60
4F32:  BC    4F40
4F34:  MOVF   x19,W
4F36:  SUBLW  7A
4F38:  BNC   4F40
4F3A:  MOVF   x19,W
4F3C:  ANDLW  DF
4F3E:  BRA    4F42
4F40:  MOVF   x19,W
4F42:  MOVWF  x19
....................          } 
4F44:  BRA    4EA0
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
4F46:  MOVF   x17,W
4F48:  SUBLW  0A
4F4A:  BNZ   4F5A
4F4C:  DECFSZ x16,W
4F4E:  BRA    4F5A
....................       result = -result; 
4F50:  COMF   x14,F
4F52:  COMF   x15,F
4F54:  INCF   x14,F
4F56:  BTFSC  FD8.2
4F58:  INCF   x15,F
....................  
....................    return(result); 
4F5A:  MOVFF  314,01
4F5E:  MOVFF  315,02
.................... } 
4F62:  MOVLB  0
4F64:  GOTO   63AA (RETURN)
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if !defined(__PCD__) 
.................... float strtod(char *s,char *endptr) { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 strtof(char *s,char *endptr) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float48 strtof48(char *s,char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s,char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
*
4334:  MOVLB  3
4336:  CLRF   x37
4338:  CLRF   x38
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
433A:  MOVLW  30
433C:  MOVWF  x3A
433E:  MOVLW  31
4340:  MOVWF  x3B
4342:  MOVLW  32
4344:  MOVWF  x3C
4346:  MOVLW  33
4348:  MOVWF  x3D
434A:  MOVLW  34
434C:  MOVWF  x3E
434E:  MOVLW  35
4350:  MOVWF  x3F
4352:  MOVLW  36
4354:  MOVWF  x40
4356:  MOVLW  37
4358:  MOVWF  x41
435A:  MOVLW  38
435C:  MOVWF  x42
435E:  MOVLW  39
4360:  MOVWF  x43
4362:  MOVLW  61
4364:  MOVWF  x44
4366:  MOVLW  62
4368:  MOVWF  x45
436A:  MOVLW  63
436C:  MOVWF  x46
436E:  MOVLW  64
4370:  MOVWF  x47
4372:  MOVLW  65
4374:  MOVWF  x48
4376:  MOVLW  66
4378:  MOVWF  x49
437A:  MOVLW  67
437C:  MOVWF  x4A
437E:  MOVLW  68
4380:  MOVWF  x4B
4382:  MOVLW  69
4384:  MOVWF  x4C
4386:  MOVLW  6A
4388:  MOVWF  x4D
438A:  MOVLW  6B
438C:  MOVWF  x4E
438E:  MOVLW  6C
4390:  MOVWF  x4F
4392:  MOVLW  6D
4394:  MOVWF  x50
4396:  MOVLW  6E
4398:  MOVWF  x51
439A:  MOVLW  6F
439C:  MOVWF  x52
439E:  MOVLW  70
43A0:  MOVWF  x53
43A2:  MOVLW  71
43A4:  MOVWF  x54
43A6:  MOVLW  73
43A8:  MOVWF  x55
43AA:  MOVLW  74
43AC:  MOVWF  x56
43AE:  MOVLW  75
43B0:  MOVWF  x57
43B2:  MOVLW  76
43B4:  MOVWF  x58
43B6:  MOVLW  77
43B8:  MOVWF  x59
43BA:  MOVLW  78
43BC:  MOVWF  x5A
43BE:  MOVLW  79
43C0:  MOVWF  x5B
43C2:  MOVLW  7A
43C4:  MOVWF  x5C
43C6:  CLRF   x5D
....................    for(sc=s;isspace(*sc);++sc); 
43C8:  MOVFF  32D,332
43CC:  MOVFF  32C,331
43D0:  MOVFF  332,03
43D4:  MOVFF  331,FE9
43D8:  MOVFF  332,FEA
43DC:  MOVF   FEF,W
43DE:  SUBLW  20
43E0:  BNZ   43EA
43E2:  INCF   x31,F
43E4:  BTFSC  FD8.2
43E6:  INCF   x32,F
43E8:  BRA    43D0
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
43EA:  MOVFF  332,03
43EE:  MOVFF  331,FE9
43F2:  MOVFF  332,FEA
43F6:  MOVF   FEF,W
43F8:  SUBLW  2D
43FA:  BZ    440E
43FC:  MOVFF  332,03
4400:  MOVFF  331,FE9
4404:  MOVFF  332,FEA
4408:  MOVF   FEF,W
440A:  SUBLW  2B
440C:  BNZ   4424
440E:  MOVFF  332,03
4412:  MOVF   x31,W
4414:  INCF   x31,F
4416:  BTFSC  FD8.2
4418:  INCF   x32,F
441A:  MOVWF  FE9
441C:  MOVFF  03,FEA
4420:  MOVF   FEF,W
4422:  BRA    4426
4424:  MOVLW  2B
4426:  MOVWF  x39
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
4428:  MOVF   x39,W
442A:  SUBLW  2D
442C:  BZ    4442
442E:  BTFSC  x30.7
4430:  BRA    4442
4432:  DECFSZ x30,W
4434:  BRA    4438
4436:  BRA    4442
4438:  BTFSC  x30.7
443A:  BRA    4446
443C:  MOVF   x30,W
443E:  SUBLW  24
4440:  BC    4446
....................    goto StrtoulGO; 
4442:  BRA    465A
....................  
....................    else if (base) 
4444:  BRA    454E
4446:  MOVF   x30,F
4448:  BZ    44E2
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
444A:  MOVF   x30,W
444C:  SUBLW  10
444E:  BNZ   448E
4450:  MOVFF  332,03
4454:  MOVFF  331,FE9
4458:  MOVFF  332,FEA
445C:  MOVF   FEF,W
445E:  SUBLW  30
4460:  BNZ   448E
4462:  MOVLW  01
4464:  ADDWF  x31,W
4466:  MOVWF  FE9
4468:  MOVLW  00
446A:  ADDWFC x32,W
446C:  MOVWF  FEA
446E:  MOVF   FEF,W
4470:  SUBLW  78
4472:  BZ    4486
4474:  MOVLW  01
4476:  ADDWF  x31,W
4478:  MOVWF  FE9
447A:  MOVLW  00
447C:  ADDWFC x32,W
447E:  MOVWF  FEA
4480:  MOVF   FEF,W
4482:  SUBLW  58
4484:  BNZ   448E
....................          sc+=2; 
4486:  MOVLW  02
4488:  ADDWF  x31,F
448A:  MOVLW  00
448C:  ADDWFC x32,F
....................       if(base==8 && *sc =='0') 
448E:  MOVF   x30,W
4490:  SUBLW  08
4492:  BNZ   44AE
4494:  MOVFF  332,03
4498:  MOVFF  331,FE9
449C:  MOVFF  332,FEA
44A0:  MOVF   FEF,W
44A2:  SUBLW  30
44A4:  BNZ   44AE
....................          sc+=1; 
44A6:  MOVLW  01
44A8:  ADDWF  x31,F
44AA:  MOVLW  00
44AC:  ADDWFC x32,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
44AE:  MOVF   x30,W
44B0:  SUBLW  02
44B2:  BNZ   44E0
44B4:  MOVFF  332,03
44B8:  MOVFF  331,FE9
44BC:  MOVFF  332,FEA
44C0:  MOVF   FEF,W
44C2:  SUBLW  30
44C4:  BNZ   44E0
44C6:  MOVLW  01
44C8:  ADDWF  x31,W
44CA:  MOVWF  FE9
44CC:  MOVLW  00
44CE:  ADDWFC x32,W
44D0:  MOVWF  FEA
44D2:  MOVF   FEF,W
44D4:  SUBLW  62
44D6:  BNZ   44E0
....................          sc+=2; 
44D8:  MOVLW  02
44DA:  ADDWF  x31,F
44DC:  MOVLW  00
44DE:  ADDWFC x32,F
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
44E0:  BRA    454E
44E2:  MOVFF  332,03
44E6:  MOVFF  331,FE9
44EA:  MOVFF  332,FEA
44EE:  MOVF   FEF,W
44F0:  SUBLW  30
44F2:  BZ    44FA
....................       base=10; 
44F4:  MOVLW  0A
44F6:  MOVWF  x30
....................    else if (sc[1]=='x' || sc[1]=='X') 
44F8:  BRA    454E
44FA:  MOVLW  01
44FC:  ADDWF  x31,W
44FE:  MOVWF  FE9
4500:  MOVLW  00
4502:  ADDWFC x32,W
4504:  MOVWF  FEA
4506:  MOVF   FEF,W
4508:  SUBLW  78
450A:  BZ    451E
450C:  MOVLW  01
450E:  ADDWF  x31,W
4510:  MOVWF  FE9
4512:  MOVLW  00
4514:  ADDWFC x32,W
4516:  MOVWF  FEA
4518:  MOVF   FEF,W
451A:  SUBLW  58
451C:  BNZ   452C
....................       base =16,sc+=2; 
451E:  MOVLW  10
4520:  MOVWF  x30
4522:  MOVLW  02
4524:  ADDWF  x31,F
4526:  MOVLW  00
4528:  ADDWFC x32,F
....................    else if(sc[1]=='b') 
452A:  BRA    454E
452C:  MOVLW  01
452E:  ADDWF  x31,W
4530:  MOVWF  FE9
4532:  MOVLW  00
4534:  ADDWFC x32,W
4536:  MOVWF  FEA
4538:  MOVF   FEF,W
453A:  SUBLW  62
453C:  BNZ   454A
....................       base=2,sc+=2; 
453E:  MOVLW  02
4540:  MOVWF  x30
4542:  ADDWF  x31,F
4544:  MOVLW  00
4546:  ADDWFC x32,F
....................    else 
4548:  BRA    454E
....................       base=8; 
454A:  MOVLW  08
454C:  MOVWF  x30
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
454E:  MOVFF  332,334
4552:  MOVFF  331,333
4556:  MOVFF  332,03
455A:  MOVFF  331,FE9
455E:  MOVFF  332,FEA
4562:  MOVF   FEF,W
4564:  SUBLW  30
4566:  BNZ   4570
4568:  INCF   x31,F
456A:  BTFSC  FD8.2
456C:  INCF   x32,F
456E:  BRA    4556
....................    sd=memchr(digits,tolower(*sc),base); 
4570:  MOVFF  332,03
4574:  MOVFF  331,FE9
4578:  MOVFF  332,FEA
457C:  MOVFF  FEF,35E
4580:  MOVF   x5E,W
4582:  SUBLW  40
4584:  BC    4592
4586:  MOVF   x5E,W
4588:  SUBLW  5A
458A:  BNC   4592
458C:  MOVF   x5E,W
458E:  IORLW  20
4590:  BRA    4594
4592:  MOVF   x5E,W
4594:  MOVWF  x5F
4596:  MOVLW  03
4598:  MOVWF  x61
459A:  MOVLW  3A
459C:  MOVWF  x60
459E:  MOVFF  35F,362
45A2:  MOVFF  330,363
45A6:  MOVLB  0
45A8:  RCALL  42CE
45AA:  MOVFF  02,336
45AE:  MOVFF  01,335
....................    for(; sd!=0; ) 
45B2:  MOVLB  3
45B4:  MOVF   x35,F
45B6:  BNZ   45BC
45B8:  MOVF   x36,F
45BA:  BZ    464E
....................    { 
....................       x=x*base+(int16)(sd-digits); 
45BC:  CLRF   03
45BE:  MOVF   x30,W
45C0:  MOVWF  00
45C2:  BTFSC  FE8.7
45C4:  DECF   03,F
45C6:  MOVWF  x5E
45C8:  MOVFF  03,35F
45CC:  MOVFF  338,361
45D0:  MOVFF  337,360
45D4:  MOVFF  03,363
45D8:  MOVWF  x62
45DA:  MOVLB  0
45DC:  RCALL  4312
45DE:  MOVFF  01,35F
45E2:  MOVLW  3A
45E4:  MOVLB  3
45E6:  SUBWF  x35,W
45E8:  MOVWF  00
45EA:  MOVLW  03
45EC:  SUBWFB x36,W
45EE:  MOVWF  03
45F0:  MOVF   00,W
45F2:  ADDWF  01,W
45F4:  MOVWF  01
45F6:  MOVF   02,W
45F8:  ADDWFC 03,F
45FA:  MOVFF  01,337
45FE:  MOVFF  03,338
....................       ++sc; 
4602:  INCF   x31,F
4604:  BTFSC  FD8.2
4606:  INCF   x32,F
....................       sd=memchr(digits,tolower(*sc),base); 
4608:  MOVFF  332,03
460C:  MOVFF  331,FE9
4610:  MOVFF  332,FEA
4614:  MOVFF  FEF,35E
4618:  MOVF   x5E,W
461A:  SUBLW  40
461C:  BC    462A
461E:  MOVF   x5E,W
4620:  SUBLW  5A
4622:  BNC   462A
4624:  MOVF   x5E,W
4626:  IORLW  20
4628:  BRA    462C
462A:  MOVF   x5E,W
462C:  MOVWF  x5F
462E:  MOVLW  03
4630:  MOVWF  x61
4632:  MOVLW  3A
4634:  MOVWF  x60
4636:  MOVFF  35F,362
463A:  MOVFF  330,363
463E:  MOVLB  0
4640:  RCALL  42CE
4642:  MOVFF  02,336
4646:  MOVFF  01,335
....................    } 
464A:  BRA    45B2
464C:  MOVLB  3
....................    if(s1==sc) 
464E:  MOVF   x31,W
4650:  SUBWF  x33,W
4652:  BNZ   467A
4654:  MOVF   x32,W
4656:  SUBWF  x34,W
4658:  BNZ   467A
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
465A:  MOVF   x2E,W
465C:  IORWF  x2F,W
465E:  BZ    4672
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
4660:  MOVFF  32E,FE9
4664:  MOVFF  32F,FEA
4668:  MOVFF  32D,FEC
466C:  MOVF   FED,F
466E:  MOVFF  32C,FEF
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
4672:  MOVLW  00
4674:  MOVWF  01
4676:  MOVWF  02
4678:  BRA    469A
....................    } 
....................    if (endptr) 
467A:  MOVF   x2E,W
467C:  IORWF  x2F,W
467E:  BZ    4692
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
4680:  MOVFF  32E,FE9
4684:  MOVFF  32F,FEA
4688:  MOVFF  332,FEC
468C:  MOVF   FED,F
468E:  MOVFF  331,FEF
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
4692:  MOVFF  337,01
4696:  MOVFF  338,02
.................... } 
469A:  MOVLB  0
469C:  GOTO   4826 (RETURN)
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
*
0D40:  MOVFF  4E,308
0D44:  MOVFF  4D,307
0D48:  MOVFF  4C,306
0D4C:  MOVFF  4B,305
0D50:  MOVLW  41
0D52:  MOVLB  3
0D54:  MOVWF  x0C
0D56:  MOVLW  C6
0D58:  MOVWF  x0B
0D5A:  MOVLW  4E
0D5C:  MOVWF  x0A
0D5E:  MOVLW  6D
0D60:  MOVWF  x09
0D62:  MOVLB  0
0D64:  BRA    0C9A
0D66:  MOVLW  39
0D68:  MOVLB  3
0D6A:  ADDWF  00,W
0D6C:  MOVWF  4B
0D6E:  MOVLW  30
0D70:  ADDWFC 01,W
0D72:  MOVWF  4C
0D74:  MOVLW  00
0D76:  ADDWFC 02,W
0D78:  MOVWF  4D
0D7A:  MOVLW  00
0D7C:  ADDWFC 03,W
0D7E:  MOVWF  4E
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
0D80:  MOVFF  4D,00
0D84:  MOVFF  4E,01
0D88:  CLRF   02
0D8A:  CLRF   03
0D8C:  MOVFF  4E,307
0D90:  MOVFF  4D,306
0D94:  MOVFF  4E,309
0D98:  MOVFF  4D,308
0D9C:  MOVLW  7F
0D9E:  MOVWF  x0B
0DA0:  MOVLW  FF
0DA2:  MOVWF  x0A
0DA4:  MOVLB  0
0DA6:  BRA    0CF8
0DA8:  MOVFF  00,01
0DAC:  MOVFF  03,02
.................... } 
0DB0:  GOTO   0EC6 (RETURN)
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
*
0C86:  MOVFF  308,4E
0C8A:  MOVFF  307,4D
0C8E:  MOVFF  306,4C
0C92:  MOVFF  305,4B
.................... } 
0C96:  GOTO   0EC4 (RETURN)
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Functions for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.C 
....................  * Dependencies:    compiler.h 
....................  *                  helpers.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     6/25/02  Rewritten CalcIPChecksum() to avoid 
....................  *                               multi-byte shift operation. 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Howard Schlunder		2/9/05	Added hexatob(), btohexa_high(), and 
....................  *								btohexa_low() 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... /********************************************************************* 
....................  * 
....................  *            ENC28J60 registers/bits 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.h 
....................  * Description: 	Include file for ENC28J60 control registers 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		06/01/04	Original 
....................  * Howard Schlunder		06/29/04	Fixed byte boundary problems on a  
....................  *									couple of PHY register structs. 
....................  * Howard Schlunder		09/29/04	Matched with data sheet 
....................  * Howard Schlunder		01/04/06	Matched with new data sheet 
....................  * Howard Schlunder		06/29/06	Changed MACON3.PHDRLEN to PHDREN 
....................  * Howard Schlunder		07/21/06	Several bits removed to match now  
....................  *									reserved bits in rev. B data sheet  
....................  *									(DS39662B) 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef ENC28J60_H 
.................... #define ENC28J60_H 
....................  
.................... typedef union { 
.................... 	BYTE v[7]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 CollisionCount:4; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 Done:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 PacketDefer:1; 
.................... 		int8 ExcessiveDefer:1; 
.................... 		int8 MaximumCollisions:1; 
.................... 		int8 LateCollision:1; 
.................... 		int8 Giant:1; 
.................... 		int8 Underrun:1; 
.................... 		int16 	 BytesTransmittedOnWire; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PAUSEControlFrame:1; 
.................... 		int8 BackpressureApplied:1; 
.................... 		int8 VLANTaggedFrame:1; 
.................... 		int8 Zeros:4; 
.................... 	} bits; 
.................... } TXSTATUS; 
....................  
.................... typedef union { 
.................... 	char v[4]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 PreviouslyIgnored:1; 
.................... 		int8 RXDCPreviouslySeen:1; 
.................... 		int8 CarrierPreviouslySeen:1; 
.................... 		int8 CodeViolation:1; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 ReceiveOk:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 DribbleNibble:1; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PauseControlFrame:1; 
.................... 		int8 UnsupportedOpcode:1; 
.................... 		int8 VLANType:1; 
.................... 		int8 Zero:1; 
.................... 	} bits; 
.................... } RXSTATUS; 
....................  
.................... /****************************************************************************** 
.................... * Register locations 
.................... ******************************************************************************/ 
.................... // Bank 0 registers -------- 
.................... #define ERDPTL		0x00 
.................... #define ERDPTH		0x01 
.................... #define EWRPTL		0x02 
.................... #define EWRPTH		0x03 
.................... #define ETXSTL		0x04 
.................... #define ETXSTH		0x05 
.................... #define ETXNDL		0x06 
.................... #define ETXNDH		0x07 
.................... #define ERXSTL		0x08 
.................... #define ERXSTH		0x09 
.................... #define ERXNDL		0x0A 
.................... #define ERXNDH		0x0B 
.................... #define ERXRDPTL	0x0C 
.................... #define ERXRDPTH	0x0D 
.................... #define ERXWRPTL	0x0E 
.................... #define ERXWRPTH	0x0F 
.................... #define EDMASTL		0x10 
.................... #define EDMASTH		0x11 
.................... #define EDMANDL		0x12 
.................... #define EDMANDH		0x13 
.................... #define EDMADSTL	0x14 
.................... #define EDMADSTH	0x15 
.................... #define EDMACSL		0x16 
.................... #define EDMACSH		0x17 
.................... //#define			0x18 
.................... //#define			0x19 
.................... //#define r			0x1A 
.................... #define EIE			0x1B 
.................... #define EIR			0x1C 
.................... #define ESTAT		0x1D 
.................... #define ECON2		0x1E 
.................... #define ECON1		0x1F 
....................  
.................... // Bank 1 registers ----- 
.................... #define EHT0		0x100 
.................... #define EHT1		0x101 
.................... #define EHT2		0x102 
.................... #define EHT3		0x103 
.................... #define EHT4		0x104 
.................... #define EHT5		0x105 
.................... #define EHT6		0x106 
.................... #define EHT7		0x107 
.................... #define EPMM0		0x108 
.................... #define EPMM1		0x109 
.................... #define EPMM2		0x10A 
.................... #define EPMM3		0x10B 
.................... #define EPMM4		0x10C 
.................... #define EPMM5		0x10D 
.................... #define EPMM6		0x10E 
.................... #define EPMM7		0x10F 
.................... #define EPMCSL		0x110 
.................... #define EPMCSH		0x111 
.................... //#define			0x112 
.................... //#define			0x113 
.................... #define EPMOL		0x114 
.................... #define EPMOH		0x115 
.................... //#define r			0x116 
.................... //#define r			0x117 
.................... #define ERXFCON		0x118 
.................... #define EPKTCNT		0x119 
.................... //#define r			0x11A 
.................... //#define EIE		0x11B 
.................... //#define EIR		0x11C 
.................... //#define ESTAT		0x11D 
.................... //#define ECON2		0x11E 
.................... //#define ECON1		0x11F 
....................  
.................... // Bank 2 registers ----- 
.................... #define MACON1		0x200 
.................... #define MACON2    0x201 
.................... //#define r			0x201 
.................... #define MACON3		0x202 
.................... #define MACON4		0x203 
.................... #define MABBIPG		0x204 
.................... //#define			0x205 
.................... #define MAIPGL		0x206 
.................... #define MAIPGH		0x207 
.................... #define MACLCON1	0x208 
.................... #define MACLCON2	0x209 
.................... #define MAMXFLL		0x20A 
.................... #define MAMXFLH		0x20B 
.................... //#define r			0x20C 
.................... //#define r			0x20D 
.................... //#define r			0x20E 
.................... //#define			0x20F 
.................... //#define r			0x210 
.................... //#define r			0x211 
.................... #define MICMD		0x212 
.................... //#define r			0x213 
.................... #define MIREGADR	0x214 
.................... //#define r			0x215 
.................... #define MIWRL		0x216 
.................... #define MIWRH		0x217 
.................... #define MIRDL		0x218 
.................... #define MIRDH		0x219 
.................... //#define r			0x21A 
.................... //#define EIE		0x21B 
.................... //#define EIR		0x21C 
.................... //#define ESTAT		0x21D 
.................... //#define ECON2		0x21E 
.................... //#define ECON1		0x21F 
....................  
.................... // Bank 3 registers ----- 
.................... #define MAADR5		0x300 
.................... #define MAADR6		0x301 
.................... #define MAADR3		0x302 
.................... #define MAADR4		0x303 
.................... #define MAADR1		0x304 
.................... #define MAADR2		0x305 
.................... #define EBSTSD		0x306 
.................... #define EBSTCON		0x307 
.................... #define EBSTCSL		0x308 
.................... #define EBSTCSH		0x309 
.................... #define MISTAT		0x30A 
.................... //#define			0x30B 
.................... //#define			0x30C 
.................... //#define			0x30D 
.................... //#define			0x30E 
.................... //#define			0x30F 
.................... //#define			0x310 
.................... //#define			0x311 
.................... #define EREVID		0x312 
.................... //#define			0x313 
.................... //#define			0x314 
.................... #define ECOCON		0x315 
.................... //#define 			0x316 
.................... #define EFLOCON		0x317 
.................... #define EPAUSL		0x318 
.................... #define EPAUSH		0x319 
.................... //#define r			0x31A 
.................... //#define EIE		0x31B 
.................... //#define EIR		0x31C 
.................... //#define ESTAT		0x31D 
.................... //#define ECON2		0x31E 
.................... //#define ECON1		0x31F 
....................  
....................  
....................  
.................... // Structures 
.................... typedef union _REG 
.................... { 
.................... 	char Val; 
....................  
.................... 	// EIE bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIE:1; 
.................... 		unsigned char TXERIE:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIE:1; 
.................... 		unsigned char LINKIE:1; 
.................... 		unsigned char DMAIE:1; 
.................... 		unsigned char PKTIE:1; 
.................... 		unsigned char INTIE:1; 
.................... 	} EIEbits; 
....................  
.................... 	// EIR bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIF:1; 
.................... 		unsigned char TXERIF:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIF:1; 
.................... 		unsigned char LINKIF:1; 
.................... 		unsigned char DMAIF:1; 
.................... 		unsigned char PKTIF:1; 
.................... 		unsigned char blank1:1; 
.................... 	} EIRbits; 
....................  
.................... 	// ESTAT bits --------- 
.................... 	struct { 
.................... 		unsigned char CLKRDY:1; 
.................... 		unsigned char TXABRT:1; 
.................... 		unsigned char RXBUSY:1; 
.................... 		unsigned char blank1:1; 
.................... 		unsigned char LATECOL:1; 
.................... 		unsigned char blank2:2; 
.................... 		unsigned char INTR:1; 
.................... 	} ESTATbits; 
....................  
.................... 	// ECON2 bits -------- 
.................... 	struct { 
.................... 		unsigned char blank3:3; 
.................... 		unsigned char VRPS:1; 
.................... 		unsigned char VRTP:1; 
.................... 		unsigned char PWRSV:1; 
.................... 		unsigned char PKTDEC:1; 
.................... 		unsigned char AUTOINC:1; 
.................... 	} ECON2bits; 
....................  
.................... 	// ECON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char BSEL0:1; 
.................... 		unsigned char BSEL1:1; 
.................... 		unsigned char RXEN:1; 
.................... 		unsigned char TXRTS:1; 
.................... 		unsigned char CSUMEN:1; 
.................... 		unsigned char DMAST:1; 
.................... 		unsigned char RXRST:1; 
.................... 		unsigned char TXRST:1; 
.................... 	} ECON1bits; 
....................  
.................... 	// ERXFCON bits ------ 
.................... 	struct { 
.................... 		unsigned char BCEN:1; 
.................... 		unsigned char MCEN:1; 
.................... 		unsigned char HTEN:1; 
.................... 		unsigned char MPEN:1; 
.................... 		unsigned char PMEN:1; 
.................... 		unsigned char CRCEN:1; 
.................... 		unsigned char ANDOR:1; 
.................... 		unsigned char UCEN:1; 
.................... 	} ERXFCONbits; 
....................  
.................... 	// MACON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char MARXEN:1; 
.................... 		unsigned char PASSALL:1; 
.................... 		unsigned char RXPAUS:1; 
.................... 		unsigned char TXPAUS:1; 
.................... 		unsigned char :4; 
.................... 	} MACON1bits; 
....................  
....................  
.................... 	// MACON3 bits -------- 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG0:1; 
.................... 		unsigned char PADCFG1:1; 
.................... 		unsigned char PADCFG2:1; 
.................... 	} MACON3bits; 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG:3; 
.................... 	} MACON3bits2; 
....................  
.................... 	// MACON4 bits -------- 
.................... 	struct { 
.................... 		unsigned char :4; 
.................... 		unsigned char NOBKOFF:1; 
.................... 		unsigned char BPEN:1; 
.................... 		unsigned char DEFER:1; 
.................... 		unsigned char blank1:1; 
.................... 	} MACON4bits; 
....................  
.................... 	// MICMD bits --------- 
.................... 	struct { 
.................... 		unsigned char MIIRD:1; 
.................... 		unsigned char MIISCAN:1; 
.................... 		unsigned char blank6:6; 
.................... 	} MICMDbits; 
....................  
.................... 	// EBSTCON bits ----- 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL0:1; 
.................... 		unsigned char TMSEL1:1; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV0:1; 
.................... 		unsigned char PSV1:1; 
.................... 		unsigned char PSV2:1; 
.................... 	} EBSTCONbits; 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL:2; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV:3; 
.................... 	} EBSTCONbits2; 
....................  
.................... 	// MISTAT bits -------- 
.................... 	struct { 
.................... 		unsigned char BUSY:1; 
.................... 		unsigned char SCAN:1; 
.................... 		unsigned char NVALID:1; 
.................... 		unsigned char blank5:5; 
.................... 	} MISTATbits; 
....................  
.................... 	// ECOCON bits ------- 
.................... 	struct { 
.................... 		unsigned char COCON0:1; 
.................... 		unsigned char COCON1:1; 
.................... 		unsigned char COCON2:1; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits; 
.................... 	struct { 
.................... 		unsigned char COCON:3; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits2; 
....................  
.................... 	// EFLOCON bits ----- 
.................... 	struct { 
.................... 		unsigned char FCEN0:1; 
.................... 		unsigned char FCEN1:1; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits; 
.................... 	struct { 
.................... 		unsigned char FCEN:2; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits2; 
.................... } REG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * PH Register Locations 
.................... ******************************************************************************/ 
.................... #define PHCON1	0x00 
.................... #define PHSTAT1	0x01 
.................... #define PHID1	0x02 
.................... #define PHID2	0x03 
.................... #define PHCON2	0x10 
.................... #define PHSTAT2	0x11 
.................... #define PHIE	0x12 
.................... #define PHIR	0x13 
.................... #define PHLCON	0x14 
....................  
....................  
.................... typedef union { 
.................... 	int16 Val; 
.................... 	WORD_VAL VAL; 
....................  
.................... 	// PHCON1 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 PDPXMD:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PPWRSV:1; 
.................... 		int8 blank22:2; 
.................... 		int8 PLOOPBK:1; 
.................... 		int8 PRST:1; 
.................... 	} PHCON1bits; 
....................  
.................... 	// PHSTAT1 bits -------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 JBSTAT:1; 
.................... 		int8 LLSTAT:1; 
.................... 		int8 blank5:5; 
.................... 		int8 blank3:3; 
.................... 		int8 PHDPX:1; 
.................... 		int8 PFDPX:1; 
.................... 		int8 blank33:3; 
.................... 	} PHSTAT1bits; 
....................  
.................... 	// PHID2 bits ---------- 
.................... 	struct { 
.................... 		int8 PREV0:1; 
.................... 		int8 PREV1:1; 
.................... 		int8 PREV2:1; 
.................... 		int8 PREV3:1; 
.................... 		int8 PPN0:1; 
.................... 		int8 PPN1:1; 
.................... 		int8 PPN2:1; 
.................... 		int8 PPN3:1; 
.................... 		int8 PPN4:1; 
.................... 		int8 PPN5:1; 
.................... 		int8 PID19:1; 
.................... 		int8 PID20:1; 
.................... 		int8 PID21:1; 
.................... 		int8 PID22:1; 
.................... 		int8 PID23:1; 
.................... 		int8 PID24:1; 
.................... 	} PHID2bits; 
.................... 	struct { 
.................... 		int8 PREV:4; 
.................... 		int8 PPNL:4; 
.................... 		int8 PPNH:2; 
.................... 		int8 PID:6; 
.................... 	} PHID2bits2; 
....................  
.................... 	// PHCON2 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 HDLDIS:1; 
.................... 		int8 blank1:1; 
.................... 		int8 JABBER:1; 
.................... 		int8 blank2:2; 
.................... 		int8 TXDIS:1; 
.................... 		int8 FRCLNK:1; 
.................... 		int8 blank11:1; 
.................... 	} PHCON2bits; 
....................  
.................... 	// PHSTAT2 bits -------- 
.................... 	struct { 
.................... 		int8 blank5:5; 
.................... 		int8 PLRITY:1; 
.................... 		int8 blank2:2; 
.................... 		int8 blank11:1; 
.................... 		int8 DPXSTAT:1; 
.................... 		int8 LSTAT:1; 
.................... 		int8 COLSTAT:1; 
.................... 		int8 RXSTAT:1; 
.................... 		int8 TXSTAT:1; 
.................... 		int8 blank22:2; 
.................... 	} PHSTAT2bits; 
....................  
.................... 	// PHIE bits ----------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 PGEIE:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PLNKIE:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIEbits; 
....................  
.................... 	// PHIR bits ----------- 
.................... 	struct { 
.................... 		int8 blank2:2; 
.................... 		int8 PGIF:1; 
.................... 		int8 blank1:1; 
.................... 		int8 PLNKIF:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIRbits; 
....................  
.................... 	// PHLCON bits ------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ0:1; 
.................... 		int8 LFRQ1:1; 
.................... 		int8 LBCFG0:1; 
.................... 		int8 LBCFG1:1; 
.................... 		int8 LBCFG2:1; 
.................... 		int8 LBCFG3:1; 
.................... 		int8 LACFG0:1; 
.................... 		int8 LACFG1:1; 
.................... 		int8 LACFG2:1; 
.................... 		int8 LACFG3:1; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits; 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ:2; 
.................... 		int8 LBCFG:4; 
.................... 		int8 LACFG:4; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits2; 
.................... } PHYREG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * Individual Register Bits 
.................... ******************************************************************************/ 
.................... // ETH/MAC/MII bits 
....................  
.................... // EIE bits ---------- 
.................... #define	EIE_INTIE		(1<<7) 
.................... #define	EIE_PKTIE		(1<<6) 
.................... #define	EIE_DMAIE		(1<<5) 
.................... #define	EIE_LINKIE		(1<<4) 
.................... #define	EIE_TXIE		(1<<3) 
.................... #define	EIE_TXERIE		(1<<1) 
.................... #define	EIE_RXERIE		(1) 
....................  
.................... // EIR bits ---------- 
.................... #define	EIR_PKTIF		(1<<6) 
.................... #define	EIR_DMAIF		(1<<5) 
.................... #define	EIR_LINKIF		(1<<4) 
.................... #define	EIR_TXIF		(1<<3) 
.................... #define	EIR_TXERIF		(1<<1) 
.................... #define	EIR_RXERIF		(1) 
....................  
.................... // ESTAT bits --------- 
.................... #define	ESTAT_INT		(1<<7) 
.................... #define ESTAT_BUFFER	(1<<6) 
.................... #define	ESTAT_LATECOL	(1<<4) 
.................... #define	ESTAT_RXBUSY	(1<<2) 
.................... #define	ESTAT_TXABRT	(1<<1) 
.................... #define	ESTAT_CLKRDY	(1) 
....................  
.................... // ECON2 bits -------- 
.................... #define	ECON2_AUTOINC	(1<<7) 
.................... #define	ECON2_PKTDEC	(1<<6) 
.................... #define	ECON2_PWRSV		(1<<5) 
.................... #define	ECON2_VRPS		(1<<3) 
....................  
.................... // ECON1 bits -------- 
.................... #define	ECON1_TXRST		(1<<7) 
.................... #define	ECON1_RXRST		(1<<6) 
.................... #define	ECON1_DMAST		(1<<5) 
.................... #define	ECON1_CSUMEN	(1<<4) 
.................... #define	ECON1_TXRTS		(1<<3) 
.................... #define	ECON1_RXEN		(1<<2) 
.................... #define	ECON1_BSEL1		(1<<1) 
.................... #define	ECON1_BSEL0		(1) 
....................  
.................... // ERXFCON bits ------ 
.................... #define	ERXFCON_UCEN	(1<<7) 
.................... #define	ERXFCON_ANDOR	(1<<6) 
.................... #define	ERXFCON_CRCEN	(1<<5) 
.................... #define	ERXFCON_PMEN	(1<<4) 
.................... #define	ERXFCON_MPEN	(1<<3) 
.................... #define	ERXFCON_HTEN	(1<<2) 
.................... #define	ERXFCON_MCEN	(1<<1) 
.................... #define	ERXFCON_BCEN	(1) 
....................  
.................... // MACON1 bits -------- 
.................... #define	MACON1_TXPAUS	(1<<3) 
.................... #define	MACON1_RXPAUS	(1<<2) 
.................... #define	MACON1_PASSALL	(1<<1) 
.................... #define	MACON1_MARXEN	(1) 
....................  
.................... // MACON3 bits -------- 
.................... #define	MACON3_PADCFG2	(1<<7) 
.................... #define	MACON3_PADCFG1	(1<<6) 
.................... #define	MACON3_PADCFG0	(1<<5) 
.................... #define	MACON3_TXCRCEN	(1<<4) 
.................... #define	MACON3_PHDRLEN	(1<<3) 
.................... #define	MACON3_HFRMEN	(1<<2) 
.................... #define	MACON3_FRMLNEN	(1<<1) 
.................... #define	MACON3_FULDPX	(1) 
....................  
.................... // MACON4 bits -------- 
.................... #define	MACON4_DEFER	(1<<6) 
.................... #define	MACON4_BPEN		(1<<5) 
.................... #define	MACON4_NOBKOFF	(1<<4) 
....................  
....................  
.................... // MICMD bits --------- 
.................... #define	MICMD_MIISCAN	(1<<1) 
.................... #define	MICMD_MIIRD		(1) 
....................  
.................... // EBSTCON bits ----- 
.................... #define	EBSTCON_PSV2	(1<<7) 
.................... #define	EBSTCON_PSV1	(1<<6) 
.................... #define	EBSTCON_PSV0	(1<<5) 
.................... #define	EBSTCON_PSEL	(1<<4) 
.................... #define	EBSTCON_TMSEL1	(1<<3) 
.................... #define	EBSTCON_TMSEL0	(1<<2) 
.................... #define	EBSTCON_TME		(1<<1) 
.................... #define	EBSTCON_BISTST	(1) 
....................  
.................... // MISTAT bits -------- 
.................... #define	MISTAT_NVALID	(1<<2) 
.................... #define	MISTAT_SCAN		(1<<1) 
.................... #define	MISTAT_BUSY		(1) 
....................  
.................... // ECOCON bits ------- 
.................... #define	ECOCON_COCON2	(1<<2) 
.................... #define	ECOCON_COCON1	(1<<1) 
.................... #define	ECOCON_COCON0	(1) 
....................  
.................... // EFLOCON bits ----- 
.................... #define	EFLOCON_FULDPXS	(1<<2) 
.................... #define	EFLOCON_FCEN1	(1<<1) 
.................... #define	EFLOCON_FCEN0	(1) 
....................  
....................  
....................  
.................... // PHY bits 
....................  
.................... // PHCON1 bits ---------- 
.................... #define	PHCON1_PRST		(1ul<<15) 
.................... #define	PHCON1_PLOOPBK	(1ul<<14) 
.................... #define	PHCON1_PPWRSV	(1ul<<11) 
.................... #define	PHCON1_PDPXMD	(1ul<<8) 
....................  
.................... // PHSTAT1 bits -------- 
.................... #define	PHSTAT1_PFDPX	(1ul<<12) 
.................... #define	PHSTAT1_PHDPX	(1ul<<11) 
.................... #define	PHSTAT1_LLSTAT	(1ul<<2) 
.................... #define	PHSTAT1_JBSTAT	(1ul<<1) 
....................  
.................... // PHID2 bits -------- 
.................... #define	PHID2_PID24		(1ul<<15) 
.................... #define	PHID2_PID23		(1ul<<14) 
.................... #define	PHID2_PID22		(1ul<<13) 
.................... #define	PHID2_PID21		(1ul<<12) 
.................... #define	PHID2_PID20		(1ul<<11) 
.................... #define	PHID2_PID19		(1ul<<10) 
.................... #define	PHID2_PPN5		(1ul<<9) 
.................... #define	PHID2_PPN4		(1ul<<8) 
.................... #define	PHID2_PPN3		(1ul<<7) 
.................... #define	PHID2_PPN2		(1ul<<6) 
.................... #define	PHID2_PPN1		(1ul<<5) 
.................... #define	PHID2_PPN0		(1ul<<4) 
.................... #define	PHID2_PREV3		(1ul<<3) 
.................... #define	PHID2_PREV2		(1ul<<2) 
.................... #define	PHID2_PREV1		(1ul<<1) 
.................... #define	PHID2_PREV0		(1ul) 
....................  
.................... // PHCON2 bits ---------- 
.................... #define	PHCON2_FRCLNK	(1ul<<14) 
.................... #define	PHCON2_TXDIS	(1ul<<13) 
.................... #define	PHCON2_JABBER	(1ul<<10) 
.................... #define	PHCON2_HDLDIS	(1ul<<8) 
....................  
.................... // PHSTAT2 bits -------- 
.................... #define	PHSTAT2_TXSTAT	(1ul<<13) 
.................... #define	PHSTAT2_RXSTAT	(1ul<<12) 
.................... #define	PHSTAT2_COLSTAT	(1ul<<11) 
.................... #define	PHSTAT2_LSTAT	(1ul<<10) 
.................... #define	PHSTAT2_DPXSTAT	(1ul<<9) 
.................... #define	PHSTAT2_PLRITY	(1ul<<5) 
....................  
.................... // PHIE bits ----------- 
.................... #define	PHIE_PLNKIE		(1ul<<4) 
.................... #define	PHIE_PGEIE		(1ul<<1) 
....................  
.................... // PHIR bits ----------- 
.................... #define	PHIR_PLNKIF		(1ul<<4) 
.................... #define	PHIR_PGIF		(1ul<<2) 
....................  
.................... // PHLCON bits ------- 
.................... #define	PHLCON_LACFG3	(1ul<<11) 
.................... #define	PHLCON_LACFG2	(1ul<<10) 
.................... #define	PHLCON_LACFG1	(1ul<<9) 
.................... #define	PHLCON_LACFG0	(1ul<<8) 
.................... #define	PHLCON_LBCFG3	(1ul<<7) 
.................... #define	PHLCON_LBCFG2	(1ul<<6) 
.................... #define	PHLCON_LBCFG1	(1ul<<5) 
.................... #define	PHLCON_LBCFG0	(1ul<<4) 
.................... #define	PHLCON_LFRQ1	(1ul<<3) 
.................... #define	PHLCON_LFRQ0	(1ul<<2) 
.................... #define	PHLCON_STRCH	(1ul<<1) 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        BYTE hexatob(WORD_VAL AsciiChars) 
.................... * 
.................... * PreCondition:    None 
.................... * 
.................... * Input:           Two ascii bytes; each ranged '0'-'9', 'A'-'F', or 
.................... *						'a'-'f' 
.................... * 
.................... * Output:          The resulting packed byte: 0x00-0xFF 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:			None 
.................... ********************************************************************/ 
.................... BYTE hexatob(WORD_VAL AsciiChars) 
.................... { 
.................... 	// Convert lowercase to uppercase 
.................... 	if(AsciiChars.v[1] > 'F') 
.................... 		AsciiChars.v[1] -= 'a'-'A'; 
.................... 	if(AsciiChars.v[0] > 'F') 
.................... 		AsciiChars.v[0] -= 'a'-'A'; 
....................  
.................... 	// Convert 0-9, A-F to 0x0-0xF 
.................... 	if(AsciiChars.v[1] > '9') 
.................... 		AsciiChars.v[1] -= 'A' - 10; 
.................... 	else 
.................... 		AsciiChars.v[1] -= '0'; 
....................  
.................... 	if(AsciiChars.v[0] > '9') 
.................... 		AsciiChars.v[0] -= 'A' - 10; 
.................... 	else 
.................... 		AsciiChars.v[0] -= '0'; 
....................  
.................... 	// Concatenate 
.................... 	return (AsciiChars.v[1]<<4) |  AsciiChars.v[0]; 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        BYTE btohexa_high(BYTE b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           One byte ranged 0x00-0xFF 
....................  * 
....................  * Output:          An ascii byte (always uppercase) between '0'-'9' 
....................  *					or 'A'-'F' that corresponds to the upper 4 bits of 
....................  *					the input byte. 
....................  *					ex: b = 0xAE, btohexa_high() returns 'A' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:			None 
....................  ********************************************************************/ 
.................... BYTE btohexa_high(BYTE b) 
.................... { 
.................... 	b >>= 4; 
.................... 	return (b>0x9) ? b+'A'-10:b+'0'; 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        BYTE btohexa_low(BYTE b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           One byte ranged 0x00-0xFF 
....................  * 
....................  * Output:          An ascii byte (always uppercase) between '0'-'9' 
....................  *					or 'A'-'F' that corresponds to the lower 4 bits of 
....................  *					the input byte. 
....................  *					ex: b = 0xAE, btohexa_low() returns 'E' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:			None 
....................  ********************************************************************/ 
.................... BYTE btohexa_low(BYTE b) 
.................... { 
.................... 	b &= 0x0F; 
.................... 	return (b>9) ? b+'A'-10:b+'0'; 
.................... } 
....................  
.................... WORD swaps(WORD_VAL v) 
.................... { 
....................     WORD_VAL new; 
....................  
....................     new.v[0]=v.v[1]; 
*
1146:  MOVFF  3B1,3B2
....................     new.v[1]=v.v[0]; 
114A:  MOVFF  3B0,3B3
....................  
....................     return(new.Val); 
114E:  MOVLB  3
1150:  MOVFF  3B2,01
1154:  MOVFF  3B3,02
.................... } 
1158:  MOVLB  0
115A:  RETLW  00
....................  
.................... DWORD swapl(DWORD_VAL v) 
.................... { 
....................     DWORD_VAL new; 
....................  
....................     new.v[0]=v.v[3]; 
*
206E:  MOVFF  39C,39D
....................     new.v[1]=v.v[2]; 
2072:  MOVFF  39B,39E
....................     new.v[2]=v.v[1]; 
2076:  MOVFF  39A,39F
....................     new.v[3]=v.v[0]; 
207A:  MOVFF  399,3A0
....................  
....................     return(new.Val); 
207E:  MOVFF  39D,00
2082:  MOVFF  39E,01
2086:  MOVFF  39F,02
208A:  MOVFF  3A0,03
.................... } 
208E:  RETLW  00
....................  
.................... WORD CalcIPChecksum(BYTE* buffer, WORD count) 
.................... { 
.................... 	WORD i; 
.................... 	WORD *val; 
....................  
.................... 	union 
.................... 	{ 
.................... 		DWORD Val; 
.................... 		struct 
.................... 		{ 
.................... 			WORD_VAL LSB; 
.................... 			WORD_VAL MSB; 
.................... 		} words; 
.................... 	} tempSum, sum; 
....................  
.................... 	sum.Val = 0; 
*
1DE2:  MOVLB  3
1DE4:  CLRF   xA2
1DE6:  CLRF   xA1
1DE8:  CLRF   xA0
1DEA:  CLRF   x9F
....................  
.................... 	i = count >> 1; 
1DEC:  BCF    FD8.0
1DEE:  RRCF   x96,W
1DF0:  MOVWF  x98
1DF2:  RRCF   x95,W
1DF4:  MOVWF  x97
.................... 	val = (WORD *)buffer; 
1DF6:  MOVFF  394,39A
1DFA:  MOVFF  393,399
....................  
.................... 	while( i-- ) 
.................... 		sum.Val += *val++; 
1DFE:  MOVFF  398,03
1E02:  MOVF   x97,W
1E04:  BTFSC  FD8.2
1E06:  DECF   x98,F
1E08:  DECF   x97,F
1E0A:  IORWF  03,W
1E0C:  BZ    1E3C
1E0E:  MOVFF  39A,03
1E12:  MOVFF  399,00
1E16:  MOVLW  02
1E18:  ADDWF  x99,F
1E1A:  BTFSC  FD8.0
1E1C:  INCF   x9A,F
1E1E:  MOVFF  00,FE9
1E22:  MOVFF  03,FEA
1E26:  MOVFF  FEC,03
1E2A:  MOVF   FED,F
1E2C:  MOVF   FEF,W
1E2E:  ADDWF  x9F,F
1E30:  MOVF   03,W
1E32:  ADDWFC xA0,F
1E34:  MOVLW  00
1E36:  ADDWFC xA1,F
1E38:  ADDWFC xA2,F
1E3A:  BRA    1DFE
....................  
.................... 	if ( count & 1 ) 
1E3C:  MOVF   x95,W
1E3E:  ANDLW  01
1E40:  MOVWF  00
1E42:  CLRF   03
1E44:  MOVF   00,W
1E46:  IORWF  03,W
1E48:  BZ    1E5E
.................... 		sum.Val += *(BYTE *)val; 
1E4A:  MOVFF  399,FE9
1E4E:  MOVFF  39A,FEA
1E52:  MOVF   FEF,W
1E54:  ADDWF  x9F,F
1E56:  MOVLW  00
1E58:  ADDWFC xA0,F
1E5A:  ADDWFC xA1,F
1E5C:  ADDWFC xA2,F
....................  
.................... 	tempSum.Val = sum.Val; 
1E5E:  MOVFF  3A2,39E
1E62:  MOVFF  3A1,39D
1E66:  MOVFF  3A0,39C
1E6A:  MOVFF  39F,39B
....................  
.................... 	while( (i = tempSum.words.MSB.Val) != 0u ) 
.................... 	{ 
1E6E:  MOVFF  39E,398
1E72:  MOVFF  39D,397
1E76:  MOVF   x97,F
1E78:  BNZ   1E7E
1E7A:  MOVF   x98,F
1E7C:  BZ    1EBC
.................... 		sum.words.MSB.Val = 0; 
1E7E:  CLRF   xA2
1E80:  CLRF   xA1
.................... 		sum.Val = (DWORD)sum.words.LSB.Val + (DWORD)i; 
1E82:  CLRF   xA6
1E84:  CLRF   xA5
1E86:  MOVFF  3A0,3A4
1E8A:  MOVFF  39F,3A3
1E8E:  CLRF   02
1E90:  CLRF   03
1E92:  MOVF   x97,W
1E94:  ADDWF  x9F,W
1E96:  MOVWF  x9F
1E98:  MOVF   x98,W
1E9A:  ADDWFC xA0,W
1E9C:  MOVWF  xA0
1E9E:  MOVF   02,W
1EA0:  ADDWFC xA5,W
1EA2:  MOVWF  xA1
1EA4:  MOVF   03,W
1EA6:  ADDWFC xA6,W
1EA8:  MOVWF  xA2
.................... 		tempSum.Val = sum.Val; 
1EAA:  MOVFF  3A2,39E
1EAE:  MOVFF  3A1,39D
1EB2:  MOVFF  3A0,39C
1EB6:  MOVFF  39F,39B
.................... 	} 
1EBA:  BRA    1E6E
....................  
.................... 	return (~sum.words.LSB.Val); 
1EBC:  MOVFF  3A0,03
1EC0:  COMF   03,F
1EC2:  MOVF   x9F,W
1EC4:  XORLW  FF
1EC6:  MOVWF  01
1EC8:  MOVFF  03,02
.................... } 
1ECC:  MOVLB  0
1ECE:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        WORD CalcIPBufferChecksum(WORD len) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  MAC buffer pointer set to starting of buffer 
....................  * 
....................  * Input:           len     - Total number of bytes to calculate 
....................  *                          checksum for. 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs checksum calculation in 
....................  *                  MAC buffer itself. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #if !defined(MCHP_MAC) 
.................... WORD CalcIPBufferChecksum(WORD len) 
.................... { 
....................     BOOL lbMSB; 
....................     WORD_VAL checkSum; 
....................     BYTE Checkbyte; 
....................  
....................     lbMSB = TRUE; 
....................     checkSum.Val = 0; 
....................  
....................     while( len-- ) 
....................     { 
....................         Checkbyte = MACGet(); 
....................  
....................         if ( !lbMSB ) 
....................         { 
....................             if ( (checkSum.v[0] = Checkbyte+checkSum.v[0]) < Checkbyte) 
....................             { 
....................                 if ( ++checkSum.v[1] == 0 ) 
....................                     checkSum.v[0]++; 
....................             } 
....................         } 
....................         else 
....................         { 
....................             if ( (checkSum.v[1] = Checkbyte+checkSum.v[1]) < Checkbyte) 
....................             { 
....................                 if ( ++checkSum.v[0] == 0 ) 
....................                     checkSum.v[1]++; 
....................             } 
....................         } 
....................  
....................         lbMSB = !lbMSB; 
....................     } 
....................  
....................     checkSum.v[1] = ~checkSum.v[1]; 
....................     checkSum.v[0] = ~checkSum.v[0]; 
....................     return checkSum.Val; 
.................... } 
.................... #endif 
....................  
....................  
.................... char *strupr (char *s) 
.................... { 
....................     char c; 
....................     char *t; 
....................  
....................     t = s; 
....................     while( (c = *t) ) 
....................     { 
....................         if ( (c >= 'a' && c <= 'z') ) 
....................             *t -= ('a' - 'A'); 
....................     t++; 
....................     } 
....................     return s; 
.................... } 
....................  
.................... void delay_s(int8 s) { 
....................    while(s) { 
....................       restart_wdt(); 
....................       delay_ms(1000); 
....................       s--; 
....................    } 
.................... } 
....................  
.................... #include "tcpip/tick.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.c 
....................  * Dependencies:    stackTSK.h 
....................  *                  Tick.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    01/16/04 Intermediate counter vars added 
....................  * R. Shelquist (CCS)   09/23/04 TickGet() temporarily disables Timer0 interrupt 
....................  ********************************************************************/ 
....................  
.................... #define TICK_INCLUDE 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               10 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... TICKTYPE TickCount = 0;  //increment every 100ms 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void) 
.................... { 
....................     setup_timer_0(RTCC_INTERNAL | RTCC_DIV_16); 
*
0766:  MOVLW  83
0768:  MOVWF  FD5
....................     set_timer0(TICK_COUNTER); 
076A:  MOVLW  85
076C:  MOVWF  FD7
076E:  MOVLW  ED
0770:  MOVWF  FD6
....................  
....................     enable_interrupts(INT_TIMER0); 
0772:  BSF    FF2.5
....................     enable_interrupts(GLOBAL); 
0774:  MOVLW  C0
0776:  IORWF  FF2,F
.................... } 
0778:  GOTO   106A (RETURN)
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void) 
.................... { 
....................     int16 ret; 
....................     disable_interrupts(INT_TIMER0); 
*
2494:  BCF    FF2.5
....................     ret=TickCount; 
2496:  MOVFF  51,355
249A:  MOVFF  50,354
....................     enable_interrupts(INT_TIMER0); 
249E:  BSF    FF2.5
....................     return ret; 
24A0:  MOVLB  3
24A2:  MOVFF  354,01
24A6:  MOVFF  355,02
.................... } 
24AA:  MOVLB  0
24AC:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... int8 second_counter=0;  //increment this every 1s 
.................... int8 second_counter_intermediate=0; 
....................  
.................... #if STACK_USE_PPP 
....................  int8 ppp_second_counter=0; 
....................  int8 ppp_second_counter_intermediate=0; 
.................... #endif 
....................  
.................... #int_timer0 
.................... void Tick_Isr(void) 
.................... { 
....................         TickCount++;    //increment this every 100ms 
*
01F8:  INCF   50,F
01FA:  BTFSC  FD8.2
01FC:  INCF   51,F
....................  
....................         second_counter_intermediate++; 
01FE:  INCF   53,F
....................         if (second_counter_intermediate >= TICKS_PER_SECOND) { 
0200:  MOVF   53,W
0202:  SUBLW  09
0204:  BC    020A
....................             second_counter++; //increment this ever 1s 
0206:  INCF   52,F
....................             second_counter_intermediate=0; 
0208:  CLRF   53
....................         } 
....................  
....................  
....................        #if STACK_USE_PPP 
....................         ppp_second_counter_intermediate++; 
....................         if (ppp_second_counter_intermediate >= TICKS_PER_SECOND) { 
....................             ppp_second_counter_intermediate=0; 
....................             ppp_second_counter++; 
....................         } 
....................        #endif 
....................  
....................  
....................     set_timer0(TICK_COUNTER); //set timer0 to properly interrupt every 100ms 
020A:  MOVLW  85
020C:  MOVWF  FD7
020E:  MOVLW  ED
0210:  MOVWF  FD6
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... //#define debug_stack  debug_printf 
.................... #define debug_stack 
....................  
.................... #if STACK_USE_MAC 
....................    #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................    #if STACK_USE_MCPENC 
....................     #include "tcpip/enc28j60.c" 
.................... /********************************************************************* 
....................  * 
....................  *     MAC Module (Microchip ENC28J60) for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.c 
....................  * Dependencies:    ENC28J60.h 
....................  *                    MAC.h 
....................  *                    string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                    Delay.h 
....................  * Processor:       PIC18 
....................  * Complier:        MCC18 v3.00 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date         Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder      6/28/04   Original 
....................  * Howard Schlunder      10/8/04   Cleanup 
....................  * Howard Schlunder      10/19/04 Small optimizations and more cleanup 
....................  * Howard Schlunder      11/29/04 Added Set/GetCLKOUT 
....................  * Howard Schlunder      12/23/05 Added B1 silicon errata workarounds 
....................  * Howard Schlunder      1/09/06   Added comments and minor mods 
....................  * Howard Schlunder      1/18/06 Added more silicon errata workarounds 
....................  * Howard Schlunder      2/20/06 Fixed TXSTART, RXSTOP 
....................  * Darren Rook          7/11/06  CCS Port 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
.................... ********************************************************************/ 
.................... #define THIS_IS_MAC_LAYER 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8 *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8 *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/StackTsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/Helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/MAC.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ENC28J60.h" 
.................... /********************************************************************* 
....................  * 
....................  *            ENC28J60 registers/bits 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.h 
....................  * Description: 	Include file for ENC28J60 control registers 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		06/01/04	Original 
....................  * Howard Schlunder		06/29/04	Fixed byte boundary problems on a  
....................  *									couple of PHY register structs. 
....................  * Howard Schlunder		09/29/04	Matched with data sheet 
....................  * Howard Schlunder		01/04/06	Matched with new data sheet 
....................  * Howard Schlunder		06/29/06	Changed MACON3.PHDRLEN to PHDREN 
....................  * Howard Schlunder		07/21/06	Several bits removed to match now  
....................  *									reserved bits in rev. B data sheet  
....................  *									(DS39662B) 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef ENC28J60_H 
.................... #define ENC28J60_H 
....................  
.................... typedef union { 
.................... 	BYTE v[7]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 CollisionCount:4; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 Done:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 PacketDefer:1; 
.................... 		int8 ExcessiveDefer:1; 
.................... 		int8 MaximumCollisions:1; 
.................... 		int8 LateCollision:1; 
.................... 		int8 Giant:1; 
.................... 		int8 Underrun:1; 
.................... 		int16 	 BytesTransmittedOnWire; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PAUSEControlFrame:1; 
.................... 		int8 BackpressureApplied:1; 
.................... 		int8 VLANTaggedFrame:1; 
.................... 		int8 Zeros:4; 
.................... 	} bits; 
.................... } TXSTATUS; 
....................  
.................... typedef union { 
.................... 	char v[4]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 PreviouslyIgnored:1; 
.................... 		int8 RXDCPreviouslySeen:1; 
.................... 		int8 CarrierPreviouslySeen:1; 
.................... 		int8 CodeViolation:1; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 ReceiveOk:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 DribbleNibble:1; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PauseControlFrame:1; 
.................... 		int8 UnsupportedOpcode:1; 
.................... 		int8 VLANType:1; 
.................... 		int8 Zero:1; 
.................... 	} bits; 
.................... } RXSTATUS; 
....................  
.................... /****************************************************************************** 
.................... * Register locations 
.................... ******************************************************************************/ 
.................... // Bank 0 registers -------- 
.................... #define ERDPTL		0x00 
.................... #define ERDPTH		0x01 
.................... #define EWRPTL		0x02 
.................... #define EWRPTH		0x03 
.................... #define ETXSTL		0x04 
.................... #define ETXSTH		0x05 
.................... #define ETXNDL		0x06 
.................... #define ETXNDH		0x07 
.................... #define ERXSTL		0x08 
.................... #define ERXSTH		0x09 
.................... #define ERXNDL		0x0A 
.................... #define ERXNDH		0x0B 
.................... #define ERXRDPTL	0x0C 
.................... #define ERXRDPTH	0x0D 
.................... #define ERXWRPTL	0x0E 
.................... #define ERXWRPTH	0x0F 
.................... #define EDMASTL		0x10 
.................... #define EDMASTH		0x11 
.................... #define EDMANDL		0x12 
.................... #define EDMANDH		0x13 
.................... #define EDMADSTL	0x14 
.................... #define EDMADSTH	0x15 
.................... #define EDMACSL		0x16 
.................... #define EDMACSH		0x17 
.................... //#define			0x18 
.................... //#define			0x19 
.................... //#define r			0x1A 
.................... #define EIE			0x1B 
.................... #define EIR			0x1C 
.................... #define ESTAT		0x1D 
.................... #define ECON2		0x1E 
.................... #define ECON1		0x1F 
....................  
.................... // Bank 1 registers ----- 
.................... #define EHT0		0x100 
.................... #define EHT1		0x101 
.................... #define EHT2		0x102 
.................... #define EHT3		0x103 
.................... #define EHT4		0x104 
.................... #define EHT5		0x105 
.................... #define EHT6		0x106 
.................... #define EHT7		0x107 
.................... #define EPMM0		0x108 
.................... #define EPMM1		0x109 
.................... #define EPMM2		0x10A 
.................... #define EPMM3		0x10B 
.................... #define EPMM4		0x10C 
.................... #define EPMM5		0x10D 
.................... #define EPMM6		0x10E 
.................... #define EPMM7		0x10F 
.................... #define EPMCSL		0x110 
.................... #define EPMCSH		0x111 
.................... //#define			0x112 
.................... //#define			0x113 
.................... #define EPMOL		0x114 
.................... #define EPMOH		0x115 
.................... //#define r			0x116 
.................... //#define r			0x117 
.................... #define ERXFCON		0x118 
.................... #define EPKTCNT		0x119 
.................... //#define r			0x11A 
.................... //#define EIE		0x11B 
.................... //#define EIR		0x11C 
.................... //#define ESTAT		0x11D 
.................... //#define ECON2		0x11E 
.................... //#define ECON1		0x11F 
....................  
.................... // Bank 2 registers ----- 
.................... #define MACON1		0x200 
.................... #define MACON2    0x201 
.................... //#define r			0x201 
.................... #define MACON3		0x202 
.................... #define MACON4		0x203 
.................... #define MABBIPG		0x204 
.................... //#define			0x205 
.................... #define MAIPGL		0x206 
.................... #define MAIPGH		0x207 
.................... #define MACLCON1	0x208 
.................... #define MACLCON2	0x209 
.................... #define MAMXFLL		0x20A 
.................... #define MAMXFLH		0x20B 
.................... //#define r			0x20C 
.................... //#define r			0x20D 
.................... //#define r			0x20E 
.................... //#define			0x20F 
.................... //#define r			0x210 
.................... //#define r			0x211 
.................... #define MICMD		0x212 
.................... //#define r			0x213 
.................... #define MIREGADR	0x214 
.................... //#define r			0x215 
.................... #define MIWRL		0x216 
.................... #define MIWRH		0x217 
.................... #define MIRDL		0x218 
.................... #define MIRDH		0x219 
.................... //#define r			0x21A 
.................... //#define EIE		0x21B 
.................... //#define EIR		0x21C 
.................... //#define ESTAT		0x21D 
.................... //#define ECON2		0x21E 
.................... //#define ECON1		0x21F 
....................  
.................... // Bank 3 registers ----- 
.................... #define MAADR5		0x300 
.................... #define MAADR6		0x301 
.................... #define MAADR3		0x302 
.................... #define MAADR4		0x303 
.................... #define MAADR1		0x304 
.................... #define MAADR2		0x305 
.................... #define EBSTSD		0x306 
.................... #define EBSTCON		0x307 
.................... #define EBSTCSL		0x308 
.................... #define EBSTCSH		0x309 
.................... #define MISTAT		0x30A 
.................... //#define			0x30B 
.................... //#define			0x30C 
.................... //#define			0x30D 
.................... //#define			0x30E 
.................... //#define			0x30F 
.................... //#define			0x310 
.................... //#define			0x311 
.................... #define EREVID		0x312 
.................... //#define			0x313 
.................... //#define			0x314 
.................... #define ECOCON		0x315 
.................... //#define 			0x316 
.................... #define EFLOCON		0x317 
.................... #define EPAUSL		0x318 
.................... #define EPAUSH		0x319 
.................... //#define r			0x31A 
.................... //#define EIE		0x31B 
.................... //#define EIR		0x31C 
.................... //#define ESTAT		0x31D 
.................... //#define ECON2		0x31E 
.................... //#define ECON1		0x31F 
....................  
....................  
....................  
.................... // Structures 
.................... typedef union _REG 
.................... { 
.................... 	char Val; 
....................  
.................... 	// EIE bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIE:1; 
.................... 		unsigned char TXERIE:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIE:1; 
.................... 		unsigned char LINKIE:1; 
.................... 		unsigned char DMAIE:1; 
.................... 		unsigned char PKTIE:1; 
.................... 		unsigned char INTIE:1; 
.................... 	} EIEbits; 
....................  
.................... 	// EIR bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIF:1; 
.................... 		unsigned char TXERIF:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIF:1; 
.................... 		unsigned char LINKIF:1; 
.................... 		unsigned char DMAIF:1; 
.................... 		unsigned char PKTIF:1; 
.................... 		unsigned char blank1:1; 
.................... 	} EIRbits; 
....................  
.................... 	// ESTAT bits --------- 
.................... 	struct { 
.................... 		unsigned char CLKRDY:1; 
.................... 		unsigned char TXABRT:1; 
.................... 		unsigned char RXBUSY:1; 
.................... 		unsigned char blank1:1; 
.................... 		unsigned char LATECOL:1; 
.................... 		unsigned char blank2:2; 
.................... 		unsigned char INTR:1; 
.................... 	} ESTATbits; 
....................  
.................... 	// ECON2 bits -------- 
.................... 	struct { 
.................... 		unsigned char blank3:3; 
.................... 		unsigned char VRPS:1; 
.................... 		unsigned char VRTP:1; 
.................... 		unsigned char PWRSV:1; 
.................... 		unsigned char PKTDEC:1; 
.................... 		unsigned char AUTOINC:1; 
.................... 	} ECON2bits; 
....................  
.................... 	// ECON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char BSEL0:1; 
.................... 		unsigned char BSEL1:1; 
.................... 		unsigned char RXEN:1; 
.................... 		unsigned char TXRTS:1; 
.................... 		unsigned char CSUMEN:1; 
.................... 		unsigned char DMAST:1; 
.................... 		unsigned char RXRST:1; 
.................... 		unsigned char TXRST:1; 
.................... 	} ECON1bits; 
....................  
.................... 	// ERXFCON bits ------ 
.................... 	struct { 
.................... 		unsigned char BCEN:1; 
.................... 		unsigned char MCEN:1; 
.................... 		unsigned char HTEN:1; 
.................... 		unsigned char MPEN:1; 
.................... 		unsigned char PMEN:1; 
.................... 		unsigned char CRCEN:1; 
.................... 		unsigned char ANDOR:1; 
.................... 		unsigned char UCEN:1; 
.................... 	} ERXFCONbits; 
....................  
.................... 	// MACON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char MARXEN:1; 
.................... 		unsigned char PASSALL:1; 
.................... 		unsigned char RXPAUS:1; 
.................... 		unsigned char TXPAUS:1; 
.................... 		unsigned char :4; 
.................... 	} MACON1bits; 
....................  
....................  
.................... 	// MACON3 bits -------- 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG0:1; 
.................... 		unsigned char PADCFG1:1; 
.................... 		unsigned char PADCFG2:1; 
.................... 	} MACON3bits; 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG:3; 
.................... 	} MACON3bits2; 
....................  
.................... 	// MACON4 bits -------- 
.................... 	struct { 
.................... 		unsigned char :4; 
.................... 		unsigned char NOBKOFF:1; 
.................... 		unsigned char BPEN:1; 
.................... 		unsigned char DEFER:1; 
.................... 		unsigned char blank1:1; 
.................... 	} MACON4bits; 
....................  
.................... 	// MICMD bits --------- 
.................... 	struct { 
.................... 		unsigned char MIIRD:1; 
.................... 		unsigned char MIISCAN:1; 
.................... 		unsigned char blank6:6; 
.................... 	} MICMDbits; 
....................  
.................... 	// EBSTCON bits ----- 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL0:1; 
.................... 		unsigned char TMSEL1:1; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV0:1; 
.................... 		unsigned char PSV1:1; 
.................... 		unsigned char PSV2:1; 
.................... 	} EBSTCONbits; 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL:2; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV:3; 
.................... 	} EBSTCONbits2; 
....................  
.................... 	// MISTAT bits -------- 
.................... 	struct { 
.................... 		unsigned char BUSY:1; 
.................... 		unsigned char SCAN:1; 
.................... 		unsigned char NVALID:1; 
.................... 		unsigned char blank5:5; 
.................... 	} MISTATbits; 
....................  
.................... 	// ECOCON bits ------- 
.................... 	struct { 
.................... 		unsigned char COCON0:1; 
.................... 		unsigned char COCON1:1; 
.................... 		unsigned char COCON2:1; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits; 
.................... 	struct { 
.................... 		unsigned char COCON:3; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits2; 
....................  
.................... 	// EFLOCON bits ----- 
.................... 	struct { 
.................... 		unsigned char FCEN0:1; 
.................... 		unsigned char FCEN1:1; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits; 
.................... 	struct { 
.................... 		unsigned char FCEN:2; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits2; 
.................... } REG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * PH Register Locations 
.................... ******************************************************************************/ 
.................... #define PHCON1	0x00 
.................... #define PHSTAT1	0x01 
.................... #define PHID1	0x02 
.................... #define PHID2	0x03 
.................... #define PHCON2	0x10 
.................... #define PHSTAT2	0x11 
.................... #define PHIE	0x12 
.................... #define PHIR	0x13 
.................... #define PHLCON	0x14 
....................  
....................  
.................... typedef union { 
.................... 	int16 Val; 
.................... 	WORD_VAL VAL; 
....................  
.................... 	// PHCON1 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 PDPXMD:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PPWRSV:1; 
.................... 		int8 blank22:2; 
.................... 		int8 PLOOPBK:1; 
.................... 		int8 PRST:1; 
.................... 	} PHCON1bits; 
....................  
.................... 	// PHSTAT1 bits -------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 JBSTAT:1; 
.................... 		int8 LLSTAT:1; 
.................... 		int8 blank5:5; 
.................... 		int8 blank3:3; 
.................... 		int8 PHDPX:1; 
.................... 		int8 PFDPX:1; 
.................... 		int8 blank33:3; 
.................... 	} PHSTAT1bits; 
....................  
.................... 	// PHID2 bits ---------- 
.................... 	struct { 
.................... 		int8 PREV0:1; 
.................... 		int8 PREV1:1; 
.................... 		int8 PREV2:1; 
.................... 		int8 PREV3:1; 
.................... 		int8 PPN0:1; 
.................... 		int8 PPN1:1; 
.................... 		int8 PPN2:1; 
.................... 		int8 PPN3:1; 
.................... 		int8 PPN4:1; 
.................... 		int8 PPN5:1; 
.................... 		int8 PID19:1; 
.................... 		int8 PID20:1; 
.................... 		int8 PID21:1; 
.................... 		int8 PID22:1; 
.................... 		int8 PID23:1; 
.................... 		int8 PID24:1; 
.................... 	} PHID2bits; 
.................... 	struct { 
.................... 		int8 PREV:4; 
.................... 		int8 PPNL:4; 
.................... 		int8 PPNH:2; 
.................... 		int8 PID:6; 
.................... 	} PHID2bits2; 
....................  
.................... 	// PHCON2 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 HDLDIS:1; 
.................... 		int8 blank1:1; 
.................... 		int8 JABBER:1; 
.................... 		int8 blank2:2; 
.................... 		int8 TXDIS:1; 
.................... 		int8 FRCLNK:1; 
.................... 		int8 blank11:1; 
.................... 	} PHCON2bits; 
....................  
.................... 	// PHSTAT2 bits -------- 
.................... 	struct { 
.................... 		int8 blank5:5; 
.................... 		int8 PLRITY:1; 
.................... 		int8 blank2:2; 
.................... 		int8 blank11:1; 
.................... 		int8 DPXSTAT:1; 
.................... 		int8 LSTAT:1; 
.................... 		int8 COLSTAT:1; 
.................... 		int8 RXSTAT:1; 
.................... 		int8 TXSTAT:1; 
.................... 		int8 blank22:2; 
.................... 	} PHSTAT2bits; 
....................  
.................... 	// PHIE bits ----------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 PGEIE:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PLNKIE:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIEbits; 
....................  
.................... 	// PHIR bits ----------- 
.................... 	struct { 
.................... 		int8 blank2:2; 
.................... 		int8 PGIF:1; 
.................... 		int8 blank1:1; 
.................... 		int8 PLNKIF:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIRbits; 
....................  
.................... 	// PHLCON bits ------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ0:1; 
.................... 		int8 LFRQ1:1; 
.................... 		int8 LBCFG0:1; 
.................... 		int8 LBCFG1:1; 
.................... 		int8 LBCFG2:1; 
.................... 		int8 LBCFG3:1; 
.................... 		int8 LACFG0:1; 
.................... 		int8 LACFG1:1; 
.................... 		int8 LACFG2:1; 
.................... 		int8 LACFG3:1; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits; 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ:2; 
.................... 		int8 LBCFG:4; 
.................... 		int8 LACFG:4; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits2; 
.................... } PHYREG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * Individual Register Bits 
.................... ******************************************************************************/ 
.................... // ETH/MAC/MII bits 
....................  
.................... // EIE bits ---------- 
.................... #define	EIE_INTIE		(1<<7) 
.................... #define	EIE_PKTIE		(1<<6) 
.................... #define	EIE_DMAIE		(1<<5) 
.................... #define	EIE_LINKIE		(1<<4) 
.................... #define	EIE_TXIE		(1<<3) 
.................... #define	EIE_TXERIE		(1<<1) 
.................... #define	EIE_RXERIE		(1) 
....................  
.................... // EIR bits ---------- 
.................... #define	EIR_PKTIF		(1<<6) 
.................... #define	EIR_DMAIF		(1<<5) 
.................... #define	EIR_LINKIF		(1<<4) 
.................... #define	EIR_TXIF		(1<<3) 
.................... #define	EIR_TXERIF		(1<<1) 
.................... #define	EIR_RXERIF		(1) 
....................  
.................... // ESTAT bits --------- 
.................... #define	ESTAT_INT		(1<<7) 
.................... #define ESTAT_BUFFER	(1<<6) 
.................... #define	ESTAT_LATECOL	(1<<4) 
.................... #define	ESTAT_RXBUSY	(1<<2) 
.................... #define	ESTAT_TXABRT	(1<<1) 
.................... #define	ESTAT_CLKRDY	(1) 
....................  
.................... // ECON2 bits -------- 
.................... #define	ECON2_AUTOINC	(1<<7) 
.................... #define	ECON2_PKTDEC	(1<<6) 
.................... #define	ECON2_PWRSV		(1<<5) 
.................... #define	ECON2_VRPS		(1<<3) 
....................  
.................... // ECON1 bits -------- 
.................... #define	ECON1_TXRST		(1<<7) 
.................... #define	ECON1_RXRST		(1<<6) 
.................... #define	ECON1_DMAST		(1<<5) 
.................... #define	ECON1_CSUMEN	(1<<4) 
.................... #define	ECON1_TXRTS		(1<<3) 
.................... #define	ECON1_RXEN		(1<<2) 
.................... #define	ECON1_BSEL1		(1<<1) 
.................... #define	ECON1_BSEL0		(1) 
....................  
.................... // ERXFCON bits ------ 
.................... #define	ERXFCON_UCEN	(1<<7) 
.................... #define	ERXFCON_ANDOR	(1<<6) 
.................... #define	ERXFCON_CRCEN	(1<<5) 
.................... #define	ERXFCON_PMEN	(1<<4) 
.................... #define	ERXFCON_MPEN	(1<<3) 
.................... #define	ERXFCON_HTEN	(1<<2) 
.................... #define	ERXFCON_MCEN	(1<<1) 
.................... #define	ERXFCON_BCEN	(1) 
....................  
.................... // MACON1 bits -------- 
.................... #define	MACON1_TXPAUS	(1<<3) 
.................... #define	MACON1_RXPAUS	(1<<2) 
.................... #define	MACON1_PASSALL	(1<<1) 
.................... #define	MACON1_MARXEN	(1) 
....................  
.................... // MACON3 bits -------- 
.................... #define	MACON3_PADCFG2	(1<<7) 
.................... #define	MACON3_PADCFG1	(1<<6) 
.................... #define	MACON3_PADCFG0	(1<<5) 
.................... #define	MACON3_TXCRCEN	(1<<4) 
.................... #define	MACON3_PHDRLEN	(1<<3) 
.................... #define	MACON3_HFRMEN	(1<<2) 
.................... #define	MACON3_FRMLNEN	(1<<1) 
.................... #define	MACON3_FULDPX	(1) 
....................  
.................... // MACON4 bits -------- 
.................... #define	MACON4_DEFER	(1<<6) 
.................... #define	MACON4_BPEN		(1<<5) 
.................... #define	MACON4_NOBKOFF	(1<<4) 
....................  
....................  
.................... // MICMD bits --------- 
.................... #define	MICMD_MIISCAN	(1<<1) 
.................... #define	MICMD_MIIRD		(1) 
....................  
.................... // EBSTCON bits ----- 
.................... #define	EBSTCON_PSV2	(1<<7) 
.................... #define	EBSTCON_PSV1	(1<<6) 
.................... #define	EBSTCON_PSV0	(1<<5) 
.................... #define	EBSTCON_PSEL	(1<<4) 
.................... #define	EBSTCON_TMSEL1	(1<<3) 
.................... #define	EBSTCON_TMSEL0	(1<<2) 
.................... #define	EBSTCON_TME		(1<<1) 
.................... #define	EBSTCON_BISTST	(1) 
....................  
.................... // MISTAT bits -------- 
.................... #define	MISTAT_NVALID	(1<<2) 
.................... #define	MISTAT_SCAN		(1<<1) 
.................... #define	MISTAT_BUSY		(1) 
....................  
.................... // ECOCON bits ------- 
.................... #define	ECOCON_COCON2	(1<<2) 
.................... #define	ECOCON_COCON1	(1<<1) 
.................... #define	ECOCON_COCON0	(1) 
....................  
.................... // EFLOCON bits ----- 
.................... #define	EFLOCON_FULDPXS	(1<<2) 
.................... #define	EFLOCON_FCEN1	(1<<1) 
.................... #define	EFLOCON_FCEN0	(1) 
....................  
....................  
....................  
.................... // PHY bits 
....................  
.................... // PHCON1 bits ---------- 
.................... #define	PHCON1_PRST		(1ul<<15) 
.................... #define	PHCON1_PLOOPBK	(1ul<<14) 
.................... #define	PHCON1_PPWRSV	(1ul<<11) 
.................... #define	PHCON1_PDPXMD	(1ul<<8) 
....................  
.................... // PHSTAT1 bits -------- 
.................... #define	PHSTAT1_PFDPX	(1ul<<12) 
.................... #define	PHSTAT1_PHDPX	(1ul<<11) 
.................... #define	PHSTAT1_LLSTAT	(1ul<<2) 
.................... #define	PHSTAT1_JBSTAT	(1ul<<1) 
....................  
.................... // PHID2 bits -------- 
.................... #define	PHID2_PID24		(1ul<<15) 
.................... #define	PHID2_PID23		(1ul<<14) 
.................... #define	PHID2_PID22		(1ul<<13) 
.................... #define	PHID2_PID21		(1ul<<12) 
.................... #define	PHID2_PID20		(1ul<<11) 
.................... #define	PHID2_PID19		(1ul<<10) 
.................... #define	PHID2_PPN5		(1ul<<9) 
.................... #define	PHID2_PPN4		(1ul<<8) 
.................... #define	PHID2_PPN3		(1ul<<7) 
.................... #define	PHID2_PPN2		(1ul<<6) 
.................... #define	PHID2_PPN1		(1ul<<5) 
.................... #define	PHID2_PPN0		(1ul<<4) 
.................... #define	PHID2_PREV3		(1ul<<3) 
.................... #define	PHID2_PREV2		(1ul<<2) 
.................... #define	PHID2_PREV1		(1ul<<1) 
.................... #define	PHID2_PREV0		(1ul) 
....................  
.................... // PHCON2 bits ---------- 
.................... #define	PHCON2_FRCLNK	(1ul<<14) 
.................... #define	PHCON2_TXDIS	(1ul<<13) 
.................... #define	PHCON2_JABBER	(1ul<<10) 
.................... #define	PHCON2_HDLDIS	(1ul<<8) 
....................  
.................... // PHSTAT2 bits -------- 
.................... #define	PHSTAT2_TXSTAT	(1ul<<13) 
.................... #define	PHSTAT2_RXSTAT	(1ul<<12) 
.................... #define	PHSTAT2_COLSTAT	(1ul<<11) 
.................... #define	PHSTAT2_LSTAT	(1ul<<10) 
.................... #define	PHSTAT2_DPXSTAT	(1ul<<9) 
.................... #define	PHSTAT2_PLRITY	(1ul<<5) 
....................  
.................... // PHIE bits ----------- 
.................... #define	PHIE_PLNKIE		(1ul<<4) 
.................... #define	PHIE_PGEIE		(1ul<<1) 
....................  
.................... // PHIR bits ----------- 
.................... #define	PHIR_PLNKIF		(1ul<<4) 
.................... #define	PHIR_PGIF		(1ul<<2) 
....................  
.................... // PHLCON bits ------- 
.................... #define	PHLCON_LACFG3	(1ul<<11) 
.................... #define	PHLCON_LACFG2	(1ul<<10) 
.................... #define	PHLCON_LACFG1	(1ul<<9) 
.................... #define	PHLCON_LACFG0	(1ul<<8) 
.................... #define	PHLCON_LBCFG3	(1ul<<7) 
.................... #define	PHLCON_LBCFG2	(1ul<<6) 
.................... #define	PHLCON_LBCFG1	(1ul<<5) 
.................... #define	PHLCON_LBCFG0	(1ul<<4) 
.................... #define	PHLCON_LFRQ1	(1ul<<3) 
.................... #define	PHLCON_LFRQ0	(1ul<<2) 
.................... #define	PHLCON_STRCH	(1ul<<1) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #if STACK_USE_SLIP 
.................... #error Unexpected module is detected. 
.................... #error This file must be linked when SLIP module is not in use. 
.................... #endif 
....................  
.................... #define debug_mac 
.................... //#define debug_mac debug_printf 
....................  
....................    #ifndef PIN_ENC_MAC_SO 
....................       #define PIN_ENC_MAC_SO  PIN_D7   // PIC <<<< ENC 
....................       #define PIN_ENC_MAC_SI  PIN_D6   // PIC >>>> ENC 
....................       #define PIN_ENC_MAC_CLK PIN_D5 
....................       #define PIN_ENC_MAC_CS  PIN_D4 
....................       #define PIN_ENC_MAC_RST PIN_D3 
....................       #define PIN_ENC_MAC_INT PIN_D2 
....................       #define PIN_ENC_MAC_WOL PIN_D1 
....................       #define ENC_MAC_USE_SPI FALSE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................       //#define mac_enc_spi_tris_init()  *0xF93=(*0xF93 | 0b11); *0xF94 = (*0xF94 & 0b11010111) | 0x10; *0xF95=*0xF95 & 0xFC 
....................       #define mac_enc_spi_tris_init()  *0xF95= (0b10000110); 
....................      #endif 
....................  
.................... #define SPISelectEthernet()      output_low(PIN_ENC_MAC_CS) //changed by ccs 
.................... #define SPIUnselectEthernet()   output_high(PIN_ENC_MAC_CS)   //changed by ccs 
....................  
.................... /** D E F I N I T I O N S ****************************************************/ 
.................... /* Hardware interface to NIC. */ 
.................... //#define MCP_RESET_TRIS   (TRISB_RB5)   //CCS wont use these 
.................... //#define MCP_RESET_IO   (LATB5)          //CCS wont use these 
.................... //#define MCP_CS_TRIS      (TRISB_RB3)   //CCS wont use these 
.................... //#define MCP_CS_IO      (LATB3)          //CCS wont use these 
.................... // The following SPI pins are used but are not configurable 
.................... //   RC3 is used for the SCK pin and is an output 
.................... //   RC4 is used for the SDI pin and is an input 
.................... //   RC5 is used for the SDO pin and is an output 
.................... // IMPORTANT SPI NOTE: The code in this file expects that the SPI interrupt 
.................... //      flag (PIR1_SSPIF) be clear at all times.  If the SPI is shared with 
.................... //      other hardware, the other code should clear the PIR1_SSPIF when it is 
.................... //      done using the SPI. 
....................  
.................... // Since the ENC28J60 doesn't support auto-negotiation, full-duplex mode is 
.................... // not compatible with most switches/routers.  If a dedicated network is used 
.................... // where the duplex of the remote node can be manually configured, you may 
.................... // change this configuration.  Otherwise, half duplex should always be used. 
.................... #define HALF_DUPLEX 
.................... //#define FULL_DUPLEX 
.................... //#define LEDB_DUPLEX 
....................  
.................... // Pseudo Functions 
.................... #define LOW(a)                (a & 0xFF) 
.................... #define HIGH(a)             ((a>>8) & 0xFF) 
....................  
.................... // NIC RAM definitions 
.................... #define RAMSIZE   8192ul 
.................... #define TXSTART (RAMSIZE-(MAC_TX_BUFFER_COUNT * (MAC_TX_BUFFER_SIZE + 8ul))) 
.................... #define RXSTART   (0ul)                  // Should be an even memory address 
.................... #define   RXSTOP   ((TXSTART-2ul) | 0x0001ul)   // Odd for errata workaround 
.................... #define RXSIZE   (RXSTOP-RXSTART+1ul) 
....................  
.................... // ENC28J60 Opcodes (to be ORed with a 5 bit address) 
.................... #define   WCR (0b010<<5)         // Write Control Register command 
.................... #define BFS (0b100<<5)         // Bit Field Set command 
.................... #define   BFC (0b101<<5)         // Bit Field Clear command 
.................... #define   RCR (0b000<<5)         // Read Control Register command 
.................... #define RBM ((0b001<<5) | 0x1A)   // Read Buffer Memory command 
.................... #define   WBM ((0b011<<5) | 0x1A) // Write Buffer Memory command 
.................... #define   SR  ((0b111<<5) | 0x1F)   // System Reset command does not use an address. 
....................                         //   It requires 0x1F, however. 
....................  
.................... #define ETHER_IP   (0x00u) 
.................... #define ETHER_ARP   (0x06u) 
....................  
.................... #define MAXFRAMEC   (1500u+sizeof(ETHER_HEADER)+4u) 
....................  
.................... // A generic structure representing the Ethernet header starting all Ethernet 
.................... // frames 
0212:  BCF    FF2.2
0214:  GOTO   0058
.................... typedef struct _ETHER_HEADER 
.................... { 
....................     MAC_ADDR        DestMACAddr; 
....................     MAC_ADDR        SourceMACAddr; 
....................     WORD_VAL        Type; 
.................... } ETHER_HEADER; 
....................  
.................... // A header appended at the start of all RX frames by the hardware 
.................... typedef struct _ENC_PREAMBLE 
.................... { 
....................     int16         NextPacketPointer; 
....................     RXSTATUS      StatusVector; 
....................  
....................     MAC_ADDR        DestMACAddr; 
....................     MAC_ADDR        SourceMACAddr; 
....................     WORD_VAL        Type; 
.................... } ENC_PREAMBLE; 
....................  
.................... typedef struct _DATA_BUFFER 
.................... { 
....................    WORD_VAL StartAddress; 
....................    WORD_VAL EndAddress; 
....................    struct 
....................    { 
....................       unsigned char bFree : 1; 
....................       unsigned char bTransmitted : 1; 
....................    } Flags; 
.................... } DATA_BUFFER; 
....................  
.................... void MACSetDuplex(DUPLEX DuplexState); 
....................  
.................... // Prototypes of functions intended for MAC layer use only. 
.................... static void BankSel(WORD Register); 
.................... static REG ReadETHReg(BYTE Address); 
.................... static REG ReadMACReg(BYTE Address); 
.................... static void WriteReg(BYTE Address, BYTE Data); 
.................... static void BFCReg(BYTE Address, BYTE Data); 
.................... static void BFSReg(BYTE Address, BYTE Data); 
.................... static void SendSystemReset(void); 
.................... //static void GetRegs(void); 
.................... #ifdef MAC_POWER_ON_TEST 
.................... static BOOL TestMemory(void); 
.................... #endif 
....................  
.................... /* Internal and externally used MAC level variables */ 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... static DATA_BUFFER TxBuffers[MAC_TX_BUFFER_COUNT]; 
.................... #endif 
....................  
.................... // Internal and externally used MAC level variables. 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... static DATA_BUFFER TxBuffers[MAC_TX_BUFFER_COUNT]; 
.................... BUFFER LastTXedBuffer; 
.................... #endif 
....................  
....................  
.................... // Internal MAC level variables and flags. 
.................... WORD_VAL NextPacketLocation; 
.................... WORD_VAL CurrentPacketLocation; 
.................... BOOL WasDiscarded; 
.................... BYTE ENCRevID; 
....................  
.................... //ENCSPIInit() added by CCS. 
.................... //A wrapper to the SPI routine, so you can use HW or SW SPI 
.................... void ENCSPIInit(void) 
.................... { 
....................    mac_enc_spi_tris_init();  //MCP_RESET_TRIS = 0; 
*
077C:  MOVLW  86
077E:  MOVWF  F95
....................  #if ENC_MAC_USE_SPI 
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_XMIT_L_TO_H | SPI_CLK_DIV_4); 
....................  #else 
....................    output_low(PIN_ENC_MAC_CLK); 
0780:  BCF    F95.5
0782:  BCF    F8C.5
....................    output_float(PIN_ENC_MAC_SO); 
0784:  BSF    F95.7
....................  #endif 
....................    // 
....................    // Set up the SPI module on the PIC for communications with the ENC28J60 
....................    // 
....................    SPIUnselectEthernet(); 
0786:  BCF    F95.4
0788:  BSF    F8C.4
....................  
....................    // Deassert the nRESET pin on the ENC28J60.  The internal 
....................    // weak pull on the nRESET pin will get the job done anyway, 
....................    // so this isn't necessary, but it may provide extra noise immunity, 
....................    // should someone put their finger on the pin or otherwise cause a leakage 
....................    // path to ground on this pin. 
....................    output_high(PIN_ENC_MAC_RST);            //MCP_RESET_IO = 1; 
078A:  BCF    F95.3
078C:  BSF    F8C.3
.................... } 
078E:  GOTO   0A9A (RETURN)
....................  
.................... //ENCSPIXfer() added by CCS. 
.................... //A wrapper to the SPI routine, so you can use HW or SW SPI 
.................... char ENCSPIXfer(char c) 
.................... { 
....................  #if ENC_MAC_USE_SPI 
....................    return(spi_read(c)); 
....................  #else 
....................    int8 i, in; 
....................    for (i=0;i<8;i++) { 
0792:  MOVLB  3
0794:  CLRF   xBC
0796:  MOVF   xBC,W
0798:  SUBLW  07
079A:  BNC   07C4
....................       output_bit(PIN_ENC_MAC_SI, shift_left(&c, 1, 0)); 
079C:  BCF    FD8.0
079E:  RLCF   xBB,F
07A0:  BC    07A6
07A2:  BCF    F8C.6
07A4:  BRA    07A8
07A6:  BSF    F8C.6
07A8:  BCF    F95.6
....................       output_high(PIN_ENC_MAC_CLK); 
07AA:  BCF    F95.5
07AC:  BSF    F8C.5
....................       shift_left(&in, 1, input(PIN_ENC_MAC_SO)); 
07AE:  BSF    F95.7
07B0:  BTFSC  F83.7
07B2:  BRA    07B8
07B4:  BCF    FD8.0
07B6:  BRA    07BA
07B8:  BSF    FD8.0
07BA:  RLCF   xBD,F
....................       output_low(PIN_ENC_MAC_CLK); 
07BC:  BCF    F95.5
07BE:  BCF    F8C.5
....................    } 
07C0:  INCF   xBC,F
07C2:  BRA    0796
....................    return(in); 
07C4:  MOVFF  3BD,01
....................  #endif 
.................... } 
07C8:  MOVLB  0
07CA:  RETLW  00
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACInit sets up the PIC's SPI module and all the 
....................  *               registers in the ENC28J60 so that normal operation can 
....................  *               begin. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACInit(void) 
.................... { 
....................    BYTE i; 
....................  
....................    ENCSPIInit(); 
*
0A98:  BRA    077C
....................  
....................    // Wait for CLKRDY to become set. 
....................    // Bit 3 in ESTAT is an unimplemented bit.  If it reads out as '1' that 
....................    // means the part is in RESET or otherwise our SPI pin is being driven 
....................    // incorrectly.  Make sure it is working before proceeding. 
....................    do 
....................    { 
....................       i = ReadETHReg(ESTAT).Val; 
0A9A:  MOVLW  1D
0A9C:  MOVLB  3
0A9E:  MOVWF  xB0
0AA0:  MOVLB  0
0AA2:  RCALL  07CC
0AA4:  MOVFF  01,302
....................    } while((i & 0x08) || (~i & ESTAT_CLKRDY)); 
0AA8:  MOVLB  3
0AAA:  BTFSS  x02.3
0AAC:  BRA    0AB2
0AAE:  MOVLB  0
0AB0:  BRA    0A9A
0AB2:  MOVF   x02,W
0AB4:  XORLW  FF
0AB6:  ANDLW  01
0AB8:  BTFSC  FD8.2
0ABA:  BRA    0AC0
0ABC:  MOVLB  0
0ABE:  BRA    0A9A
....................  
....................  
.................... #ifdef MAC_POWER_ON_TEST 
....................    // Do the memory test and enter a while always trap if a hardware error 
....................    // occured.  The LEDA and LEDB pins will be configured to blink 
....................    // periodically in an abnormal manner to indicate to the user that the 
....................    // error occured. 
....................    if( !TestMemory() ) 
....................    { 
....................       SetLEDConfig(0x0AA2);      // Set LEDs to blink periodically 
....................       while(1); 
....................    } 
.................... #endif 
....................  
....................    // RESET the entire ENC28J60, clearing all registers 
....................    SendSystemReset(); 
0AC0:  MOVLB  0
0AC2:  BRA    07F6
....................     delay_ms(1); 
0AC4:  MOVLW  01
0AC6:  MOVLB  3
0AC8:  MOVWF  x2F
0ACA:  MOVLB  0
0ACC:  RCALL  050E
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................     // On Init, all transmit buffers are free. 
....................     for (i = 0; i < MAC_TX_BUFFER_COUNT; i++ ) 
....................     { 
....................         TxBuffers[i].StartAddress.Val = TXSTART + ((WORD)i * (MAC_TX_BUFFER_SIZE+8)); 
....................         TxBuffers[i].Flags.bFree = TRUE; 
....................     } 
.................... #endif 
....................     CurrentTxBuffer = 0; 
0ACE:  CLRF   4F
....................  
....................    // Start up in Bank 0 and configure the receive buffer boundary pointers 
....................    // and the buffer write protect pointer (receive buffer read pointer) 
....................    WasDiscarded = TRUE; 
0AD0:  BSF    58.0
....................    NextPacketLocation.Val = RXSTART; 
0AD2:  CLRF   55
0AD4:  CLRF   54
....................    WriteReg(ERXSTL, LOW(RXSTART)); 
0AD6:  MOVLW  08
0AD8:  MOVLB  3
0ADA:  MOVWF  xB6
0ADC:  CLRF   xB7
0ADE:  MOVLB  0
0AE0:  RCALL  080C
....................    WriteReg(ERXSTH, HIGH(RXSTART)); 
0AE2:  MOVLW  09
0AE4:  MOVLB  3
0AE6:  MOVWF  xB6
0AE8:  CLRF   xB7
0AEA:  MOVLB  0
0AEC:  RCALL  080C
....................    WriteReg(ERXRDPTL, LOW(RXSTOP));   // Write low byte first 
0AEE:  MOVLW  0C
0AF0:  MOVLB  3
0AF2:  MOVWF  xB6
0AF4:  MOVLW  F7
0AF6:  MOVWF  xB7
0AF8:  MOVLB  0
0AFA:  RCALL  080C
....................    WriteReg(ERXRDPTH, HIGH(RXSTOP));   // Write high byte last 
0AFC:  MOVLW  0D
0AFE:  MOVLB  3
0B00:  MOVWF  xB6
0B02:  MOVLW  1B
0B04:  MOVWF  xB7
0B06:  MOVLB  0
0B08:  RCALL  080C
.................... #if RXSTOP != 0x1FFF   // The RESET default ERXND is 0x1FFF 
....................    WriteReg(ERXNDL, LOW(RXSTOP)); 
0B0A:  MOVLW  0A
0B0C:  MOVLB  3
0B0E:  MOVWF  xB6
0B10:  MOVLW  F7
0B12:  MOVWF  xB7
0B14:  MOVLB  0
0B16:  RCALL  080C
....................    WriteReg(ERXNDH, HIGH(RXSTOP)); 
0B18:  MOVLW  0B
0B1A:  MOVLB  3
0B1C:  MOVWF  xB6
0B1E:  MOVLW  1B
0B20:  MOVWF  xB7
0B22:  MOVLB  0
0B24:  RCALL  080C
.................... #endif 
.................... #if TXSTART != 0      // The RESET default ETXST is 0 
....................    WriteReg(ETXSTL, LOW(TXSTART)); 
0B26:  MOVLW  04
0B28:  MOVLB  3
0B2A:  MOVWF  xB6
0B2C:  MOVLW  F8
0B2E:  MOVWF  xB7
0B30:  MOVLB  0
0B32:  RCALL  080C
....................    WriteReg(ETXSTH, HIGH(TXSTART)); 
0B34:  MOVLW  05
0B36:  MOVLB  3
0B38:  MOVWF  xB6
0B3A:  MOVLW  1B
0B3C:  MOVWF  xB7
0B3E:  MOVLB  0
0B40:  RCALL  080C
.................... #endif 
....................  
....................    // Enter Bank 1 and configure Receive Filters 
....................    // (No need to reconfigure - Unicast OR Broadcast with CRC checking is 
....................    // acceptable) 
....................    // Write ERXFCON_CRCEN only to ERXFCON to enter promiscuous mode 
....................    //BankSel(ERXFCON); 
....................    //WriteReg((BYTE)ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN | ERXFCON_HTEN); 
....................  
....................    // Enter Bank 2 and configure the MAC 
....................    BankSel(MACON1); 
0B42:  MOVLW  02
0B44:  MOVLB  3
0B46:  MOVWF  xB4
0B48:  CLRF   xB3
0B4A:  MOVLB  0
0B4C:  RCALL  0866
....................  
....................    // Enable the receive portion of the MAC 
....................    WriteReg((BYTE)MACON1, MACON1_TXPAUS | MACON1_RXPAUS | MACON1_MARXEN); 
0B4E:  MOVLB  3
0B50:  CLRF   xB6
0B52:  MOVLW  0D
0B54:  MOVWF  xB7
0B56:  MOVLB  0
0B58:  RCALL  080C
....................  
....................    // Pad packets to 60 bytes, add CRC, and check Type/Length field. 
....................    WriteReg((BYTE)MACON3, MACON3_PADCFG0 | MACON3_TXCRCEN | MACON3_FRMLNEN); 
0B5A:  MOVLW  02
0B5C:  MOVLB  3
0B5E:  MOVWF  xB6
0B60:  MOVLW  32
0B62:  MOVWF  xB7
0B64:  MOVLB  0
0B66:  RCALL  080C
....................  
....................     // Allow infinite deferals if the medium is continuously busy 
....................     // (do not time out a transmission if the half duplex medium is 
....................     // completely saturated with other people's data) 
....................     WriteReg((BYTE)MACON4, MACON4_DEFER); 
0B68:  MOVLW  03
0B6A:  MOVLB  3
0B6C:  MOVWF  xB6
0B6E:  MOVLW  40
0B70:  MOVWF  xB7
0B72:  MOVLB  0
0B74:  RCALL  080C
....................  
....................    // Late collisions occur beyond 63+8 bytes (8 bytes for preamble/start of frame delimiter) 
....................    // 55 is all that is needed for IEEE 802.3, but ENC28J60 B5 errata for improper link pulse 
....................    // collisions will occur less often with a larger number. 
....................     WriteReg((BYTE)MACLCON2, 63); 
0B76:  MOVLW  09
0B78:  MOVLB  3
0B7A:  MOVWF  xB6
0B7C:  MOVLW  3F
0B7E:  MOVWF  xB7
0B80:  MOVLB  0
0B82:  RCALL  080C
....................  
....................    // Set non-back-to-back inter-packet gap to 9.6us.  The back-to-back 
....................    // inter-packet gap (MABBIPG) is set by MACSetDuplex() which is called 
....................    // later. 
....................    WriteReg((BYTE)MAIPGL, 0x12); 
0B84:  MOVLW  06
0B86:  MOVLB  3
0B88:  MOVWF  xB6
0B8A:  MOVLW  12
0B8C:  MOVWF  xB7
0B8E:  MOVLB  0
0B90:  RCALL  080C
....................    WriteReg((BYTE)MAIPGH, 0x0C); 
0B92:  MOVLW  07
0B94:  MOVLB  3
0B96:  MOVWF  xB6
0B98:  MOVLW  0C
0B9A:  MOVWF  xB7
0B9C:  MOVLB  0
0B9E:  RCALL  080C
....................  
....................    // Set the maximum packet size which the controller will accept 
....................    WriteReg((BYTE)MAMXFLL, LOW(MAXFRAMEC)); 
0BA0:  MOVLW  0A
0BA2:  MOVLB  3
0BA4:  MOVWF  xB6
0BA6:  MOVLW  EE
0BA8:  MOVWF  xB7
0BAA:  MOVLB  0
0BAC:  RCALL  080C
....................    WriteReg((BYTE)MAMXFLH, HIGH(MAXFRAMEC)); 
0BAE:  MOVLW  0B
0BB0:  MOVLB  3
0BB2:  MOVWF  xB6
0BB4:  MOVLW  05
0BB6:  MOVWF  xB7
0BB8:  MOVLB  0
0BBA:  RCALL  080C
....................  
....................     // Enter Bank 3 and initialize physical MAC address registers 
....................    BankSel(MAADR1); 
0BBC:  MOVLW  03
0BBE:  MOVLB  3
0BC0:  MOVWF  xB4
0BC2:  MOVLW  04
0BC4:  MOVWF  xB3
0BC6:  MOVLB  0
0BC8:  RCALL  0866
....................     WriteReg((BYTE)MAADR1, AppConfig.MyMACAddr.v[0]); 
0BCA:  MOVLW  04
0BCC:  MOVLB  3
0BCE:  MOVWF  xB6
0BD0:  MOVFF  1C,3B7
0BD4:  MOVLB  0
0BD6:  RCALL  080C
....................     WriteReg((BYTE)MAADR2, AppConfig.MyMACAddr.v[1]); 
0BD8:  MOVLW  05
0BDA:  MOVLB  3
0BDC:  MOVWF  xB6
0BDE:  MOVFF  1D,3B7
0BE2:  MOVLB  0
0BE4:  RCALL  080C
....................     WriteReg((BYTE)MAADR3, AppConfig.MyMACAddr.v[2]); 
0BE6:  MOVLW  02
0BE8:  MOVLB  3
0BEA:  MOVWF  xB6
0BEC:  MOVFF  1E,3B7
0BF0:  MOVLB  0
0BF2:  RCALL  080C
....................     WriteReg((BYTE)MAADR4, AppConfig.MyMACAddr.v[3]); 
0BF4:  MOVLW  03
0BF6:  MOVLB  3
0BF8:  MOVWF  xB6
0BFA:  MOVFF  1F,3B7
0BFE:  MOVLB  0
0C00:  RCALL  080C
....................     WriteReg((BYTE)MAADR5, AppConfig.MyMACAddr.v[4]); 
0C02:  MOVLB  3
0C04:  CLRF   xB6
0C06:  MOVFF  20,3B7
0C0A:  MOVLB  0
0C0C:  RCALL  080C
....................     WriteReg((BYTE)MAADR6, AppConfig.MyMACAddr.v[5]); 
0C0E:  MOVLW  01
0C10:  MOVLB  3
0C12:  MOVWF  xB6
0C14:  MOVFF  21,3B7
0C18:  MOVLB  0
0C1A:  RCALL  080C
....................  
....................    // Get the Rev ID so that we can implement the correct errata workarounds 
....................    ENCRevID = ReadETHReg((BYTE)EREVID).Val; 
0C1C:  MOVLW  12
0C1E:  MOVLB  3
0C20:  MOVWF  xB0
0C22:  MOVLB  0
0C24:  RCALL  07CC
0C26:  MOVFF  01,59
....................  
....................    // Disable half duplex loopback in PHY.  Bank bits changed to Bank 2 as a 
....................    // side effect. 
....................    WritePHYReg(PHCON2, PHCON2_HDLDIS); 
0C2A:  MOVLW  10
0C2C:  MOVLB  3
0C2E:  MOVWF  x07
0C30:  MOVLW  01
0C32:  MOVWF  x09
0C34:  CLRF   x08
0C36:  MOVLB  0
0C38:  RCALL  08CE
....................  
....................    // Configure LEDA to display LINK status, LEDB to display TX/RX activity 
....................    SetLEDConfig(0x0472); 
0C3A:  MOVLW  14
0C3C:  MOVLB  3
0C3E:  MOVWF  x07
0C40:  MOVLW  04
0C42:  MOVWF  x09
0C44:  MOVLW  72
0C46:  MOVWF  x08
0C48:  MOVLB  0
0C4A:  RCALL  08CE
....................  
....................    // Set the MAC and PHY into the proper duplex state 
.................... #if defined(FULL_DUPLEX) 
....................    MACSetDuplex(FULL);      // Function exits with Bank 2 selected 
.................... #elif defined(HALF_DUPLEX) 
....................    MACSetDuplex(HALF);      // Function exits with Bank 2 selected 
0C4C:  MOVLB  3
0C4E:  CLRF   x03
0C50:  MOVLB  0
0C52:  BRA    09FC
.................... #else 
....................    // Use the external LEDB polarity to determine weather full or half duplex 
....................    // communication mode should be set. 
....................    MACSetDuplex(USE_PHY);   // Function exits with Bank 2 selected 
.................... #endif 
....................  
....................    // Enable packet reception 
....................    BFSReg(ECON1, ECON1_RXEN); 
0C54:  MOVLW  1F
0C56:  MOVLB  3
0C58:  MOVWF  xB8
0C5A:  MOVLW  04
0C5C:  MOVWF  xB9
0C5E:  MOVLB  0
0C60:  RCALL  0848
.................... }//end MACInit 
0C62:  GOTO   106C (RETURN)
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsLinked(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE: If the PHY reports that a link partner is present 
....................  *                    and the link has been up continuously since the last 
....................  *                    call to MACIsLinked() 
....................  *               FALSE: If the PHY reports no link partner, or the link went 
....................  *                     down momentarily since the last call to MACIsLinked() 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the PHSTAT1.LLSTAT bit. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsLinked(void) 
.................... { 
....................    // LLSTAT is a latching low link status bit.  Therefore, if the link 
....................    // goes down and comes back up before a higher level stack program calls 
....................    // MACIsLinked(), MACIsLinked() will still return FALSE.  The next 
....................    // call to MACIsLinked() will return TRUE (unless the link goes down 
....................    // again). 
....................    return ReadPHYReg(PHSTAT1).PHSTAT1bits.LLSTAT; 
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           HighPriority: TRUE: Check the hardware ECON1.TXRTS bit 
....................  *                          FALSE: Check if a TX buffer is free 
....................  * 
....................  * Output:          TRUE: If no Ethernet transmission is in progress 
....................  *               FALSE: If a previous transmission was started, and it has 
....................  *                     not completed yet.  While FALSE, the data in the 
....................  *                     transmit buffer and the TXST/TXND pointers must not 
....................  *                     be changed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the ECON1.TXRTS bit 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsTxReady(BOOL HighPriority) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    BUFFER i; 
....................  
....................    if(HighPriority) 
.................... #endif 
....................    { 
....................        return !ReadETHReg(ECON1).ECON1bits.TXRTS; 
*
25B2:  MOVLW  1F
25B4:  MOVLB  3
25B6:  MOVWF  xB0
25B8:  MOVLB  0
25BA:  CALL   07CC
25BE:  MOVFF  01,392
25C2:  MOVLW  00
25C4:  MOVLB  3
25C6:  BTFSC  01.3
25C8:  MOVLW  01
25CA:  XORLW  00
25CC:  BZ    25D2
25CE:  MOVLW  00
25D0:  BRA    25D4
25D2:  MOVLW  01
25D4:  MOVWF  01
25D6:  BRA    25D8
....................    } 
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................  
....................    // Check if the current buffer can be modified.  It cannot be modified if 
....................    // the TX hardware is currently transmitting it. 
....................    if(CurrentTxBuffer == LastTXedBuffer) 
....................    { 
....................        return !ReadETHReg(ECON1).ECON1bits.TXRTS; 
....................    } 
....................  
....................    // Check if a buffer is available for a new packet 
....................    for(i = 1; i < MAC_TX_BUFFER_COUNT; i++) 
....................    { 
....................       if(TxBuffers[i].Flags.bFree) 
....................       { 
....................          return TRUE; 
....................       } 
....................    } 
....................  
....................    return FALSE; 
.................... #endif 
.................... } 
25D8:  MOVLB  0
25DA:  RETLW  00
....................  
.................... BUFFER MACGetTxBuffer(BOOL HighPriority) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    BUFFER i; 
....................  
....................    if(HighPriority) 
.................... #endif 
....................    { 
....................       return !ReadETHReg(ECON1).ECON1bits.TXRTS ? 0 : INVALID_BUFFER; 
*
1448:  MOVLW  1F
144A:  MOVLB  3
144C:  MOVWF  xB0
144E:  MOVLB  0
1450:  CALL   07CC
1454:  MOVFF  01,392
1458:  MOVLW  00
145A:  MOVLB  3
145C:  BTFSC  01.3
145E:  MOVLW  01
1460:  XORLW  00
1462:  BNZ   1468
1464:  MOVLW  00
1466:  BRA    146A
1468:  MOVLW  FF
146A:  MOVWF  01
146C:  BRA    146E
....................    } 
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    // Find a free buffer.  Do not use buffer 0, it is reserved for 
....................    // high priority messages that don't need to be acknowledged 
....................    // before being discarded (TCP control packets, all ICMP 
....................    // packets, all UDP packets, etc.) 
....................    for(i = 1; i < MAC_TX_BUFFER_COUNT; i++) 
....................    { 
....................       // If this buffer is free, then mark it as used and return with it 
....................       if(TxBuffers[i].Flags.bFree) 
....................       { 
....................          TxBuffers[i].Flags.bFree = FALSE; 
....................          TxBuffers[i].Flags.bTransmitted = FALSE; 
....................          return i; 
....................       } 
....................    } 
....................  
....................    return INVALID_BUFFER; 
.................... #endif 
.................... } 
146E:  MOVLB  0
1470:  RETLW  00
....................  
....................  
.................... void MACDiscardTx(BUFFER buffer) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    if(buffer < sizeof(TxBuffers)/sizeof(TxBuffers[0])) 
....................    { 
....................        TxBuffers[buffer].Flags.bFree = TRUE; 
....................        CurrentTxBuffer = buffer; 
....................    } 
.................... #endif 
.................... } 
*
0004:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACDiscardRx(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Marks the last received packet (obtained using 
....................  *               MACGetHeader())as being processed and frees the buffer 
....................  *               memory associated with it 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACDiscardRx(void) 
.................... { 
....................    WORD_VAL NewRXRDLocation; 
....................  
....................    // Make sure the current packet was not already discarded 
....................    if( WasDiscarded ) 
*
1076:  BTFSS  58.0
1078:  BRA    107C
....................       return; 
107A:  BRA    10E0
....................    WasDiscarded = TRUE; 
107C:  BSF    58.0
....................  
....................    // Decrement the next packet pointer before writing it into 
....................    // the ERXRDPT registers.  This is a silicon errata workaround. 
....................    // RX buffer wrapping must be taken into account if the 
....................    // NextPacketLocation is precisely RXSTART. 
....................    NewRXRDLocation.Val = NextPacketLocation.Val - 1; 
107E:  MOVLW  01
1080:  SUBWF  54,W
1082:  MOVLB  3
1084:  MOVWF  x54
1086:  MOVLW  00
1088:  SUBWFB 55,W
108A:  MOVWF  x55
.................... #if RXSTART == 0 
....................    if(NewRXRDLocation.Val > RXSTOP) 
108C:  MOVF   x55,W
108E:  SUBLW  1A
1090:  BC    10A4
1092:  XORLW  FF
1094:  BNZ   109C
1096:  MOVF   x54,W
1098:  SUBLW  F7
109A:  BC    10A4
.................... #else 
....................    if(NewRXRDLocation.Val < RXSTART || NewRXRDLocation.Val > RXSTOP) 
.................... #endif 
....................    { 
....................       NewRXRDLocation.Val = RXSTOP; 
109C:  MOVLW  1B
109E:  MOVWF  x55
10A0:  MOVLW  F7
10A2:  MOVWF  x54
....................    } 
....................  
....................    // Decrement the RX packet counter register, EPKTCNT 
....................    BFSReg(ECON2, ECON2_PKTDEC); 
10A4:  MOVLW  1E
10A6:  MOVWF  xB8
10A8:  MOVLW  40
10AA:  MOVWF  xB9
10AC:  MOVLB  0
10AE:  CALL   0848
....................  
....................    // Move the receive read pointer to unwrite-protect the memory used by the 
....................    // last packet.  The writing order is important: set the low byte first, 
....................    // high byte last. 
....................    BankSel(ERXRDPTL); 
10B2:  MOVLB  3
10B4:  CLRF   xB4
10B6:  MOVLW  0C
10B8:  MOVWF  xB3
10BA:  MOVLB  0
10BC:  CALL   0866
....................    WriteReg(ERXRDPTL, NewRXRDLocation.v[0]); 
10C0:  MOVLW  0C
10C2:  MOVLB  3
10C4:  MOVWF  xB6
10C6:  MOVFF  354,3B7
10CA:  MOVLB  0
10CC:  CALL   080C
....................    WriteReg(ERXRDPTH, NewRXRDLocation.v[1]); 
10D0:  MOVLW  0D
10D2:  MOVLB  3
10D4:  MOVWF  xB6
10D6:  MOVFF  355,3B7
10DA:  MOVLB  0
10DC:  CALL   080C
.................... } 
10E0:  RETLW  00
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetFreeRxSize(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          A WORD estimate of how much RX buffer space is free at 
....................  *               the present time. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetFreeRxSize(void) 
.................... { 
....................    WORD_VAL ReadPT, WritePT; 
....................  
....................    // Read the Ethernet hardware buffer write pointer.  Because packets can be 
....................    // received at any time, it can change between reading the low and high 
....................    // bytes.  A loop is necessary to make certain a proper low/high byte pair 
....................    // is read. 
....................    BankSel(EPKTCNT); 
*
25DC:  MOVLW  01
25DE:  MOVLB  3
25E0:  MOVWF  xB4
25E2:  MOVLW  19
25E4:  MOVWF  xB3
25E6:  MOVLB  0
25E8:  CALL   0866
....................    do { 
....................       // Save EPKTCNT in a temporary location 
....................       ReadPT.v[0] = ReadETHReg((BYTE)EPKTCNT).Val; 
25EC:  MOVLW  19
25EE:  MOVLB  3
25F0:  MOVWF  xB0
25F2:  MOVLB  0
25F4:  CALL   07CC
25F8:  MOVFF  01,391
....................  
....................       BankSel(ERXWRPTL); 
25FC:  MOVLB  3
25FE:  CLRF   xB4
2600:  MOVLW  0E
2602:  MOVWF  xB3
2604:  MOVLB  0
2606:  CALL   0866
....................       WritePT.v[0] = ReadETHReg(ERXWRPTL).Val; 
260A:  MOVLW  0E
260C:  MOVLB  3
260E:  MOVWF  xB0
2610:  MOVLB  0
2612:  CALL   07CC
2616:  MOVFF  01,393
....................       WritePT.v[1] = ReadETHReg(ERXWRPTH).Val; 
261A:  MOVLW  0F
261C:  MOVLB  3
261E:  MOVWF  xB0
2620:  MOVLB  0
2622:  CALL   07CC
2626:  MOVFF  01,394
....................  
....................       BankSel(EPKTCNT); 
262A:  MOVLW  01
262C:  MOVLB  3
262E:  MOVWF  xB4
2630:  MOVLW  19
2632:  MOVWF  xB3
2634:  MOVLB  0
2636:  CALL   0866
....................    } while(ReadETHReg((BYTE)EPKTCNT).Val != ReadPT.v[0]); 
263A:  MOVLW  19
263C:  MOVLB  3
263E:  MOVWF  xB0
2640:  MOVLB  0
2642:  CALL   07CC
2646:  MOVFF  01,395
264A:  MOVLB  3
264C:  MOVF   x91,W
264E:  SUBWF  01,W
2650:  BTFSC  FD8.2
2652:  BRA    2658
2654:  MOVLB  0
2656:  BRA    25EC
....................  
....................    // Determine where the write protection pointer is 
....................    BankSel(ERXRDPTL); 
2658:  CLRF   xB4
265A:  MOVLW  0C
265C:  MOVWF  xB3
265E:  MOVLB  0
2660:  CALL   0866
....................    ReadPT.v[0] = ReadETHReg(ERXRDPTL).Val; 
2664:  MOVLW  0C
2666:  MOVLB  3
2668:  MOVWF  xB0
266A:  MOVLB  0
266C:  CALL   07CC
2670:  MOVFF  01,391
....................    ReadPT.v[1] = ReadETHReg(ERXRDPTH).Val; 
2674:  MOVLW  0D
2676:  MOVLB  3
2678:  MOVWF  xB0
267A:  MOVLB  0
267C:  CALL   07CC
2680:  MOVFF  01,392
....................  
....................    // Calculate the difference between the pointers, taking care to account 
....................    // for buffer wrapping conditions 
....................    if ( WritePT.Val > ReadPT.Val ) 
2684:  MOVLB  3
2686:  MOVF   x92,W
2688:  SUBWF  x94,W
268A:  BNC   26B8
268C:  BNZ   2694
268E:  MOVF   x93,W
2690:  SUBWF  x91,W
2692:  BC    26B8
....................    { 
....................       return (RXSTOP - RXSTART) - (WritePT.Val - ReadPT.Val); 
2694:  MOVF   x91,W
2696:  SUBWF  x93,W
2698:  MOVWF  00
269A:  MOVF   x92,W
269C:  SUBWFB x94,W
269E:  MOVWF  03
26A0:  MOVF   00,W
26A2:  XORLW  FF
26A4:  ADDLW  F8
26A6:  MOVWF  00
26A8:  MOVLW  1B
26AA:  SUBFWB 03,F
26AC:  MOVFF  00,01
26B0:  MOVFF  03,02
26B4:  BRA    26F0
....................    } 
....................    else if ( WritePT.Val == ReadPT.Val ) 
26B6:  BRA    26F0
26B8:  MOVF   x91,W
26BA:  SUBWF  x93,W
26BC:  BNZ   26D0
26BE:  MOVF   x92,W
26C0:  SUBWF  x94,W
26C2:  BNZ   26D0
....................    { 
....................       return RXSIZE - 1; 
26C4:  MOVLW  F7
26C6:  MOVWF  01
26C8:  MOVLW  1B
26CA:  MOVWF  02
26CC:  BRA    26F0
....................    } 
....................    else 
26CE:  BRA    26F0
....................     { 
....................       return ReadPT.Val - WritePT.Val - 1; 
26D0:  MOVF   x93,W
26D2:  SUBWF  x91,W
26D4:  MOVWF  x95
26D6:  MOVF   x94,W
26D8:  SUBWFB x92,W
26DA:  MOVWF  x96
26DC:  MOVLW  01
26DE:  SUBWF  x95,W
26E0:  MOVWF  00
26E2:  MOVLW  00
26E4:  SUBWFB x96,W
26E6:  MOVWF  03
26E8:  MOVFF  00,01
26EC:  MOVWF  02
26EE:  BRA    26F0
....................    } 
.................... } 
26F0:  MOVLB  0
26F2:  GOTO   297A (RETURN)
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           *remote: Location to store the Source MAC address of the 
....................  *                      received frame. 
....................  *               *type: Location of a BYTE to store the constant 
....................  *                     MAC_UNKNOWN, ETHER_IP, or ETHER_ARP, representing 
....................  *                     the contents of the Ethernet type field. 
....................  * 
....................  * Output:          TRUE: If a packet was waiting in the RX buffer.  The 
....................  *                    remote, and type values are updated. 
....................  *               FALSE: If a packet was not pending.  remote and type are 
....................  *                     not changed. 
....................  * 
....................  * Side Effects:    Last packet is discarded if MACDiscardRx() hasn't already 
....................  *               been called. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
.................... { 
....................    ENC_PREAMBLE header; 
....................  
....................    // Test if at least one packet has been received and is waiting 
....................    BankSel(EPKTCNT); 
*
115C:  MOVLW  01
115E:  MOVLB  3
1160:  MOVWF  xB4
1162:  MOVLW  19
1164:  MOVWF  xB3
1166:  MOVLB  0
1168:  CALL   0866
....................    if(ReadETHReg((BYTE)EPKTCNT).Val == 0) 
116C:  MOVLW  19
116E:  MOVLB  3
1170:  MOVWF  xB0
1172:  MOVLB  0
1174:  CALL   07CC
1178:  MOVFF  01,320
117C:  MOVLB  3
117E:  MOVF   x20,F
1180:  BNZ   1188
....................       return FALSE; 
1182:  MOVLW  00
1184:  MOVWF  01
1186:  BRA    128C
....................  
....................    // Make absolutely certain that any previous packet was discarded 
....................    if(WasDiscarded == FALSE) 
1188:  BTFSC  58.0
118A:  BRA    1198
....................    { 
....................       MACDiscardRx(); 
118C:  MOVLB  0
118E:  RCALL  1076
....................       return FALSE; 
1190:  MOVLW  00
1192:  MOVWF  01
1194:  MOVLB  3
1196:  BRA    128C
....................    } 
....................  
....................    // Save the location of this packet 
....................    CurrentPacketLocation.Val = NextPacketLocation.Val; 
1198:  MOVFF  55,57
119C:  MOVFF  54,56
....................  
....................    // Set the SPI read pointer to the beginning of the next unprocessed packet 
....................    BankSel(ERDPTL); 
11A0:  CLRF   xB4
11A2:  CLRF   xB3
11A4:  MOVLB  0
11A6:  CALL   0866
....................    WriteReg(ERDPTL, NextPacketLocation.v[0]); 
11AA:  MOVLB  3
11AC:  CLRF   xB6
11AE:  MOVFF  54,3B7
11B2:  MOVLB  0
11B4:  CALL   080C
....................    WriteReg(ERDPTH, NextPacketLocation.v[1]); 
11B8:  MOVLW  01
11BA:  MOVLB  3
11BC:  MOVWF  xB6
11BE:  MOVFF  55,3B7
11C2:  MOVLB  0
11C4:  CALL   080C
....................  
....................    // Obtain the MAC header from the Ethernet buffer 
....................    MACGetArray((BYTE*)&header, sizeof(header)); 
11C8:  MOVLW  03
11CA:  MOVLB  3
11CC:  MOVWF  x21
11CE:  MOVLW  0C
11D0:  MOVFF  321,3A0
11D4:  MOVWF  x9F
11D6:  CLRF   xA2
11D8:  MOVLW  14
11DA:  MOVWF  xA1
11DC:  MOVLB  0
11DE:  RCALL  10E2
....................  
....................    // The EtherType field, like most items transmitted on the Ethernet medium 
....................    // are in big endian. 
....................     header.Type.Val = swaps(header.Type.Val); 
11E0:  MOVFF  31F,3B1
11E4:  MOVFF  31E,3B0
11E8:  RCALL  1146
11EA:  MOVFF  02,31F
11EE:  MOVFF  01,31E
....................  
....................    // Validate the data returned from the ENC28J60.  Random data corruption, 
....................    // such as if a single SPI bit error occurs while communicating or a 
....................    // momentary power glitch could cause this to occur in rare circumstances. 
....................    if(header.NextPacketPointer > RXSTOP || ((BYTE_VAL*)(&header.NextPacketPointer))->bits.b0 || 
....................       header.StatusVector.bits.Zero || 
....................       header.StatusVector.bits.CRCError || 
....................       header.StatusVector.bits.ByteCount > 1518 || 
....................       !header.StatusVector.bits.ReceiveOk) 
11F2:  MOVLB  3
11F4:  MOVF   x0D,W
11F6:  SUBLW  1A
11F8:  BC    1204
11FA:  XORLW  FF
11FC:  BNZ   1230
11FE:  MOVF   x0C,W
1200:  SUBLW  F7
1202:  BNC   1230
1204:  MOVLW  03
1206:  MOVWF  x21
1208:  MOVLW  0C
120A:  MOVWF  FE9
120C:  MOVFF  321,FEA
1210:  BTFSC  FEF.0
1212:  BRA    1230
1214:  BTFSC  x11.7
1216:  BRA    1230
1218:  BTFSC  x10.4
121A:  BRA    1230
121C:  MOVF   x0F,W
121E:  SUBLW  04
1220:  BC    122C
1222:  XORLW  FF
1224:  BNZ   1230
1226:  MOVF   x0E,W
1228:  SUBLW  EE
122A:  BNC   1230
122C:  BTFSC  x10.7
122E:  BRA    1232
....................    { 
....................       //Reset(); 
....................       reset_cpu(); 
1230:  RESET
....................    } 
....................  
....................    // Save the location where the hardware will write the next packet to 
....................    NextPacketLocation.Val = header.NextPacketPointer; 
1232:  MOVFF  30D,55
1236:  MOVFF  30C,54
....................  
....................    // Return the Ethernet frame's Source MAC address field to the caller 
....................    // This parameter is useful for replying to requests without requiring an 
....................    // ARP cycle. 
....................     memcpy((void*)remote->v, (void*)header.SourceMACAddr.v, sizeof(*remote)); 
123A:  MOVFF  308,320
123E:  MOVFF  309,321
1242:  MOVFF  309,FEA
1246:  MOVFF  308,FE9
124A:  MOVLW  03
124C:  MOVWF  FE2
124E:  MOVLW  18
1250:  MOVWF  FE1
1252:  MOVLW  06
1254:  MOVWF  01
1256:  MOVFF  FE6,FEE
125A:  DECFSZ 01,F
125C:  BRA    1256
....................  
....................    // Return a simplified version of the EtherType field to the caller 
....................     *type = MAC_UNKNOWN; 
125E:  MOVFF  30A,FE9
1262:  MOVFF  30B,FEA
1266:  MOVLW  FF
1268:  MOVWF  FEF
....................     if( (header.Type.v[1] == 0x08u) && 
....................        ((header.Type.v[0] == ETHER_IP) || (header.Type.v[0] == ETHER_ARP)) ) 
126A:  MOVF   x1F,W
126C:  SUBLW  08
126E:  BNZ   1286
1270:  MOVF   x1E,F
1272:  BZ    127A
1274:  MOVF   x1E,W
1276:  SUBLW  06
1278:  BNZ   1286
....................     { 
....................        *type = header.Type.v[0]; 
127A:  MOVFF  30A,FE9
127E:  MOVFF  30B,FEA
1282:  MOVFF  31E,FEF
....................     } 
....................  
....................     // Mark this packet as discardable 
....................     WasDiscarded = FALSE; 
1286:  BCF    58.0
....................    return TRUE; 
1288:  MOVLW  01
128A:  MOVWF  01
.................... } 
128C:  MOVLB  0
128E:  GOTO   6B76 (RETURN)
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void    MACPutHeader(MAC_ADDR *remote, 
....................  *                                    BYTE type, 
....................  *                                   WORD dataLen) 
....................  * 
....................  * PreCondition:    MACIsTxReady() must return TRUE. 
....................  * 
....................  * Input:           *remote: Pointer to memory which contains the destination 
....................  *                       MAC address (6 bytes) 
....................  *               type: The constant ETHER_ARP or ETHER_IP, defining which 
....................  *                    value to write into the Ethernet header's type field. 
....................  *               dataLen: Length of the Ethernet data payload 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Because of the dataLen parameter, it is probably 
....................  *               advantagous to call this function immediately before 
....................  *               transmitting a packet rather than initially when the 
....................  *               packet is first created.  The order in which the packet 
....................  *               is constructed (header first or data first) is not 
....................  *               important. 
....................  *****************************************************************************/ 
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen) 
.................... { 
....................  
....................    BankSel(EWRPTL); 
*
1588:  MOVLB  3
158A:  CLRF   xB4
158C:  MOVLW  02
158E:  MOVWF  xB3
1590:  MOVLB  0
1592:  CALL   0866
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    // Set the SPI write pointer to the beginning of the transmit buffer 
....................    WriteReg(EWRPTL, TxBuffers[CurrentTxBuffer].StartAddress.v[0]); 
....................    WriteReg(EWRPTH, TxBuffers[CurrentTxBuffer].StartAddress.v[1]); 
....................  
....................    // Calculate where to put the TXND pointer 
....................     dataLen += (WORD)sizeof(ETHER_HEADER) + TxBuffers[CurrentTxBuffer].StartAddress.Val; 
....................    TxBuffers[CurrentTxBuffer].EndAddress.Val = dataLen; 
.................... #else 
....................    // Set the SPI write pointer to the beginning of the transmit buffer 
....................    WriteReg(EWRPTL, LOW(TXSTART)); 
1596:  MOVLW  02
1598:  MOVLB  3
159A:  MOVWF  xB6
159C:  MOVLW  F8
159E:  MOVWF  xB7
15A0:  MOVLB  0
15A2:  CALL   080C
....................    WriteReg(EWRPTH, HIGH(TXSTART)); 
15A6:  MOVLW  03
15A8:  MOVLB  3
15AA:  MOVWF  xB6
15AC:  MOVLW  1B
15AE:  MOVWF  xB7
15B0:  MOVLB  0
15B2:  CALL   080C
....................  
....................    // Calculate where to put the TXND pointer 
....................     dataLen += (WORD)sizeof(ETHER_HEADER) + TXSTART; 
15B6:  MOVLW  06
15B8:  MOVLB  3
15BA:  ADDWF  xB1,F
15BC:  MOVLW  1C
15BE:  ADDWFC xB2,F
....................  
....................    // Write the TXND pointer into the registers, given the dataLen given 
....................    WriteReg(ETXNDL, ((WORD_VAL*)&dataLen)->v[0]); 
15C0:  MOVLW  03
15C2:  MOVWF  xB4
15C4:  MOVLW  B1
15C6:  MOVWF  FE9
15C8:  MOVFF  3B4,FEA
15CC:  MOVFF  FEF,3B5
15D0:  MOVLW  06
15D2:  MOVWF  xB6
15D4:  MOVFF  3B5,3B7
15D8:  MOVLB  0
15DA:  CALL   080C
....................    WriteReg(ETXNDH, ((WORD_VAL*)&dataLen)->v[1]); 
15DE:  MOVLW  03
15E0:  MOVLB  3
15E2:  MOVWF  xB4
15E4:  MOVLW  B1
15E6:  MOVWF  xB3
15E8:  MOVLW  01
15EA:  ADDWF  xB3,W
15EC:  MOVWF  FE9
15EE:  MOVLW  00
15F0:  ADDWFC xB4,W
15F2:  MOVWF  FEA
15F4:  MOVFF  FEF,3B5
15F8:  MOVLW  07
15FA:  MOVWF  xB6
15FC:  MOVFF  3B5,3B7
1600:  MOVLB  0
1602:  CALL   080C
.................... #endif 
....................  
....................  
....................    // Set the per-packet control byte and write the Ethernet destination 
....................    // address 
....................    MACPut(0x00);   // Use default control configuration 
1606:  MOVLB  3
1608:  CLRF   xB4
160A:  MOVLB  0
160C:  RCALL  151C
....................     MACPutArray((BYTE*)remote, sizeof(*remote)); 
160E:  MOVFF  3AF,3B6
1612:  MOVFF  3AE,3B5
1616:  MOVLB  3
1618:  CLRF   xB8
161A:  MOVLW  06
161C:  MOVWF  xB7
161E:  MOVLB  0
1620:  RCALL  153A
....................  
....................    // Write our MAC address in the Ethernet source field 
....................    MACPutArray((BYTE*)&AppConfig.MyMACAddr, sizeof(AppConfig.MyMACAddr)); 
1622:  MOVLB  3
1624:  CLRF   xB4
1626:  MOVLW  1C
1628:  MOVFF  3B4,3B6
162C:  MOVWF  xB5
162E:  CLRF   xB8
1630:  MOVLW  06
1632:  MOVWF  xB7
1634:  MOVLB  0
1636:  RCALL  153A
....................  
....................    // Write the appropriate Ethernet Type WORD for the protocol being used 
....................     MACPut(0x08); 
1638:  MOVLW  08
163A:  MOVLB  3
163C:  MOVWF  xB4
163E:  MOVLB  0
1640:  RCALL  151C
....................     MACPut((type == MAC_IP) ? ETHER_IP : ETHER_ARP); 
1642:  MOVLB  3
1644:  MOVF   xB0,F
1646:  BNZ   164C
1648:  MOVLW  00
164A:  BRA    164E
164C:  MOVLW  06
164E:  MOVWF  xB4
1650:  MOVLB  0
1652:  RCALL  151C
.................... } 
1654:  RETLW  00
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACFlush(void) 
....................  * 
....................  * PreCondition:    A packet has been created by calling MACPut() and 
....................  *               MACPutHeader(). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACFlush causes the current TX packet to be sent out on 
....................  *               the Ethernet medium.  The hardware MAC will take control 
....................  *               and handle CRC generation, collision retransmission and 
....................  *               other details. 
....................  * 
....................  * Note:         After transmission completes (MACIsTxReady() returns TRUE), 
....................  *               the packet can be modified and transmitted again by calling 
....................  *               MACFlush() again.  Until MACPutHeader() or MACPut() is 
....................  *               called (in the TX data area), the data in the TX buffer 
....................  *               will not be corrupted. 
....................  *****************************************************************************/ 
.................... void MACFlush(void) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    // Set the packet start and end address pointers 
....................    BankSel(ETXSTL); 
....................    WriteReg(ETXSTL, TxBuffers[CurrentTxBuffer].StartAddress.v[0]); 
....................    WriteReg(ETXSTH, TxBuffers[CurrentTxBuffer].StartAddress.v[1]); 
....................    WriteReg(ETXNDL, TxBuffers[CurrentTxBuffer].EndAddress.v[0]); 
....................    WriteReg(ETXNDH, TxBuffers[CurrentTxBuffer].EndAddress.v[1]); 
....................    LastTXedBuffer = CurrentTxBuffer; 
....................    TxBuffers[CurrentTxBuffer].Flags.bTransmitted = TRUE; 
.................... #endif 
....................  
....................    // Reset transmit logic if a TX Error has previously occured 
....................    // This is a silicon errata workaround 
....................    if(ReadETHReg(EIR).EIRbits.TXERIF) 
1656:  MOVLW  1C
1658:  MOVLB  3
165A:  MOVWF  xB0
165C:  MOVLB  0
165E:  CALL   07CC
1662:  MOVFF  01,39D
1666:  MOVLW  00
1668:  MOVLB  3
166A:  BTFSC  01.1
166C:  MOVLW  01
166E:  XORLW  00
1670:  BZ    1692
....................    { 
....................       BFSReg(ECON1, ECON1_TXRST); 
1672:  MOVLW  1F
1674:  MOVWF  xB8
1676:  MOVLW  80
1678:  MOVWF  xB9
167A:  MOVLB  0
167C:  CALL   0848
....................       BFCReg(ECON1, ECON1_TXRST); 
1680:  MOVLW  1F
1682:  MOVLB  3
1684:  MOVWF  xB5
1686:  MOVLW  80
1688:  MOVWF  xB6
168A:  MOVLB  0
168C:  CALL   082A
1690:  MOVLB  3
....................    } 
....................    BFCReg(EIR, EIR_TXERIF | EIR_TXIF); 
1692:  MOVLW  1C
1694:  MOVWF  xB5
1696:  MOVLW  0A
1698:  MOVWF  xB6
169A:  MOVLB  0
169C:  CALL   082A
....................  
....................    // Start the transmission 
....................    // After transmission completes (MACIsTxReady() returns TRUE), the packet 
....................    // can be modified and transmitted again by calling MACFlush() again. 
....................    // Until MACPutHeader() is called, the data in the TX buffer will not be 
....................    // corrupted. 
....................    BFSReg(ECON1, ECON1_TXRTS); 
16A0:  MOVLW  1F
16A2:  MOVLB  3
16A4:  MOVWF  xB8
16A6:  MOVLW  08
16A8:  MOVWF  xB9
16AA:  MOVLB  0
16AC:  CALL   0848
....................  
....................    // Revision B5 silicon errata workaround 
....................    if(ENCRevID == 0x05) 
16B0:  MOVF   59,W
16B2:  SUBLW  05
16B4:  BTFSS  FD8.2
16B6:  BRA    1878
....................    { 
....................       while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF))); 
16B8:  MOVLW  1C
16BA:  MOVLB  3
16BC:  MOVWF  xB0
16BE:  MOVLB  0
16C0:  CALL   07CC
16C4:  MOVFF  01,39D
16C8:  MOVLB  3
16CA:  MOVF   01,W
16CC:  ANDLW  0A
16CE:  BTFSS  FD8.2
16D0:  BRA    16D6
16D2:  MOVLB  0
16D4:  BRA    16B8
....................       if(ReadETHReg(EIR).EIRbits.TXERIF) 
16D6:  MOVLW  1C
16D8:  MOVWF  xB0
16DA:  MOVLB  0
16DC:  CALL   07CC
16E0:  MOVFF  01,39D
16E4:  MOVLW  00
16E6:  MOVLB  3
16E8:  BTFSC  01.1
16EA:  MOVLW  01
16EC:  XORLW  00
16EE:  BTFSC  FD8.2
16F0:  BRA    187A
....................       { 
....................          WORD_VAL ReadPtrSave; 
....................          WORD_VAL TXEnd; 
....................          TXSTATUS TXStatus; 
....................          BYTE i; 
....................  
....................          // Cancel the previous transmission if it has become stuck set 
....................          BFCReg(ECON1, ECON1_TXRTS); 
16F2:  MOVLW  1F
16F4:  MOVWF  xB5
16F6:  MOVLW  08
16F8:  MOVWF  xB6
16FA:  MOVLB  0
16FC:  CALL   082A
....................  
....................          // Save the current read pointer (controlled by application) 
....................          BankSel(ERDPTL); 
1700:  MOVLB  3
1702:  CLRF   xB4
1704:  CLRF   xB3
1706:  MOVLB  0
1708:  CALL   0866
....................          ReadPtrSave.v[0] = ReadETHReg(ERDPTL).Val; 
170C:  MOVLB  3
170E:  CLRF   xB0
1710:  MOVLB  0
1712:  CALL   07CC
1716:  MOVFF  01,391
....................          ReadPtrSave.v[1] = ReadETHReg(ERDPTH).Val; 
171A:  MOVLW  01
171C:  MOVLB  3
171E:  MOVWF  xB0
1720:  MOVLB  0
1722:  CALL   07CC
1726:  MOVFF  01,392
....................  
....................          // Get the location of the transmit status vector 
....................          TXEnd.v[0] = ReadETHReg(ETXNDL).Val; 
172A:  MOVLW  06
172C:  MOVLB  3
172E:  MOVWF  xB0
1730:  MOVLB  0
1732:  CALL   07CC
1736:  MOVFF  01,393
....................          TXEnd.v[1] = ReadETHReg(ETXNDH).Val; 
173A:  MOVLW  07
173C:  MOVLB  3
173E:  MOVWF  xB0
1740:  MOVLB  0
1742:  CALL   07CC
1746:  MOVFF  01,394
....................          TXEnd.Val++; 
174A:  MOVLB  3
174C:  INCF   x93,F
174E:  BTFSC  FD8.2
1750:  INCF   x94,F
....................  
....................          // Read the transmit status vector 
....................          WriteReg(ERDPTL, TXEnd.v[0]); 
1752:  CLRF   xB6
1754:  MOVFF  393,3B7
1758:  MOVLB  0
175A:  CALL   080C
....................          WriteReg(ERDPTH, TXEnd.v[1]); 
175E:  MOVLW  01
1760:  MOVLB  3
1762:  MOVWF  xB6
1764:  MOVFF  394,3B7
1768:  MOVLB  0
176A:  CALL   080C
....................          MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus)); 
176E:  MOVLW  03
1770:  MOVLB  3
1772:  MOVWF  x9E
1774:  MOVLW  95
1776:  MOVFF  39E,3A0
177A:  MOVWF  x9F
177C:  CLRF   xA2
177E:  MOVLW  07
1780:  MOVWF  xA1
1782:  MOVLB  0
1784:  RCALL  10E2
....................  
....................          // Implement retransmission if a late collision occured (this can 
....................          // happen on B5 when certain link pulses arrive at the same time 
....................          // as the transmission) 
....................          for(i = 0; i < 16; i++) 
1786:  MOVLB  3
1788:  CLRF   x9C
178A:  MOVF   x9C,W
178C:  SUBLW  0F
178E:  BNC   185C
....................          { 
....................             if(ReadETHReg(EIR).EIRbits.TXERIF && TXStatus.bits.LateCollision) 
1790:  MOVLW  1C
1792:  MOVWF  xB0
1794:  MOVLB  0
1796:  CALL   07CC
179A:  MOVFF  01,39D
179E:  MOVLW  00
17A0:  MOVLB  3
17A2:  BTFSC  01.1
17A4:  MOVLW  01
17A6:  XORLW  00
17A8:  BZ    1852
17AA:  BTFSS  x98.5
17AC:  BRA    1852
....................             { 
....................                // Reset the TX logic 
....................                BFSReg(ECON1, ECON1_TXRST); 
17AE:  MOVLW  1F
17B0:  MOVWF  xB8
17B2:  MOVLW  80
17B4:  MOVWF  xB9
17B6:  MOVLB  0
17B8:  CALL   0848
....................                BFCReg(ECON1, ECON1_TXRST); 
17BC:  MOVLW  1F
17BE:  MOVLB  3
17C0:  MOVWF  xB5
17C2:  MOVLW  80
17C4:  MOVWF  xB6
17C6:  MOVLB  0
17C8:  CALL   082A
....................                BFCReg(EIR, EIR_TXERIF | EIR_TXIF); 
17CC:  MOVLW  1C
17CE:  MOVLB  3
17D0:  MOVWF  xB5
17D2:  MOVLW  0A
17D4:  MOVWF  xB6
17D6:  MOVLB  0
17D8:  CALL   082A
....................  
....................                // Transmit the packet again 
....................                BFSReg(ECON1, ECON1_TXRTS); 
17DC:  MOVLW  1F
17DE:  MOVLB  3
17E0:  MOVWF  xB8
17E2:  MOVLW  08
17E4:  MOVWF  xB9
17E6:  MOVLB  0
17E8:  CALL   0848
....................                while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF))); 
17EC:  MOVLW  1C
17EE:  MOVLB  3
17F0:  MOVWF  xB0
17F2:  MOVLB  0
17F4:  CALL   07CC
17F8:  MOVFF  01,39D
17FC:  MOVLB  3
17FE:  MOVF   01,W
1800:  ANDLW  0A
1802:  BTFSS  FD8.2
1804:  BRA    180A
1806:  MOVLB  0
1808:  BRA    17EC
....................  
....................                // Cancel the previous transmission if it has become stuck set 
....................                BFCReg(ECON1, ECON1_TXRTS); 
180A:  MOVLW  1F
180C:  MOVWF  xB5
180E:  MOVLW  08
1810:  MOVWF  xB6
1812:  MOVLB  0
1814:  CALL   082A
....................  
....................                // Read transmit status vector 
....................                WriteReg(ERDPTL, TXEnd.v[0]); 
1818:  MOVLB  3
181A:  CLRF   xB6
181C:  MOVFF  393,3B7
1820:  MOVLB  0
1822:  CALL   080C
....................                WriteReg(ERDPTH, TXEnd.v[1]); 
1826:  MOVLW  01
1828:  MOVLB  3
182A:  MOVWF  xB6
182C:  MOVFF  394,3B7
1830:  MOVLB  0
1832:  CALL   080C
....................                MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus)); 
1836:  MOVLW  03
1838:  MOVLB  3
183A:  MOVWF  x9E
183C:  MOVLW  95
183E:  MOVFF  39E,3A0
1842:  MOVWF  x9F
1844:  CLRF   xA2
1846:  MOVLW  07
1848:  MOVWF  xA1
184A:  MOVLB  0
184C:  RCALL  10E2
....................             } 
....................             else 
184E:  BRA    1856
1850:  MOVLB  3
....................             { 
....................                break; 
1852:  BRA    185C
1854:  MOVLB  0
....................             } 
....................          } 
1856:  MOVLB  3
1858:  INCF   x9C,F
185A:  BRA    178A
....................  
....................          // Restore the current read pointer 
....................          WriteReg(ERDPTL, ReadPtrSave.v[0]); 
185C:  CLRF   xB6
185E:  MOVFF  391,3B7
1862:  MOVLB  0
1864:  CALL   080C
....................          WriteReg(ERDPTH, ReadPtrSave.v[1]); 
1868:  MOVLW  01
186A:  MOVLB  3
186C:  MOVWF  xB6
186E:  MOVFF  392,3B7
1872:  MOVLB  0
1874:  CALL   080C
1878:  MOVLB  3
....................       } 
....................    } 
.................... } 
187A:  MOVLB  0
187C:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetRxBuffer(WORD offset) 
....................  * 
....................  * PreCondition:    A packet has been obtained by calling MACGetHeader() and 
....................  *               getting a TRUE result. 
....................  * 
....................  * Input:           offset: WORD specifying how many bytes beyond the Ethernet 
....................  *                     header's type field to relocate the SPI read and 
....................  *                     write pointers. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI read and write pointers are updated.  All calls to 
....................  *               MACGet(), MACPut(), MACGetArray(), and MACPutArray(), 
....................  *               and various other functions will use these new values. 
....................  * 
....................  * Note:         RXSTOP must be statically defined as being > RXSTART for 
....................  *               this function to work correctly.  In other words, do not 
....................  *               define an RX buffer which spans the 0x1FFF->0x0000 memory 
....................  *               boundary. 
....................  *****************************************************************************/ 
.................... void MACSetRxBuffer(WORD offset) 
.................... { 
....................    WORD_VAL ReadPT; 
....................  
....................    // Determine the address of the beginning of the entire packet 
....................    // and adjust the address to the desired location 
....................    ReadPT.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
1BA6:  MOVLW  14
1BA8:  ADDWF  56,W
1BAA:  MOVLB  3
1BAC:  MOVWF  x3E
1BAE:  MOVLW  00
1BB0:  ADDWFC 57,W
1BB2:  MOVWF  x3F
1BB4:  MOVF   x3A,W
1BB6:  ADDWF  x3E,W
1BB8:  MOVWF  x3C
1BBA:  MOVF   x3B,W
1BBC:  ADDWFC x3F,W
1BBE:  MOVWF  x3D
....................  
....................    // Since the receive buffer is circular, adjust if a wraparound is needed 
....................    if ( ReadPT.Val > RXSTOP ) 
1BC0:  MOVF   x3D,W
1BC2:  SUBLW  1A
1BC4:  BC    1BD8
1BC6:  XORLW  FF
1BC8:  BNZ   1BD0
1BCA:  MOVF   x3C,W
1BCC:  SUBLW  F7
1BCE:  BC    1BD8
....................       ReadPT.Val -= RXSIZE; 
1BD0:  MOVLW  F8
1BD2:  SUBWF  x3C,F
1BD4:  MOVLW  1B
1BD6:  SUBWFB x3D,F
....................  
....................    // Set the SPI read and write pointers to the new calculated value 
....................    BankSel(ERDPTL); 
1BD8:  CLRF   xB4
1BDA:  CLRF   xB3
1BDC:  MOVLB  0
1BDE:  CALL   0866
....................    WriteReg(ERDPTL, ReadPT.v[0]); 
1BE2:  MOVLB  3
1BE4:  CLRF   xB6
1BE6:  MOVFF  33C,3B7
1BEA:  MOVLB  0
1BEC:  CALL   080C
....................    WriteReg(ERDPTH, ReadPT.v[1]); 
1BF0:  MOVLW  01
1BF2:  MOVLB  3
1BF4:  MOVWF  xB6
1BF6:  MOVFF  33D,3B7
1BFA:  MOVLB  0
1BFC:  CALL   080C
....................    WriteReg(EWRPTL, ReadPT.v[0]); 
1C00:  MOVLW  02
1C02:  MOVLB  3
1C04:  MOVWF  xB6
1C06:  MOVFF  33C,3B7
1C0A:  MOVLB  0
1C0C:  CALL   080C
....................    WriteReg(EWRPTH, ReadPT.v[1]); 
1C10:  MOVLW  03
1C12:  MOVLB  3
1C14:  MOVWF  xB6
1C16:  MOVFF  33D,3B7
1C1A:  MOVLB  0
1C1C:  CALL   080C
.................... } 
1C20:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetTxBuffer(BUFFER buffer, WORD offset) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           buffer: BYTE specifying which transmit buffer to seek 
....................  *                     within.  If MAC_TX_BUFFER_COUNT <= 1, this 
....................  *                     parameter is not used. 
....................  *               offset: WORD specifying how many bytes beyond the Ethernet 
....................  *                     header's type field to relocate the SPI read and 
....................  *                     write pointers. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI read and write pointers are updated.  All calls to 
....................  *               MACGet(), MACPut(), MACGetArray(), and MACPutArray(), 
....................  *               and various other functions will use these new values. 
....................  * 
....................  * Note:         None 
....................  *****************************************************************************/ 
.................... void MACSetTxBuffer(BUFFER buffer, WORD offset) 
.................... { 
....................     CurrentTxBuffer = buffer; 
*
1472:  MOVFF  3AA,4F
....................  
....................    // Calculate the proper address.  Since the TX memory area is not circular, 
....................    // no wrapparound checks are necessary. +1 adjustment is needed because of 
....................    // the per packet control byte which preceeds the packet in the TX memory 
....................    // area. 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    offset += TxBuffers[buffer].StartAddress.Val + 1 + sizeof(ETHER_HEADER); 
.................... #else 
....................    offset += TXSTART + 1 + sizeof(ETHER_HEADER); 
1476:  MOVLW  07
1478:  MOVLB  3
147A:  ADDWF  xAB,F
147C:  MOVLW  1C
147E:  ADDWFC xAC,F
.................... #endif 
....................  
....................    // Set the SPI read and write pointers to the new calculated value 
....................    BankSel(EWRPTL); 
1480:  CLRF   xB4
1482:  MOVLW  02
1484:  MOVWF  xB3
1486:  MOVLB  0
1488:  CALL   0866
....................    WriteReg(ERDPTL, ((WORD_VAL*)&offset)->v[0]); 
148C:  MOVLW  03
148E:  MOVLB  3
1490:  MOVWF  xAE
1492:  MOVLW  AB
1494:  MOVWF  FE9
1496:  MOVFF  3AE,FEA
149A:  MOVFF  FEF,3AF
149E:  CLRF   xB6
14A0:  MOVFF  3AF,3B7
14A4:  MOVLB  0
14A6:  CALL   080C
....................    WriteReg(ERDPTH, ((WORD_VAL*)&offset)->v[1]); 
14AA:  MOVLW  03
14AC:  MOVLB  3
14AE:  MOVWF  xAE
14B0:  MOVLW  AB
14B2:  MOVWF  xAD
14B4:  MOVLW  01
14B6:  ADDWF  xAD,W
14B8:  MOVWF  FE9
14BA:  MOVLW  00
14BC:  ADDWFC xAE,W
14BE:  MOVWF  FEA
14C0:  MOVFF  FEF,3AF
14C4:  MOVLW  01
14C6:  MOVWF  xB6
14C8:  MOVFF  3AF,3B7
14CC:  MOVLB  0
14CE:  CALL   080C
....................    WriteReg(EWRPTL, ((WORD_VAL*)&offset)->v[0]); 
14D2:  MOVLW  03
14D4:  MOVLB  3
14D6:  MOVWF  xAE
14D8:  MOVLW  AB
14DA:  MOVWF  FE9
14DC:  MOVFF  3AE,FEA
14E0:  MOVFF  FEF,3AF
14E4:  MOVLW  02
14E6:  MOVWF  xB6
14E8:  MOVFF  3AF,3B7
14EC:  MOVLB  0
14EE:  CALL   080C
....................    WriteReg(EWRPTH, ((WORD_VAL*)&offset)->v[1]); 
14F2:  MOVLW  03
14F4:  MOVLB  3
14F6:  MOVWF  xAE
14F8:  MOVLW  AB
14FA:  MOVWF  xAD
14FC:  MOVLW  01
14FE:  ADDWF  xAD,W
1500:  MOVWF  FE9
1502:  MOVLW  00
1504:  ADDWFC xAE,W
1506:  MOVWF  FEA
1508:  MOVFF  FEF,3AF
150C:  MOVLW  03
150E:  MOVWF  xB6
1510:  MOVFF  3AF,3B7
1514:  MOVLB  0
1516:  CALL   080C
.................... } 
151A:  RETLW  00
....................  
....................  
.................... #if defined(MCHP_MAC) 
.................... // MACCalcRxChecksum() and MACCalcTxChecksum() use the DMA module to calculate 
.................... // checksums.  These two functions have been tested. 
.................... /****************************************************************************** 
....................  * Function:        WORD MACCalcRxChecksum(WORD offset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           offset   - Number of bytes beyond the beginning of the 
....................  *                     Ethernet data (first byte after the type field) 
....................  *                     where the checksum should begin 
....................  *               len      - Total number of bytes to include in the checksum 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself using the hardware DMA module 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACCalcRxChecksum(WORD offset, WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    // Add the offset requested by firmware plus the Ethernet header 
....................    temp.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
1A9E:  MOVLW  14
1AA0:  ADDWF  56,W
1AA2:  MOVLB  3
1AA4:  MOVWF  x67
1AA6:  MOVLW  00
1AA8:  ADDWFC 57,W
1AAA:  MOVWF  x68
1AAC:  MOVF   x61,W
1AAE:  ADDWF  x67,W
1AB0:  MOVWF  x65
1AB2:  MOVF   x62,W
1AB4:  ADDWFC x68,W
1AB6:  MOVWF  x66
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
1AB8:  MOVF   x66,W
1ABA:  SUBLW  1A
1ABC:  BC    1AD0
1ABE:  XORLW  FF
1AC0:  BNZ   1AC8
1AC2:  MOVF   x65,W
1AC4:  SUBLW  F7
1AC6:  BC    1AD0
....................    { 
....................       temp.Val -= RXSIZE; 
1AC8:  MOVLW  F8
1ACA:  SUBWF  x65,F
1ACC:  MOVLW  1B
1ACE:  SUBWFB x66,F
....................    } 
....................  
....................    // Program the start address of the DMA 
....................    BankSel(EDMASTL); 
1AD0:  CLRF   xB4
1AD2:  MOVLW  10
1AD4:  MOVWF  xB3
1AD6:  MOVLB  0
1AD8:  CALL   0866
....................    WriteReg(EDMASTL, temp.v[0]); 
1ADC:  MOVLW  10
1ADE:  MOVLB  3
1AE0:  MOVWF  xB6
1AE2:  MOVFF  365,3B7
1AE6:  MOVLB  0
1AE8:  CALL   080C
....................    WriteReg(EDMASTH, temp.v[1]); 
1AEC:  MOVLW  11
1AEE:  MOVLB  3
1AF0:  MOVWF  xB6
1AF2:  MOVFF  366,3B7
1AF6:  MOVLB  0
1AF8:  CALL   080C
....................  
....................    // Calculate the end address, given the start address and len 
....................    temp.Val += len-1; 
1AFC:  MOVLW  01
1AFE:  MOVLB  3
1B00:  SUBWF  x63,W
1B02:  MOVWF  00
1B04:  MOVLW  00
1B06:  SUBWFB x64,W
1B08:  MOVWF  03
1B0A:  MOVF   00,W
1B0C:  ADDWF  x65,F
1B0E:  MOVF   03,W
1B10:  ADDWFC x66,F
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
1B12:  MOVF   x66,W
1B14:  SUBLW  1A
1B16:  BC    1B2A
1B18:  XORLW  FF
1B1A:  BNZ   1B22
1B1C:  MOVF   x65,W
1B1E:  SUBLW  F7
1B20:  BC    1B2A
....................    { 
....................       temp.Val -= RXSIZE; 
1B22:  MOVLW  F8
1B24:  SUBWF  x65,F
1B26:  MOVLW  1B
1B28:  SUBWFB x66,F
....................    } 
....................  
....................    // Program the end address of the DMA 
....................    WriteReg(EDMANDL, temp.v[0]); 
1B2A:  MOVLW  12
1B2C:  MOVWF  xB6
1B2E:  MOVFF  365,3B7
1B32:  MOVLB  0
1B34:  CALL   080C
....................    WriteReg(EDMANDH, temp.v[1]); 
1B38:  MOVLW  13
1B3A:  MOVLB  3
1B3C:  MOVWF  xB6
1B3E:  MOVFF  366,3B7
1B42:  MOVLB  0
1B44:  CALL   080C
....................  
....................    // Do the checksum calculation 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
1B48:  MOVLW  1F
1B4A:  MOVLB  3
1B4C:  MOVWF  xB8
1B4E:  MOVLW  30
1B50:  MOVWF  xB9
1B52:  MOVLB  0
1B54:  CALL   0848
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
1B58:  MOVLW  1F
1B5A:  MOVLB  3
1B5C:  MOVWF  xB0
1B5E:  MOVLB  0
1B60:  CALL   07CC
1B64:  MOVFF  01,367
1B68:  MOVLW  00
1B6A:  MOVLB  3
1B6C:  BTFSC  01.5
1B6E:  MOVLW  01
1B70:  XORLW  00
1B72:  BTFSC  FD8.2
1B74:  BRA    1B7A
1B76:  MOVLB  0
1B78:  BRA    1B58
....................  
....................    // Swap endianness and return 
....................    temp.v[1] = ReadETHReg(EDMACSL).Val; 
1B7A:  MOVLW  16
1B7C:  MOVWF  xB0
1B7E:  MOVLB  0
1B80:  CALL   07CC
1B84:  MOVFF  01,366
....................    temp.v[0] = ReadETHReg(EDMACSH).Val; 
1B88:  MOVLW  17
1B8A:  MOVLB  3
1B8C:  MOVWF  xB0
1B8E:  MOVLB  0
1B90:  CALL   07CC
1B94:  MOVFF  01,365
....................    return temp.Val; 
1B98:  MOVLB  3
1B9A:  MOVFF  365,01
1B9E:  MOVFF  366,02
.................... } 
1BA2:  MOVLB  0
1BA4:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACCalcTxChecksum(WORD offset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           offset   - Number of bytes beyond the beginning of the 
....................  *                     Ethernet data (first byte after the type field) 
....................  *                     where the checksum should begin 
....................  *               len      - Total number of bytes to include in the checksum 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself using the hardware DMA module 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACCalcTxChecksum(WORD offset, WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    // Program the start address of the DMA, after adjusting for the Ethernet 
....................    // header 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    temp.Val = TxBuffers[CurrentTxBuffer].StartAddress.Val + sizeof(ETHER_HEADER) 
....................             + offset + 1;   // +1 needed to account for per packet control byte 
.................... #else 
....................    temp.Val = TXSTART + sizeof(ETHER_HEADER) 
....................             + offset + 1;   // +1 needed to account for per packet control byte 
*
26F6:  MOVLW  06
26F8:  MOVLB  3
26FA:  ADDWF  xAA,W
26FC:  MOVWF  xB0
26FE:  MOVLW  1C
2700:  ADDWFC xAB,W
2702:  MOVWF  xB1
2704:  MOVLW  01
2706:  ADDWF  xB0,W
2708:  MOVWF  xAE
270A:  MOVLW  00
270C:  ADDWFC xB1,W
270E:  MOVWF  xAF
.................... #endif 
....................    BankSel(EDMASTL); 
2710:  CLRF   xB4
2712:  MOVLW  10
2714:  MOVWF  xB3
2716:  MOVLB  0
2718:  CALL   0866
....................    WriteReg(EDMASTL, temp.v[0]); 
271C:  MOVLW  10
271E:  MOVLB  3
2720:  MOVWF  xB6
2722:  MOVFF  3AE,3B7
2726:  MOVLB  0
2728:  CALL   080C
....................    WriteReg(EDMASTH, temp.v[1]); 
272C:  MOVLW  11
272E:  MOVLB  3
2730:  MOVWF  xB6
2732:  MOVFF  3AF,3B7
2736:  MOVLB  0
2738:  CALL   080C
....................  
....................    // Program the end address of the DMA. 
....................    temp.Val += len-1; 
273C:  MOVLW  01
273E:  MOVLB  3
2740:  SUBWF  xAC,W
2742:  MOVWF  00
2744:  MOVLW  00
2746:  SUBWFB xAD,W
2748:  MOVWF  03
274A:  MOVF   00,W
274C:  ADDWF  xAE,F
274E:  MOVF   03,W
2750:  ADDWFC xAF,F
....................    WriteReg(EDMANDL, temp.v[0]); 
2752:  MOVLW  12
2754:  MOVWF  xB6
2756:  MOVFF  3AE,3B7
275A:  MOVLB  0
275C:  CALL   080C
....................    WriteReg(EDMANDH, temp.v[1]); 
2760:  MOVLW  13
2762:  MOVLB  3
2764:  MOVWF  xB6
2766:  MOVFF  3AF,3B7
276A:  MOVLB  0
276C:  CALL   080C
....................  
....................    // Do the checksum calculation 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
2770:  MOVLW  1F
2772:  MOVLB  3
2774:  MOVWF  xB8
2776:  MOVLW  30
2778:  MOVWF  xB9
277A:  MOVLB  0
277C:  CALL   0848
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
2780:  MOVLW  1F
2782:  MOVLB  3
2784:  MOVWF  xB0
2786:  MOVLB  0
2788:  CALL   07CC
278C:  MOVFF  01,3B0
2790:  MOVLW  00
2792:  MOVLB  3
2794:  BTFSC  01.5
2796:  MOVLW  01
2798:  XORLW  00
279A:  BTFSC  FD8.2
279C:  BRA    27A2
279E:  MOVLB  0
27A0:  BRA    2780
....................  
....................    // Swap endianness and return 
....................    temp.v[1] = ReadETHReg(EDMACSL).Val; 
27A2:  MOVLW  16
27A4:  MOVWF  xB0
27A6:  MOVLB  0
27A8:  CALL   07CC
27AC:  MOVFF  01,3AF
....................    temp.v[0] = ReadETHReg(EDMACSH).Val; 
27B0:  MOVLW  17
27B2:  MOVLB  3
27B4:  MOVWF  xB0
27B6:  MOVLB  0
27B8:  CALL   07CC
27BC:  MOVFF  01,3AE
....................    return temp.Val; 
27C0:  MOVLB  3
27C2:  MOVFF  3AE,01
27C6:  MOVFF  3AF,02
.................... } 
27CA:  MOVLB  0
27CC:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD CalcIPBufferChecksum(WORD len) 
....................  * 
....................  * PreCondition:    Read buffer pointer set to starting of checksum data 
....................  * 
....................  * Input:           len: Total number of bytes to calculate the checksum over. 
....................  *                   The first byte included in the checksum is the byte 
....................  *                   pointed to by ERDPT, which is updated by calls to 
....................  *                   MACGet(), MACSetRxBuffer(), MACSetTxBuffer(), etc. 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself.  The ENC28J60 has a hardware DMA module 
....................  *               which can calculate the checksum faster than software, so 
....................  *               this function replaces the CaclIPBufferChecksum() function 
....................  *               defined in the helpers.c file.  Through the use of 
....................  *               preprocessor defines, this replacement is automatic. 
....................  * 
....................  * Note:            This function works either in the RX buffer area or the TX 
....................  *               buffer area.  No validation is done on the len parameter. 
....................  *****************************************************************************/ 
.................... WORD CalcIPBufferChecksum(WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    // Take care of special cases which the DMA cannot be used for 
....................    if(len == 0u) 
*
1EFC:  MOVLB  3
1EFE:  MOVF   x91,F
1F00:  BNZ   1F10
1F02:  MOVF   x92,F
1F04:  BNZ   1F10
....................    { 
....................       return 0xFFFF; 
1F06:  MOVLW  FF
1F08:  MOVWF  01
1F0A:  MOVWF  02
1F0C:  BRA    2050
....................    } 
....................    else if(len == 1u) 
1F0E:  BRA    1F3E
1F10:  DECFSZ x91,W
1F12:  BRA    1F3E
1F14:  MOVF   x92,F
1F16:  BNZ   1F3E
....................    { 
....................       return ~(((WORD)MACGet())<<8); 
1F18:  MOVLB  0
1F1A:  RCALL  1ED0
1F1C:  MOVLB  3
1F1E:  CLRF   x96
1F20:  MOVFF  01,395
1F24:  MOVFF  01,03
1F28:  MOVLW  00
1F2A:  CLRF   00
1F2C:  DECF   00,F
1F2E:  XORWF  00,F
1F30:  MOVLW  FF
1F32:  XORWF  03,F
1F34:  MOVFF  00,01
1F38:  MOVFF  03,02
1F3C:  BRA    2050
....................    } 
....................  
....................  
....................    // Set the DMA starting address to the SPI read pointer value 
....................    BankSel(ERDPTL); 
1F3E:  CLRF   xB4
1F40:  CLRF   xB3
1F42:  MOVLB  0
1F44:  CALL   0866
....................    temp.v[0] = ReadETHReg(ERDPTL).Val; 
1F48:  MOVLB  3
1F4A:  CLRF   xB0
1F4C:  MOVLB  0
1F4E:  CALL   07CC
1F52:  MOVFF  01,393
....................    temp.v[1] = ReadETHReg(ERDPTH).Val; 
1F56:  MOVLW  01
1F58:  MOVLB  3
1F5A:  MOVWF  xB0
1F5C:  MOVLB  0
1F5E:  CALL   07CC
1F62:  MOVFF  01,394
....................    WriteReg(EDMASTL, temp.v[0]); 
1F66:  MOVLW  10
1F68:  MOVLB  3
1F6A:  MOVWF  xB6
1F6C:  MOVFF  393,3B7
1F70:  MOVLB  0
1F72:  CALL   080C
....................    WriteReg(EDMASTH, temp.v[1]); 
1F76:  MOVLW  11
1F78:  MOVLB  3
1F7A:  MOVWF  xB6
1F7C:  MOVFF  394,3B7
1F80:  MOVLB  0
1F82:  CALL   080C
....................  
....................    // See if we are calculating a checksum within the RX buffer (where 
....................    // wrapping rules apply) or TX/unused area (where wrapping rules are 
....................    // not applied) 
.................... #if RXSTART == 0 
....................    if(temp.Val <= RXSTOP) 
1F86:  MOVLB  3
1F88:  MOVF   x94,W
1F8A:  SUBLW  1B
1F8C:  BNC   1FC4
1F8E:  BNZ   1F96
1F90:  MOVF   x93,W
1F92:  SUBLW  F7
1F94:  BNC   1FC4
.................... #else 
....................    if(temp.Val >= RXSTART && temp.Val <= RXSTOP) 
.................... #endif 
....................    { 
....................       // Calculate the DMA ending address given the starting address and len 
....................       // parameter.  The DMA will follow the receive buffer wrapping boundary. 
....................       temp.Val += len-1; 
1F96:  MOVLW  01
1F98:  SUBWF  x91,W
1F9A:  MOVWF  00
1F9C:  MOVLW  00
1F9E:  SUBWFB x92,W
1FA0:  MOVWF  03
1FA2:  MOVF   00,W
1FA4:  ADDWF  x93,F
1FA6:  MOVF   03,W
1FA8:  ADDWFC x94,F
....................       if(temp.Val > RXSTOP) 
1FAA:  MOVF   x94,W
1FAC:  SUBLW  1A
1FAE:  BC    1FC2
1FB0:  XORLW  FF
1FB2:  BNZ   1FBA
1FB4:  MOVF   x93,W
1FB6:  SUBLW  F7
1FB8:  BC    1FC2
....................       { 
....................          temp.Val -= RXSIZE; 
1FBA:  MOVLW  F8
1FBC:  SUBWF  x93,F
1FBE:  MOVLW  1B
1FC0:  SUBWFB x94,F
....................       } 
....................    } 
....................    else 
1FC2:  BRA    1FD8
....................    { 
....................       temp.Val += len-1; 
1FC4:  MOVLW  01
1FC6:  SUBWF  x91,W
1FC8:  MOVWF  00
1FCA:  MOVLW  00
1FCC:  SUBWFB x92,W
1FCE:  MOVWF  03
1FD0:  MOVF   00,W
1FD2:  ADDWF  x93,F
1FD4:  MOVF   03,W
1FD6:  ADDWFC x94,F
....................    } 
....................  
....................    // Write the DMA end address 
....................    WriteReg(EDMANDL, temp.v[0]); 
1FD8:  MOVLW  12
1FDA:  MOVWF  xB6
1FDC:  MOVFF  393,3B7
1FE0:  MOVLB  0
1FE2:  CALL   080C
....................    WriteReg(EDMANDH, temp.v[1]); 
1FE6:  MOVLW  13
1FE8:  MOVLB  3
1FEA:  MOVWF  xB6
1FEC:  MOVFF  394,3B7
1FF0:  MOVLB  0
1FF2:  CALL   080C
....................  
....................    // Begin the DMA checksum calculation and wait until it is finished 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
1FF6:  MOVLW  1F
1FF8:  MOVLB  3
1FFA:  MOVWF  xB8
1FFC:  MOVLW  30
1FFE:  MOVWF  xB9
2000:  MOVLB  0
2002:  CALL   0848
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
2006:  MOVLW  1F
2008:  MOVLB  3
200A:  MOVWF  xB0
200C:  MOVLB  0
200E:  CALL   07CC
2012:  MOVFF  01,395
2016:  MOVLW  00
2018:  MOVLB  3
201A:  BTFSC  01.5
201C:  MOVLW  01
201E:  XORLW  00
2020:  BTFSC  FD8.2
2022:  BRA    2028
2024:  MOVLB  0
2026:  BRA    2006
....................  
....................    // Return the resulting good stuff 
....................    temp.v[0] = ReadETHReg(EDMACSL).Val; 
2028:  MOVLW  16
202A:  MOVWF  xB0
202C:  MOVLB  0
202E:  CALL   07CC
2032:  MOVFF  01,393
....................    temp.v[1] = ReadETHReg(EDMACSH).Val; 
2036:  MOVLW  17
2038:  MOVLB  3
203A:  MOVWF  xB0
203C:  MOVLB  0
203E:  CALL   07CC
2042:  MOVFF  01,394
....................    return temp.Val; 
2046:  MOVLB  3
2048:  MOVFF  393,01
204C:  MOVFF  394,02
.................... } 
2050:  MOVLB  0
2052:  RETLW  00
.................... #endif   // End of MCHP_MAC specific code 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           RxOffset: Offset in the RX buffer (0=first byte of 
....................  *                        destination MAC address) to copy from. 
....................  *               TxOffset: Offset in the TX buffer (0=first byte of 
....................  *                       destination MAC address) to copy to. 
....................  *               len:     Number of bytes to copy 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        If the TX logic is transmitting a packet (ECON1.TXRTS is 
....................  *               set), the hardware will wait until it is finished.  Then, 
....................  *               the DMA module will copy the data from the receive buffer 
....................  *               to the transmit buffer. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... // Remove this line if your application needs to use this 
.................... // function.  This code has NOT been tested. 
.................... #if 0 
.................... void MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    temp.Val = CurrentPacketLocation.Val + RxOffset + sizeof(ENC_PREAMBLE); 
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
....................       temp.Val -= RXSIZE; 
....................  
....................    BankSel(EDMASTL); 
....................    WriteReg(EDMASTL, temp.v[0]); 
....................    WriteReg(EDMASTH, temp.v[1]); 
....................  
....................    temp.Val += len-1; 
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
....................       temp.Val -= RXSIZE; 
....................  
....................    WriteReg(EDMANDL, temp.v[0]); 
....................    WriteReg(EDMANDH, temp.v[1]); 
....................  
....................    TxOffset += TXSTART+1; 
....................    WriteReg(EDMADSTL, ((WORD_VAL*)&TxOffset)->v[0]); 
....................    WriteReg(EDMADSTH, ((WORD_VAL*)&TxOffset)->v[1]); 
....................  
....................    // Do the DMA Copy.  The DMA module will wait for TXRTS to become clear 
....................    // before starting the copy. 
....................    BFCReg(ECON1, ECON1_CSUMEN); 
....................    BFSReg(ECON1, ECON1_DMAST); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
.................... } 
.................... #endif 
....................  
....................  
.................... #if defined(MAC_FILTER_BROADCASTS) 
.................... // NOTE: This code has NOT been tested.  See StackTsk.h's explanation 
.................... // of MAC_FILTER_BROADCASTS. 
.................... /****************************************************************************** 
....................  * Function:        void MACSetPMFilter(BYTE *Pattern, 
....................  *                              BYTE *PatternMask, 
....................  *                              WORD PatternOffset) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                MACIsTxReady() must return TRUE 
....................  * 
....................  * Input:           *Pattern: Pointer to an intial pattern to compare against 
....................  *               *PatternMask: Pointer to an 8 byte pattern mask which 
....................  *                          defines which bytes of the pattern are 
....................  *                          important.  At least one bit must be set. 
....................  *               PatternOffset: Offset from the beginning of the Ethernet 
....................  *                           frame (1st byte of destination address), to 
....................  *                           begin comparing with the given pattern. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Contents of the TX buffer space are overwritten 
....................  * 
....................  * Overview:        MACSetPMFilter sets the hardware receive filters for: 
....................  *               CRC AND (Unicast OR Pattern Match).  As a result, only a 
....................  *               subset of the broadcast packets which are normally 
....................  *               received will be received. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACSetPMFilter(BYTE *Pattern, 
....................                BYTE *PatternMask, 
....................                WORD PatternOffset) 
.................... { 
....................    WORD_VAL i; 
....................    BYTE *MaskPtr; 
....................    BYTE UnmaskedPatternLen; 
....................  
....................    // Set the SPI write pointer and DMA startting address to the beginning of 
....................    // the transmit buffer 
....................    BankSel(EWRPTL); 
....................    WriteReg(EWRPTL, LOW(TXSTART)); 
....................    WriteReg(EWRPTH, HIGH(TXSTART)); 
....................    WriteReg(EDMASTL, LOW(TXSTART)); 
....................    WriteReg(EDMASTH, HIGH(TXSTART)); 
....................  
....................    // Fill the transmit buffer with the pattern to match against.  Only the 
....................    // bytes which have a mask bit of 1 are written into the buffer and will 
....................    // subsequently be used for checksum computation. 
....................    MaskPtr = PatternMask; 
....................    for(i.Val = 0x0100; i.v[0] < 64; i.v[0]++) 
....................    { 
....................       if( *MaskPtr & i.v[1] ) 
....................       { 
....................          MACPut(*Pattern); 
....................          UnmaskedPatternLen++; 
....................       } 
....................       Pattern++; 
....................  
....................       i.v[1] <<= 1; 
....................       if( i.v[1] == 0u ) 
....................       { 
....................          i.v[1] = 0x01; 
....................          MaskPtr++; 
....................       } 
....................    } 
....................  
....................    // Calculate and set the DMA end address 
....................    i.Val = TXSTART + (WORD)UnmaskedPatternLen - 1; 
....................    WriteReg(EDMANDL, i.v[0]); 
....................    WriteReg(EDMANDH, i.v[1]); 
....................  
....................    // Calculate the checksum on the given pattern using the DMA module 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
....................    // Make certain that the PM filter isn't enabled while it is 
....................    // being reconfigured. 
....................    BankSel(ERXFCON); 
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN); 
....................  
....................    // Get the calculated DMA checksum and store it in the PM 
....................    // checksum registers 
....................    i.v[0] == ReadETHReg(EDMACSL).Val; 
....................    i.v[1] == ReadETHReg(EDMACSH).Val; 
....................    WriteReg(EPMCSL, i.v[0]); 
....................    WriteReg(EPMCSH, i.v[0]); 
....................  
....................    // Set the Pattern Match offset and 8 byte mask 
....................    WriteReg(EPMOL, ((WORD_VAL*)&PatternOffset)->v[0]); 
....................    WriteReg(EPMOH, ((WORD_VAL*)&PatternOffset)->v[1]); 
....................    for(i.Val = EPMM0; i.Val <= EPMM7 ; i.Val++) 
....................    { 
....................       WriteReg(i.Val, *PatternMask++); 
....................    } 
....................  
....................    // Begin using the new Pattern Match filter instead of the 
....................    // broadcast filter 
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_PMEN); 
.................... }//end MACSetPMFilter 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACDisablePMFilter(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACDisablePMFilter disables the Pattern Match receive 
....................  *               filter (if enabled) and returns to the default filter 
....................  *               configuration of: CRC AND (Unicast OR Broadcast). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACDisablePMFilter(void) 
.................... { 
....................    BankSel(ERXFCON); 
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN); 
....................    return; 
.................... }//end MACDisablePMFilter 
.................... #endif // end of MAC_FILTER_BROADCASTS specific code 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BYTE MACGet() 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Byte read from the ENC28J60's RAM 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACGet returns the byte pointed to by ERDPT and 
....................  *               increments ERDPT so MACGet() can be called again.  The 
....................  *               increment will follow the receive buffer wrapping boundary. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BYTE MACGet() 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = RBM; 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = 0;            // Send a dummy byte to receive the register 
....................                      //   contents. 
....................    while(!PIR1_SSPIF);      // Wait until register is received. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
....................  
....................    return SSPBUF; 
.................... */ 
....................    char c; 
....................  
....................    SPISelectEthernet(); 
*
1ED0:  BCF    F95.4
1ED2:  BCF    F8C.4
....................    ENCSPIXfer(RBM); 
1ED4:  MOVLW  3A
1ED6:  MOVLB  3
1ED8:  MOVWF  xBB
1EDA:  MOVLB  0
1EDC:  CALL   0792
....................    c=ENCSPIXfer(0); 
1EE0:  MOVLB  3
1EE2:  CLRF   xBB
1EE4:  MOVLB  0
1EE6:  CALL   0792
1EEA:  MOVFF  01,395
....................    SPIUnselectEthernet(); 
1EEE:  BCF    F95.4
1EF0:  BSF    F8C.4
....................    return(c); 
1EF2:  MOVLB  3
1EF4:  MOVFF  395,01
.................... }//end MACGet 
1EF8:  MOVLB  0
1EFA:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           *val: Pointer to storage location 
....................  *               len:  Number of bytes to read from the data buffer. 
....................  * 
....................  * Output:          Byte(s) of data read from the data buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Burst reads several sequential bytes from the data buffer 
....................  *               and places them into local memory.  With SPI burst support, 
....................  *               it performs much faster than multiple MACGet() calls. 
....................  *               ERDPT is incremented after each byte, following the same 
....................  *               rules as MACGet(). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetArray(BYTE *val, WORD len) 
.................... { 
.................... /* 
....................    int16 i; 
....................  
....................    // Start the burst operation 
....................    SPISelectEthernet(); 
....................    SSPBUF = RBM;         // Send the Read Buffer Memory opcode. 
....................    i = 0; 
....................    val--; 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................  
....................    // Read the data 
....................    while(i<len) 
....................    { 
....................       SSPBUF = 0;         // Send a dummy byte to receive a byte 
....................       i++; 
....................       val++; 
....................       while(!PIR1_SSPIF);   // Wait until byte is received. 
....................       PIR1_SSPIF = 0; 
....................       *val = SSPBUF; 
....................    }; 
....................  
....................    // Terminate the burst operation 
....................    SPIUnselectEthernet(); 
....................  
....................    return i; 
.................... */ 
....................  
....................    int16 i=0; 
*
10E2:  MOVLB  3
10E4:  CLRF   xA3
10E6:  CLRF   xA4
....................  
....................    SPISelectEthernet(); 
10E8:  BCF    F95.4
10EA:  BCF    F8C.4
....................    ENCSPIXfer(RBM); 
10EC:  MOVLW  3A
10EE:  MOVWF  xBB
10F0:  MOVLB  0
10F2:  CALL   0792
....................    while(i<len) 
....................    { 
10F6:  MOVLB  3
10F8:  MOVF   xA4,W
10FA:  SUBWF  xA2,W
10FC:  BNC   1136
10FE:  BNZ   1106
1100:  MOVF   xA1,W
1102:  SUBWF  xA3,W
1104:  BC    1136
....................       *val=ENCSPIXfer(0); 
1106:  MOVFF  3A0,03
110A:  MOVFF  39F,3A5
110E:  MOVFF  3A0,3A6
1112:  CLRF   xBB
1114:  MOVLB  0
1116:  CALL   0792
111A:  MOVFF  3A6,FEA
111E:  MOVFF  3A5,FE9
1122:  MOVFF  01,FEF
....................       val++; 
1126:  MOVLB  3
1128:  INCF   x9F,F
112A:  BTFSC  FD8.2
112C:  INCF   xA0,F
....................       i++; 
112E:  INCF   xA3,F
1130:  BTFSC  FD8.2
1132:  INCF   xA4,F
....................    } 
1134:  BRA    10F8
....................    SPIUnselectEthernet(); 
1136:  BCF    F95.4
1138:  BSF    F8C.4
....................  
....................    return(i); 
113A:  MOVFF  3A3,01
113E:  MOVFF  3A4,02
.................... }//end MACGetArray 
1142:  MOVLB  0
1144:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPut(BYTE val) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           Byte to write into the ENC28J60 buffer memory 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPut outputs the Write Buffer Memory opcode/constant 
....................  *               (8 bits) and data to write (8 bits) over the SPI. 
....................  *               EWRPT is incremented after the write. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPut(BYTE val) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = WBM;         // Send the opcode and constant. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/constant is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = val;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until byte is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
151C:  BCF    F95.4
151E:  BCF    F8C.4
....................    ENCSPIXfer(WBM); 
1520:  MOVLW  7A
1522:  MOVLB  3
1524:  MOVWF  xBB
1526:  MOVLB  0
1528:  CALL   0792
....................    ENCSPIXfer(val); 
152C:  MOVFF  3B4,3BB
1530:  CALL   0792
....................    SPIUnselectEthernet(); 
1534:  BCF    F95.4
1536:  BSF    F8C.4
.................... }//end MACPut 
1538:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPutArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           *val: Pointer to source of bytes to copy. 
....................  *               len:  Number of bytes to write to the data buffer. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPutArray writes several sequential bytes to the 
....................  *               ENC28J60 RAM.  It performs faster than multiple MACPut() 
....................  *               calls.  EWRPT is incremented by len. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPutArray(BYTE *val, WORD len) 
.................... { 
.................... /* 
....................    // Select the chip and send the proper opcode 
....................    SPISelectEthernet(); 
....................    SSPBUF = WBM;         // Send the Write Buffer Memory opcode 
....................    while(!PIR1_SSPIF);      // Wait until opcode/constant is transmitted. 
....................    PIR1_SSPIF = 0; 
....................  
....................    // Send the data 
....................    while(len) 
....................    { 
....................       SSPBUF = *val;      // Start sending the byte 
....................       val++;            // Increment after writing to SSPBUF to increase speed 
....................       len--;            // Decrement after writing to SSPBUF to increase speed 
....................       while(!PIR1_SSPIF);   // Wait until byte is transmitted 
....................       PIR1_SSPIF = 0; 
....................    }; 
....................  
....................    // Terminate the burst operation 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
153A:  BCF    F95.4
153C:  BCF    F8C.4
....................    ENCSPIXfer(WBM); 
153E:  MOVLW  7A
1540:  MOVLB  3
1542:  MOVWF  xBB
1544:  MOVLB  0
1546:  CALL   0792
....................    while(len--) 
....................    { 
154A:  MOVLB  3
154C:  MOVFF  3B8,03
1550:  MOVF   xB7,W
1552:  BTFSC  FD8.2
1554:  DECF   xB8,F
1556:  DECF   xB7,F
1558:  IORWF  03,W
155A:  BZ    1580
....................       ENCSPIXfer(*val); 
155C:  MOVFF  3B6,03
1560:  MOVFF  3B5,FE9
1564:  MOVFF  3B6,FEA
1568:  MOVFF  FEF,3B9
156C:  MOVFF  3B9,3BB
1570:  MOVLB  0
1572:  CALL   0792
....................       val++; 
1576:  MOVLB  3
1578:  INCF   xB5,F
157A:  BTFSC  FD8.2
157C:  INCF   xB6,F
....................    } 
157E:  BRA    154C
....................    SPIUnselectEthernet(); 
1580:  BCF    F95.4
1582:  BSF    F8C.4
.................... }//end MACPutArray 
1584:  MOVLB  0
1586:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        static void SendSystemReset(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SendSystemReset sends the System Reset SPI command to 
....................  *               the Ethernet controller.  It resets all register contents 
....................  *               (except for ECOCON) and returns the device to the power 
....................  *               on default state. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... static void SendSystemReset(void) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = SR; 
....................    while(!PIR1_SSPIF);      // Wait until the command is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
07F6:  BCF    F95.4
07F8:  BCF    F8C.4
....................    ENCSPIXfer(SR); 
07FA:  MOVLW  FF
07FC:  MOVLB  3
07FE:  MOVWF  xBB
0800:  MOVLB  0
0802:  RCALL  0792
....................    SPIUnselectEthernet(); 
0804:  BCF    F95.4
0806:  BSF    F8C.4
.................... }//end SendSystemReset 
0808:  GOTO   0AC4 (RETURN)
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        REG ReadETHReg(BYTE Address) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *                to read from. 
....................  * 
....................  * Input:           5 bit address of the ETH control register to read from. 
....................  *                 The top 3 bits must be 0. 
....................  * 
....................  * Output:          Byte read from the Ethernet controller's ETH register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadETHReg sends the 8 bit RCR opcode/Address byte over 
....................  *               the SPI and then retrives the register contents in the 
....................  *               next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine cannot be used to access MAC/MII or PHY 
....................  *               registers.  Use ReadMACReg() or ReadPHYReg() for that 
....................  *               purpose. 
....................  *****************************************************************************/ 
.................... static REG ReadETHReg(BYTE Address) 
.................... { 
....................    char c; 
.................... /* 
....................    // Select the chip and send the Read Control Register opcode/address 
....................    SPISelectEthernet(); 
....................    SSPBUF = RCR | Address; 
....................  
....................    while(!PIR1_SSPIF);      // Wait until the opcode/address is transmitted 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = 0;            // Send a dummy byte to receive the register 
....................                      //   contents 
....................    while(!PIR1_SSPIF);      // Wait until the register is received 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
....................  
....................    return *((REG*)&SSPBUF); 
....................    */ 
....................  
....................    SPISelectEthernet(); 
*
07CC:  BCF    F95.4
07CE:  BCF    F8C.4
....................    ENCSPIXfer(RCR | Address); 
07D0:  MOVFF  3B0,3B2
07D4:  MOVFF  3B0,3BB
07D8:  MOVLB  0
07DA:  RCALL  0792
....................    c=ENCSPIXfer(0); 
07DC:  MOVLB  3
07DE:  CLRF   xBB
07E0:  MOVLB  0
07E2:  RCALL  0792
07E4:  MOVFF  01,3B1
....................    SPIUnselectEthernet(); 
07E8:  BCF    F95.4
07EA:  BSF    F8C.4
....................    return(c); 
07EC:  MOVLB  3
07EE:  MOVFF  3B1,01
.................... }//end ReadETHReg 
07F2:  MOVLB  0
07F4:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        REG ReadMACReg(BYTE Address) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *                to read from. 
....................  * 
....................  * Input:           5 bit address of the MAC or MII register to read from. 
....................  *                 The top 3 bits must be 0. 
....................  * 
....................  * Output:          Byte read from the Ethernet controller's MAC/MII register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadMACReg sends the 8 bit RCR opcode/Address byte as well 
....................  *               as a dummy byte over the SPI and then retrives the 
....................  *               register contents in the last 8 SPI clocks. 
....................  * 
....................  * Note:            This routine cannot be used to access ETH or PHY 
....................  *               registers.  Use ReadETHReg() or ReadPHYReg() for that 
....................  *               purpose. 
....................  *****************************************************************************/ 
.................... static REG ReadMACReg(BYTE Address) 
.................... { 
....................    char c; 
.................... /* 
....................    SPISelectEthernet(); 
....................  
....................    SSPBUF = RCR | Address;   // Send the Read Control Register opcode and 
....................                      //   address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................  
....................    SSPBUF = 0;            // Send a dummy byte 
....................    while(!PIR1_SSPIF);      // Wait for the dummy byte to be transmitted 
....................    PIR1_SSPIF = 0; 
....................  
....................    SSPBUF = 0;            // Send another dummy byte to receive the register 
....................                      //   contents. 
....................    while(!PIR1_SSPIF);      // Wait until register is received. 
....................    PIR1_SSPIF = 0; 
....................  
....................    SPIUnselectEthernet(); 
....................  
....................    return *((REG*)&SSPBUF); 
.................... */ 
....................    SPISelectEthernet(); 
*
089C:  BCF    F95.4
089E:  BCF    F8C.4
....................  
....................    ENCSPIXfer(RCR | Address); 
08A0:  MOVFF  30A,30C
08A4:  MOVFF  30A,3BB
08A8:  MOVLB  0
08AA:  RCALL  0792
....................    ENCSPIXfer(0); 
08AC:  MOVLB  3
08AE:  CLRF   xBB
08B0:  MOVLB  0
08B2:  RCALL  0792
....................    c=ENCSPIXfer(0); 
08B4:  MOVLB  3
08B6:  CLRF   xBB
08B8:  MOVLB  0
08BA:  RCALL  0792
08BC:  MOVFF  01,30B
....................  
....................    SPIUnselectEthernet(); 
08C0:  BCF    F95.4
08C2:  BSF    F8C.4
....................  
....................    return(c); 
08C4:  MOVLB  3
08C6:  MOVFF  30B,01
.................... }//end ReadMACReg 
08CA:  MOVLB  0
08CC:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        ReadPHYReg 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Address of the PHY register to read from. 
....................  * 
....................  * Output:          16 bits of data read from the PHY register. 
....................  * 
....................  * Side Effects:    Alters bank bits to point to Bank 2 
....................  * 
....................  * Overview:        ReadPHYReg performs an MII read operation.  While in 
....................  *               progress, it simply polls the MII BUSY bit wasting time. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... PHYREG ReadPHYReg(BYTE Register) 
.................... { 
....................    PHYREG Result; 
....................  
....................    // Set the right address and start the register read operation 
....................    BankSel(MIREGADR); 
*
0960:  MOVLW  02
0962:  MOVLB  3
0964:  MOVWF  xB4
0966:  MOVLW  14
0968:  MOVWF  xB3
096A:  MOVLB  0
096C:  RCALL  0866
....................    WriteReg(MIREGADR, Register); 
096E:  MOVLW  14
0970:  MOVLB  3
0972:  MOVWF  xB6
0974:  MOVFF  307,3B7
0978:  MOVLB  0
097A:  RCALL  080C
....................    WriteReg(MICMD, MICMD_MIIRD); 
097C:  MOVLW  12
097E:  MOVLB  3
0980:  MOVWF  xB6
0982:  MOVLW  01
0984:  MOVWF  xB7
0986:  MOVLB  0
0988:  RCALL  080C
....................  
....................    // Loop to wait until the PHY register has been read through the MII 
....................    // This requires 10.24us 
....................    BankSel(MISTAT); 
098A:  MOVLW  03
098C:  MOVLB  3
098E:  MOVWF  xB4
0990:  MOVLW  0A
0992:  MOVWF  xB3
0994:  MOVLB  0
0996:  RCALL  0866
....................    while(ReadMACReg(MISTAT).MISTATbits.BUSY); 
0998:  MOVLW  0A
099A:  MOVLB  3
099C:  MOVWF  x0A
099E:  MOVLB  0
09A0:  RCALL  089C
09A2:  MOVFF  01,30A
09A6:  MOVLW  00
09A8:  MOVLB  3
09AA:  BTFSC  01.0
09AC:  MOVLW  01
09AE:  XORLW  00
09B0:  BTFSC  FD8.2
09B2:  BRA    09B8
09B4:  MOVLB  0
09B6:  BRA    0998
....................  
....................    // Stop reading 
....................    BankSel(MIREGADR); 
09B8:  MOVLW  02
09BA:  MOVWF  xB4
09BC:  MOVLW  14
09BE:  MOVWF  xB3
09C0:  MOVLB  0
09C2:  RCALL  0866
....................    WriteReg(MICMD, 0x00); 
09C4:  MOVLW  12
09C6:  MOVLB  3
09C8:  MOVWF  xB6
09CA:  CLRF   xB7
09CC:  MOVLB  0
09CE:  RCALL  080C
....................  
....................    // Obtain results and return 
....................    Result.VAL.v[0] = ReadMACReg(MIRDL).Val; 
09D0:  MOVLW  18
09D2:  MOVLB  3
09D4:  MOVWF  x0A
09D6:  MOVLB  0
09D8:  RCALL  089C
09DA:  MOVFF  01,308
....................    Result.VAL.v[1] = ReadMACReg(MIRDH).Val; 
09DE:  MOVLW  19
09E0:  MOVLB  3
09E2:  MOVWF  x0A
09E4:  MOVLB  0
09E6:  RCALL  089C
09E8:  MOVFF  01,309
....................    return Result; 
09EC:  MOVLB  3
09EE:  MOVFF  308,01
09F2:  MOVFF  309,02
.................... }//end ReadPHYReg 
09F6:  MOVLB  0
09F8:  GOTO   0A12 (RETURN)
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void WriteReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *               to modify. 
....................  * 
....................  * Input:           5 bit address of the ETH, MAC, or MII register to modify. 
....................  *                 The top 3 bits must be 0. 
....................  *               Byte to be written into the register. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        WriteReg sends the 8 bit WCR opcode/Address byte over the 
....................  *               SPI and then sends the data to write in the next 8 SPI 
....................  *               clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the BFCReg() and 
....................  *               BFSReg() functions.  It is seperate to maximize speed. 
....................  *               Unlike the ReadETHReg/ReadMACReg functions, WriteReg() 
....................  *               can write to any ETH or MAC register.  Writing to PHY 
....................  *               registers must be accomplished with WritePHYReg(). 
....................  *****************************************************************************/ 
.................... static void WriteReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = WCR | Address;   // Send the opcode and address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = Data;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until register is written. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
080C:  BCF    F95.4
080E:  BCF    F8C.4
....................    ENCSPIXfer(WCR | Address); 
0810:  MOVLB  3
0812:  MOVF   xB6,W
0814:  IORLW  40
0816:  MOVWF  xB8
0818:  MOVWF  xBB
081A:  MOVLB  0
081C:  RCALL  0792
....................    ENCSPIXfer(Data); 
081E:  MOVFF  3B7,3BB
0822:  RCALL  0792
....................    SPIUnselectEthernet(); 
0824:  BCF    F95.4
0826:  BSF    F8C.4
.................... }//end WriteReg 
0828:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void BFCReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *                 to modify. 
....................  * 
....................  * Input:           5 bit address of the register to modify.  The top 3 bits 
....................  *                 must be 0. 
....................  *               Byte to be used with the Bit Field Clear operation. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BFCReg sends the 8 bit BFC opcode/Address byte over the 
....................  *               SPI and then sends the data in the next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the WriteReg() and 
....................  *               BFSReg() functions.  It is separate to maximize speed. 
....................  *               BFCReg() must only be used on ETH registers. 
....................  *****************************************************************************/ 
.................... static void BFCReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = BFC | Address;   // Send the opcode and address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = Data;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until register is written. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
082A:  BCF    F95.4
082C:  BCF    F8C.4
....................    ENCSPIXfer(BFC | Address); 
082E:  MOVLB  3
0830:  MOVF   xB5,W
0832:  IORLW  A0
0834:  MOVWF  xB7
0836:  MOVWF  xBB
0838:  MOVLB  0
083A:  RCALL  0792
....................    ENCSPIXfer(Data); 
083C:  MOVFF  3B6,3BB
0840:  RCALL  0792
....................    SPIUnselectEthernet(); 
0842:  BCF    F95.4
0844:  BSF    F8C.4
.................... }//end BFCReg 
0846:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void BFSReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *               to modify. 
....................  * 
....................  * Input:           5 bit address of the register to modify.  The top 3 bits 
....................  *                 must be 0. 
....................  *               Byte to be used with the Bit Field Set operation. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BFSReg sends the 8 bit BFC opcode/Address byte over the 
....................  *               SPI and then sends the data in the next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the WriteReg() and 
....................  *               BFCReg() functions.  It is separate to maximize speed. 
....................  *               BFSReg() must only be used on ETH registers. 
....................  *****************************************************************************/ 
.................... static void BFSReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = BFS | Address;   // Send the opcode and address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = Data;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until register is written. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
0848:  BCF    F95.4
084A:  BCF    F8C.4
....................    ENCSPIXfer(BFS | Address); 
084C:  MOVLB  3
084E:  MOVF   xB8,W
0850:  IORLW  80
0852:  MOVWF  xBA
0854:  MOVWF  xBB
0856:  MOVLB  0
0858:  RCALL  0792
....................    ENCSPIXfer(Data); 
085A:  MOVFF  3B9,3BB
085E:  RCALL  0792
....................    SPIUnselectEthernet(); 
0860:  BCF    F95.4
0862:  BSF    F8C.4
.................... }//end BFSReg 
0864:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WritePHYReg 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Address of the PHY register to write to. 
....................  *               16 bits of data to write to PHY register. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Alters bank bits to point to Bank 3 
....................  * 
....................  * Overview:        WritePHYReg performs an MII write operation.  While in 
....................  *               progress, it simply polls the MII BUSY bit wasting time. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void WritePHYReg(BYTE Register, WORD Data) 
.................... { 
....................    // Write the register address 
....................    BankSel(MIREGADR); 
*
08CE:  MOVLW  02
08D0:  MOVLB  3
08D2:  MOVWF  xB4
08D4:  MOVLW  14
08D6:  MOVWF  xB3
08D8:  MOVLB  0
08DA:  RCALL  0866
....................    WriteReg(MIREGADR, Register); 
08DC:  MOVLW  14
08DE:  MOVLB  3
08E0:  MOVWF  xB6
08E2:  MOVFF  307,3B7
08E6:  MOVLB  0
08E8:  RCALL  080C
....................  
....................    // Write the data 
....................    // Order is important: write low byte first, high byte last 
....................    WriteReg(MIWRL, ((WORD_VAL*)&Data)->v[0]); 
08EA:  MOVLW  03
08EC:  MOVLB  3
08EE:  MOVWF  x0B
08F0:  MOVLW  08
08F2:  MOVWF  FE9
08F4:  MOVFF  30B,FEA
08F8:  MOVFF  FEF,30C
08FC:  MOVLW  16
08FE:  MOVWF  xB6
0900:  MOVFF  30C,3B7
0904:  MOVLB  0
0906:  RCALL  080C
....................    WriteReg(MIWRH, ((WORD_VAL*)&Data)->v[1]); 
0908:  MOVLW  03
090A:  MOVLB  3
090C:  MOVWF  x0B
090E:  MOVLW  08
0910:  MOVWF  x0A
0912:  MOVLW  01
0914:  ADDWF  x0A,W
0916:  MOVWF  FE9
0918:  MOVLW  00
091A:  ADDWFC x0B,W
091C:  MOVWF  FEA
091E:  MOVFF  FEF,30C
0922:  MOVLW  17
0924:  MOVWF  xB6
0926:  MOVFF  30C,3B7
092A:  MOVLB  0
092C:  RCALL  080C
....................  
....................    // Wait until the PHY register has been written 
....................    BankSel(MISTAT); 
092E:  MOVLW  03
0930:  MOVLB  3
0932:  MOVWF  xB4
0934:  MOVLW  0A
0936:  MOVWF  xB3
0938:  MOVLB  0
093A:  RCALL  0866
....................    while(ReadMACReg(MISTAT).MISTATbits.BUSY); 
093C:  MOVLW  0A
093E:  MOVLB  3
0940:  MOVWF  x0A
0942:  MOVLB  0
0944:  RCALL  089C
0946:  MOVFF  01,30A
094A:  MOVLW  00
094C:  MOVLB  3
094E:  BTFSC  01.0
0950:  MOVLW  01
0952:  XORLW  00
0954:  BTFSC  FD8.2
0956:  BRA    095C
0958:  MOVLB  0
095A:  BRA    093C
.................... }//end WritePHYReg 
095C:  MOVLB  0
095E:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BankSel 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Register address with the high byte containing the 2 bank 
....................  *                 select 2 bits. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BankSel takes the high byte of a register address and 
....................  *               changes the bank select bits in ETHCON1 to match. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... static void BankSel(WORD Register) 
.................... { 
....................    BFCReg(ECON1, ECON1_BSEL1 | ECON1_BSEL0); 
*
0866:  MOVLW  1F
0868:  MOVLB  3
086A:  MOVWF  xB5
086C:  MOVLW  03
086E:  MOVWF  xB6
0870:  MOVLB  0
0872:  RCALL  082A
....................    BFSReg(ECON1, ((WORD_VAL*)&Register)->v[1]); 
0874:  MOVLW  03
0876:  MOVLB  3
0878:  MOVWF  xB6
087A:  MOVLW  B3
087C:  MOVWF  xB5
087E:  MOVLW  01
0880:  ADDWF  xB5,W
0882:  MOVWF  FE9
0884:  MOVLW  00
0886:  ADDWFC xB6,W
0888:  MOVWF  FEA
088A:  MOVFF  FEF,3B7
088E:  MOVLW  1F
0890:  MOVWF  xB8
0892:  MOVFF  3B7,3B9
0896:  MOVLB  0
0898:  RCALL  0848
.................... }//end BankSel 
089A:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        static BOOL TestMemory(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if the memory tests have passed 
....................  *               FALSE if the BIST has detected a hardware fault 
....................  * 
....................  * Side Effects:    Alters the state of numerous control registers and all 
....................  *               RAM bytes. 
....................  * 
....................  * Overview:        The internal BIST and DMA modules are used to fill the 
....................  *               entire dual port memory and calculate a checksum of the 
....................  *               data stored within.  Address and Random fill modes are 
....................  *               used. 
....................  * 
....................  * Note:            For the Random Fill mode, the random number generator is 
....................  *               seeded by the contents of the TMR0L PIC SFR.  If the timer 
....................  *               is running, additional confidence that the memory is 
....................  *               working can be obtained by calling TestMemory multiple 
....................  *               times. 
....................  *****************************************************************************/ 
.................... #if defined(MAC_POWER_ON_TEST) 
.................... static BOOL TestMemory(void) 
.................... { 
....................    #define RANDOM_FILL      0b0000 
....................    #define ADDRESS_FILL   0b0100 
....................    #define PATTERN_SHIFT   0b1000 
....................  
....................    WORD_VAL DMAChecksum, BISTChecksum; 
....................  
....................  
....................    // Select Bank 0 and disable anything that could have been in progress 
....................    WriteReg(ECON1, 0x00); 
....................  
....................    // Set up necessary pointers for the DMA to calculate over the entire 
....................    // memory 
....................    WriteReg(EDMASTL, 0x00); 
....................    WriteReg(EDMASTH, 0x00); 
....................    WriteReg(EDMANDL, LOW(RAMSIZE-1u)); 
....................    WriteReg(EDMANDH, HIGH(RAMSIZE-1u)); 
....................    WriteReg(ERXNDL, LOW(RAMSIZE-1u)); 
....................    WriteReg(ERXNDH, HIGH(RAMSIZE-1u)); 
....................  
....................    // Enable Test Mode and do an Address Fill 
....................    BankSel(EBSTCON); 
....................    WriteReg((BYTE)EBSTCON, EBSTCON_TME | 
....................                    EBSTCON_BISTST | 
....................                    ADDRESS_FILL); 
....................  
....................  
....................    // Wait for the BIST to complete and disable test mode before 
....................    // starting any DMA operations. 
....................    while(ReadETHReg((BYTE)EBSTCON).EBSTCONbits.BISTST); 
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
....................  
....................    // Begin reading the memory and calculating a checksum over it 
....................    // Block until the checksum is generated 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
....................    BankSel(EDMACSL); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
....................    // Obtain the resulting DMA checksum and the expected BIST checksum 
....................    DMAChecksum.v[0] = ReadETHReg(EDMACSL).Val; 
....................    DMAChecksum.v[1] = ReadETHReg(EDMACSH).Val; 
....................    BankSel(EBSTCSL); 
....................    BISTChecksum.v[0] = ReadETHReg((BYTE)EBSTCSL).Val; 
....................    BISTChecksum.v[1] = ReadETHReg((BYTE)EBSTCSH).Val; 
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
....................    // Compare the results 
....................    // 0xF807 should always be generated in Address fill mode 
....................    if( (DMAChecksum.Val != BISTChecksum.Val) || (DMAChecksum.Val != 0xF807) ) 
....................       return FALSE; 
....................  
....................    // Seed the random number generator and begin another Random Fill test 
....................    // with the DMA and BIST memory access ports swapped. 
.................... #ifdef __C30__ 
....................    WriteReg((BYTE)EBSTSD, TMR1); 
.................... #else 
....................    WriteReg((BYTE)EBSTSD, TMR0L); 
.................... #endif 
....................    WriteReg((BYTE)EBSTCON, EBSTCON_TME | 
....................                  EBSTCON_PSEL | 
....................                  EBSTCON_BISTST | 
....................                  RANDOM_FILL); 
....................  
....................  
....................    // Wait for the BIST to complete and disable test mode since 
....................    // we won't be needing it anymore 
....................    while(ReadETHReg((BYTE)EBSTCON).EBSTCONbits.BISTST); 
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
....................  
....................    // Begin reading the memory and calculating a checksum over it 
....................    // Block until the checksum is generated 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
....................    BankSel(EDMACSL); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
....................    // Obtain the resulting DMA checksum and the expected BIST checksum 
....................    DMAChecksum.v[0] = ReadETHReg(EDMACSL).Val; 
....................    DMAChecksum.v[1] = ReadETHReg(EDMACSH).Val; 
....................    BankSel(EBSTCSL); 
....................    BISTChecksum.v[0] = ReadETHReg((BYTE)EBSTCSL).Val; 
....................    BISTChecksum.v[1] = ReadETHReg((BYTE)EBSTCSH).Val; 
....................  
....................    return (DMAChecksum.Val == BISTChecksum.Val); 
.................... }//end TestMemory 
.................... #endif 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetDuplex(DUPLEX DuplexState) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Member of DUPLEX enum: 
....................  *                  FULL: Set full duplex mode 
....................  *                  HALF: Set half duplex mode 
....................  *                  USE_PHY: Set the MAC to match the PHYDPLXMODE bit in 
....................  *                         PHYCON.  This is controlled by LEDB on RESET. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Changes bank bits to Bank 2. 
....................  * 
....................  * Overview:        Disables RX, TX logic, sets MAC up for full duplex 
....................  *               operation, sets PHY up for full duplex operation, and 
....................  *               reenables RX logic.  The back-to-back inter-packet gap 
....................  *               register (MACBBIPG) is updated to maintain a 9.6us gap. 
....................  * 
....................  * Note:            If a packet is being transmitted or received while this 
....................  *               function is called, it will be aborted. 
....................  *****************************************************************************/ 
.................... void MACSetDuplex(DUPLEX DuplexState) 
.................... { 
....................    REG Register; 
....................    PHYREG PhyReg; 
....................  
....................    // Disable receive logic and abort any packets currently being transmitted 
....................    BFCReg(ECON1, ECON1_TXRTS | ECON1_RXEN); 
*
09FC:  MOVLW  1F
09FE:  MOVLB  3
0A00:  MOVWF  xB5
0A02:  MOVLW  0C
0A04:  MOVWF  xB6
0A06:  MOVLB  0
0A08:  RCALL  082A
....................  
....................    // Set the PHY to the proper duplex mode 
....................    PhyReg = ReadPHYReg(PHCON1); 
0A0A:  MOVLB  3
0A0C:  CLRF   x07
0A0E:  MOVLB  0
0A10:  BRA    0960
0A12:  MOVFF  02,306
0A16:  MOVFF  01,305
....................    if(DuplexState == USE_PHY) 
0A1A:  MOVLB  3
0A1C:  MOVF   x03,W
0A1E:  SUBLW  02
0A20:  BNZ   0A2A
....................    { 
....................       DuplexState = PhyReg.PHCON1bits.PDPXMD; 
0A22:  CLRF   x03
0A24:  BTFSC  x06.0
0A26:  INCF   x03,F
....................    } 
....................    else 
0A28:  BRA    0A40
....................    { 
....................       PhyReg.PHCON1bits.PDPXMD = DuplexState; 
0A2A:  BCF    x06.0
0A2C:  BTFSC  x03.0
0A2E:  BSF    x06.0
....................       WritePHYReg(PHCON1, PhyReg.Val); 
0A30:  CLRF   x07
0A32:  MOVFF  306,309
0A36:  MOVFF  305,308
0A3A:  MOVLB  0
0A3C:  RCALL  08CE
0A3E:  MOVLB  3
....................    } 
....................  
....................    // Set the MAC to the proper duplex mode 
....................    BankSel(MACON3); 
0A40:  MOVLW  02
0A42:  MOVWF  xB4
0A44:  MOVWF  xB3
0A46:  MOVLB  0
0A48:  RCALL  0866
....................    Register = ReadMACReg(MACON3); 
0A4A:  MOVLW  02
0A4C:  MOVLB  3
0A4E:  MOVWF  x0A
0A50:  MOVLB  0
0A52:  RCALL  089C
0A54:  MOVFF  01,304
....................    Register.MACON3bits.FULDPX = DuplexState; 
0A58:  MOVLB  3
0A5A:  BCF    x04.0
0A5C:  BTFSC  x03.0
0A5E:  BSF    x04.0
....................    WriteReg(MACON3, Register.Val); 
0A60:  MOVLW  02
0A62:  MOVWF  xB6
0A64:  MOVFF  304,3B7
0A68:  MOVLB  0
0A6A:  RCALL  080C
....................  
....................    // Set the back-to-back inter-packet gap time to IEEE specified 
....................    // requirements.  The meaning of the MABBIPG value changes with the duplex 
....................    // state, so it must be updated in this function. 
....................    // In full duplex, 0x15 represents 9.6us; 0x12 is 9.6us in half duplex 
....................    WriteReg(MABBIPG, DuplexState ? 0x15 : 0x12); 
0A6C:  MOVLB  3
0A6E:  MOVF   x03,F
0A70:  BZ    0A76
0A72:  MOVLW  15
0A74:  BRA    0A78
0A76:  MOVLW  12
0A78:  MOVWF  x07
0A7A:  MOVLW  04
0A7C:  MOVWF  xB6
0A7E:  MOVFF  307,3B7
0A82:  MOVLB  0
0A84:  RCALL  080C
....................  
....................    // Reenable receive logic 
....................    BFSReg(ECON1, ECON1_RXEN); 
0A86:  MOVLW  1F
0A88:  MOVLB  3
0A8A:  MOVWF  xB8
0A8C:  MOVLW  04
0A8E:  MOVWF  xB9
0A90:  MOVLB  0
0A92:  RCALL  0848
.................... }//end MACSetDuplex 
0A94:  GOTO   0C54 (RETURN)
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerDown(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerDown puts the ENC28J60 in low power sleep mode. In 
....................  *               sleep mode, no packets can be transmitted or received. 
....................  *               All MAC and PHY registers should not be accessed. 
....................  * 
....................  * Note:            If a packet is being transmitted while this function is 
....................  *                called, this function will block until it is it complete. 
....................  *               If anything is being received, it will be completed. 
....................  *****************************************************************************/ 
.................... void MACPowerDown(void) 
.................... { 
....................    // Disable packet reception 
....................    BFCReg(ECON1, ECON1_RXEN); 
....................  
....................    // Make sure any last packet which was in-progress when RXEN was cleared 
....................    // is completed 
....................    while(ReadETHReg(ESTAT).ESTATbits.RXBUSY); 
....................  
....................    // If a packet is being transmitted, wait for it to finish 
....................    while(ReadETHReg(ECON1).ECON1bits.TXRTS); 
....................  
....................    // Enter sleep mode 
....................    BFSReg(ECON2, ECON2_PWRSV); 
.................... }//end MACPowerDown 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerUp(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerUp returns the ENC28J60 back to normal operation 
....................  *               after a previous call to MACPowerDown().  Calling this 
....................  *               function when already powered up will have no effect. 
....................  * 
....................  * Note:            The first packet transmitted may get lost at the RX end if 
....................  *               you don't wait for the link to go up first.  MACIsLinked() 
....................  *               can be called to determine if a link is established. 
....................  *****************************************************************************/ 
.................... void MACPowerUp(void) 
.................... { 
....................    // Leave power down mode 
....................    BFCReg(ECON2, ECON2_PWRSV); 
....................  
....................    // Wait for the 300us Oscillator Startup Timer (OST) to time out.  This 
....................    // delay is required for the PHY module to return to an operational state. 
....................    while(!ReadETHReg(ESTAT).ESTATbits.CLKRDY); 
....................  
....................    // Enable packet reception 
....................    BFSReg(ECON1, ECON1_RXEN); 
.................... }//end MACPowerUp 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void SetCLKOUT(BYTE NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - 0x00: CLKOUT disabled (pin driven low) 
....................  *                        0x01: Divide by 1 (25 MHz) 
....................  *                        0x02: Divide by 2 (12.5 MHz) 
....................  *                        0x03: Divide by 3 (8.333333 MHz) 
....................  *                        0x04: Divide by 4 (6.25 MHz, POR default) 
....................  *                        0x05: Divide by 8 (3.125 MHz) 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the ECOCON register. 
....................  *               The CLKOUT pin will beginning outputting the new frequency 
....................  *               immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... void SetCLKOUT(BYTE NewConfig) 
.................... { 
....................    BankSel(ECOCON); 
....................    WriteReg(ECOCON, NewConfig); 
.................... }//end SetCLKOUT 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BYTE GetCLKOUT(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          BYTE - 0x00: CLKOUT disabled (pin driven low) 
....................  *                     0x01: Divide by 1 (25 MHz) 
....................  *                     0x02: Divide by 2 (12.5 MHz) 
....................  *                     0x03: Divide by 3 (8.333333 MHz) 
....................  *                     0x04: Divide by 4 (6.25 MHz, POR default) 
....................  *                     0x05: Divide by 8 (3.125 MHz) 
....................  *                     0x06: Reserved 
....................  *                     0x07: Reserved 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the ECOCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BYTE GetCLKOUT(void) 
.................... { 
....................    BankSel(ECOCON); 
....................    return ReadETHReg(ECOCON).Val; 
.................... }//end GetCLKOUT 
....................  
....................    #elif STACK_USE_MCPINC 
....................     #include "tcpip/eth97j60.c" 
....................    #else 
....................     #include "tcpip/rtl8019AS.c" 
....................    #endif 
.................... #endif 
....................  
.................... #if STACK_USE_PPP 
....................    #include "tcpip/modem.c" 
....................    #include "tcpip/ppp.c" 
....................    #include "tcpip/pppwrap.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SLIP 
....................    #include "tcpip/slip.c" 
.................... #ENDIF 
....................  
.................... #if STACK_USE_UDP 
....................    #include "tcpip/udp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    #include "tcpip/dhcp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
....................    #include "tcpip/smtp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    #include "tcpip/http.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ///                                                                     /// 
.................... ///                              HTTP.H                                 /// 
.................... ///                                                                     /// 
.................... /// Simple webserver for the Microchip TCP/IP stack.                    /// 
.................... /// NOTE: THIS IS A DIFFERENT HTTP.H THAN WHAT MICROCHIP PROVIDES       /// 
.................... ///                                                                     /// 
.................... /// See HTTP.C for documenation                                         /// 
.................... ///                                                                     /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2006 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef HTTP_USE_CHUNKS 
.................... #define HTTP_USE_CHUNKS   FALSE 
.................... #endif 
....................  
.................... #ifndef HTTP_USE_DOUBLE_ESCAPE 
.................... #define HTTP_USE_DOUBLE_ESCAPE   FALSE 
.................... #endif 
....................  
.................... #ifndef HTTP_USE_CONTENT_TYPE 
.................... #define HTTP_USE_CONTENT_TYPE   FALSE 
.................... #endif 
....................  
.................... #ifndef HTTP_PORT 
.................... #define HTTP_PORT             80 
.................... #endif 
....................  
.................... #ifndef HTTP_NUM_SOCKETS 
.................... #define HTTP_NUM_SOCKETS      1 
.................... #endif 
....................  
.................... #ifndef HTTP_GET_PARAM_MAX_SIZE 
.................... #define HTTP_GET_PARAM_MAX_SIZE  254 
.................... #endif 
....................  
.................... void HTTP_Init(void); 
.................... void HTTP_Task(void); 
....................  
.................... //**** CALLBACKS START ******/// 
....................  
.................... /// the following three functions are callbacks and 
.................... /// must be written in your main application!!!  see the documentation above 
.................... /// for more help. 
....................  
.................... #if HTTP_USE_CONTENT_TYPE 
....................  void http_get_page(char *file_str, int32 *retAddress, char *retStr); 
.................... #else 
....................  int32 http_get_page(char *file_str); 
.................... #endif 
....................  
.................... int8 http_format_char(int32 file, char id, char *str, int8 max_ret); 
.................... void http_exec_cgi(int32 file, char *key, char *val); 
....................  
.................... //**** CALLBACKS END ******/// 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_HTTP2 
....................    #include "tcpip/http2.h" 
.................... #endif 
....................  
.................... #if STACK_USE_DNS 
....................    #include "tcpip/dns.h" 
.................... #endif 
....................  
.................... #if STACK_USE_SNMP 
....................    #include "tcpip/snmp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MPFS 
....................    #include "tcpip/mpfs.h" 
.................... #endif 
....................  
.................... #include "tcpip/ip.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  PIC IP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.C 
....................  * Dependencies:    string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  IP.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Howard Schlunder		8/31/04	Beta Rev 0.9 (See version.log for detail) 
....................  * Howard Schlunder		1/5/06	Improved DMA checksum efficiency 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8 *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8 *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... // This is left shifted by 4.  Actual value is 0x04. 
.................... #define IPv4                (0x40u) 
.................... #define IP_VERSION          IPv4 
....................  
.................... #define debug_ip 
.................... //#define debug_ip  debug_printf 
....................  
.................... // IHL (Internet Header Length) is # of DWORDs in a header. 
.................... // Since, we do not support options, our IP header length will be 
.................... // minimum i.e. 20 bytes : IHL = 20 / 4 = 5. 
.................... #define IP_IHL              (0x05) 
....................  
.................... #define IP_SERVICE_NW_CTRL  (0x07) 
.................... #define IP_SERVICE_IN_CTRL  (0x06) 
.................... #define IP_SERVICE_ECP      (0x05) 
.................... #define IP_SERVICE_OVR      (0x04) 
.................... #define IP_SERVICE_FLASH    (0x03) 
.................... #define IP_SERVICE_IMM      (0x02) 
.................... #define IP_SERVICE_PRIOR    (0x01) 
.................... #define IP_SERVICE_ROUTINE  (0x00) 
....................  
.................... #define IP_SERVICE_N_DELAY  (0x00) 
.................... #define IP_SERCICE_L_DELAY  (0x08) 
.................... #define IP_SERVICE_N_THRPT  (0x00) 
.................... #define IP_SERVICE_H_THRPT  (0x10) 
.................... #define IP_SERVICE_N_RELIB  (0x00) 
.................... #define IP_SERVICE_H_RELIB  (0x20) 
....................  
.................... #define IP_SERVICE          (IP_SERVICE_ROUTINE | IP_SERVICE_N_DELAY) 
....................  
.................... #define MY_IP_TTL           (100)   // Time-To-Live in Seconds 
....................  
....................  
....................  
....................  
.................... static WORD _Identifier = 0; 
.................... static BYTE IPHeaderLen; 
....................  
.................... static void SwapIPHeader(IP_HEADER* h); 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len) 
.................... { 
....................     WORD_VAL    CalcChecksum; 
....................     IP_HEADER   header; 
....................  
.................... #if !defined(MCHP_MAC) 
....................     WORD_VAL    ReceivedChecksum; 
....................     WORD        checksums[2]; 
....................     BYTE        optionsLen; 
.................... #define MAX_OPTIONS_LEN     (40)            // As per RFC 791. 
....................     BYTE        options[MAX_OPTIONS_LEN]; 
.................... #endif 
....................  
....................     // Read IP header. 
....................     MACGetArray((BYTE*)&header, sizeof(header)); 
*
1D02:  MOVLW  03
1D04:  MOVLB  3
1D06:  MOVWF  x27
1D08:  MOVLW  12
1D0A:  MOVFF  327,3A0
1D0E:  MOVWF  x9F
1D10:  CLRF   xA2
1D12:  MOVLW  14
1D14:  MOVWF  xA1
1D16:  MOVLB  0
1D18:  CALL   10E2
....................  
....................     // Make sure that this is an IPv4 packet. 
....................     if ( (header.VersionIHL & 0xf0) != IP_VERSION ) 
1D1C:  MOVLB  3
1D1E:  MOVF   x12,W
1D20:  ANDLW  F0
1D22:  SUBLW  40
1D24:  BZ    1D2C
....................     	return FALSE; 
1D26:  MOVLW  00
1D28:  MOVWF  01
1D2A:  BRA    1DDC
....................  
.................... 	IPHeaderLen = (header.VersionIHL & 0x0f) << 2; 
1D2C:  MOVF   x12,W
1D2E:  ANDLW  0F
1D30:  MOVWF  00
1D32:  RLCF   00,W
1D34:  MOVWF  5C
1D36:  RLCF   5C,F
1D38:  MOVLW  FC
1D3A:  ANDWF  5C,F
....................  
.................... #if defined(MCHP_MAC) 
.................... 	// Validate the IP header.  If it is correct, the checksum 
.................... 	// will come out to 0x0000 (because the header contains a 
.................... 	// precomputed checksum).  A corrupt header will have a 
.................... 	// nonzero checksum. 
.................... 	CalcChecksum.Val = MACCalcRxChecksum(0, IPHeaderLen); 
1D3C:  CLRF   x62
1D3E:  CLRF   x61
1D40:  CLRF   x64
1D42:  MOVFF  5C,363
1D46:  MOVLB  0
1D48:  RCALL  1A9E
1D4A:  MOVFF  02,311
1D4E:  MOVFF  01,310
....................  
.................... 	// Seek to the end of the IP header 
.................... 	MACSetRxBuffer(IPHeaderLen); 
1D52:  MOVLB  3
1D54:  CLRF   x3B
1D56:  MOVFF  5C,33A
1D5A:  MOVLB  0
1D5C:  RCALL  1BA6
....................  
....................     if(CalcChecksum.Val) 
1D5E:  MOVLB  3
1D60:  MOVF   x10,W
1D62:  IORWF  x11,W
1D64:  BZ    1D6C
.................... #else 
....................  
....................     // Calculate options length in this header, if there is any. 
....................     // IHL is in terms of numbers of 32-bit DWORDs; i.e. actual 
....................     // length is 4 times IHL. 
....................     optionsLen = ((header.VersionIHL & 0x0f) << 2) - sizeof(header); 
....................  
....................     // If there is any option(s), read it so that we can include them 
....................     // in checksum calculation. 
....................     if ( optionsLen > MAX_OPTIONS_LEN ) 
....................         return FALSE; 
....................  
....................     if ( optionsLen > 0 ) 
....................         MACGetArray(options, optionsLen); 
....................  
....................     // Save header checksum; clear it and recalculate it ourselves. 
....................     ReceivedChecksum.Val = header.HeaderChecksum; 
....................     header.HeaderChecksum = 0; 
....................  
....................     // Calculate checksum of header including options bytes. 
....................     checksums[0] = ~CalcIPChecksum((BYTE*)&header, sizeof(header)); 
....................  
....................     // Calculate Options checksum too, if they are present. 
....................     if ( optionsLen > 0 ) 
....................         checksums[1] = ~CalcIPChecksum((BYTE*)options, optionsLen); 
....................     else 
....................         checksums[1] = 0; 
....................  
....................     CalcChecksum.Val  = CalcIPChecksum((BYTE*)checksums, 
....................                                             2 * sizeof(WORD)); 
....................  
....................     // Make sure that checksum is correct 
....................     if ( ReceivedChecksum.Val != CalcChecksum.Val ) 
.................... #endif 
....................     { 
....................         // Bad packet. The function caller will be notified by means of the FALSE 
....................         // return value and it should discard the packet. 
....................         return FALSE; 
1D66:  MOVLW  00
1D68:  MOVWF  01
1D6A:  BRA    1DDC
....................     } 
....................  
....................     // Network to host conversion. 
....................     SwapIPHeader(&header); 
1D6C:  MOVLW  03
1D6E:  MOVWF  xAB
1D70:  MOVLW  12
1D72:  MOVWF  xAA
1D74:  MOVLB  0
1D76:  RCALL  1C22
....................  
....................     // If caller is intrested, return destination IP address 
....................     // as seen in this IP header. 
....................     if ( localIP ) 
1D78:  MOVLB  3
1D7A:  MOVF   x08,W
1D7C:  IORWF  x09,W
1D7E:  BZ    1D98
....................         localIP->Val    = header.DestAddress.Val; 
1D80:  MOVFF  308,FE9
1D84:  MOVFF  309,FEA
1D88:  MOVFF  322,FEF
1D8C:  MOVFF  323,FEC
1D90:  MOVFF  324,FEC
1D94:  MOVFF  325,FEC
....................  
....................     remote->IPAddr.Val  = header.SourceAddress.Val; 
1D98:  MOVLW  06
1D9A:  ADDWF  x0A,W
1D9C:  MOVWF  FE9
1D9E:  MOVLW  00
1DA0:  ADDWFC x0B,W
1DA2:  MOVWF  FEA
1DA4:  MOVFF  31E,FEF
1DA8:  MOVFF  31F,FEC
1DAC:  MOVFF  320,FEC
1DB0:  MOVFF  321,FEC
....................     *protocol           = header.Protocol; 
1DB4:  MOVFF  30C,FE9
1DB8:  MOVFF  30D,FEA
1DBC:  MOVFF  31B,FEF
.................... #if defined(MCHP_MAC) 
....................     *len 				= header.TotalLength - IPHeaderLen; 
1DC0:  MOVFF  30E,FE9
1DC4:  MOVFF  30F,FEA
1DC8:  MOVF   5C,W
1DCA:  SUBWF  x14,W
1DCC:  MOVWF  00
1DCE:  MOVLW  00
1DD0:  SUBWFB x15,W
1DD2:  MOVFF  00,FEF
1DD6:  MOVWF  FEC
.................... #else 
....................     *len                = header.TotalLength - optionsLen - 
....................                             sizeof(header); 
.................... #endif 
....................  
....................     return TRUE; 
1DD8:  MOVLW  01
1DDA:  MOVWF  01
.................... } 
1DDC:  MOVLB  0
1DDE:  GOTO   6BE0 (RETURN)
....................  
....................  
.................... /********************************************************************* 
....................  * Function: WORD IPPutHeader(NODE_INFO *remote, 
....................  *           				  BYTE protocol, 
....................  *                			  WORD len) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           *remote     - Destination node address 
....................  *                  protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          (WORD)0 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  ********************************************************************/ 
.................... WORD IPPutHeader(NODE_INFO *remote, 
....................                 BYTE protocol, 
....................                 WORD    len) 
.................... { 
....................     IP_HEADER   header; 
....................  
....................     IPHeaderLen = sizeof(IP_HEADER); 
*
27CE:  MOVLW  14
27D0:  MOVWF  5C
....................  
....................     header.VersionIHL       = IP_VERSION | IP_IHL; 
27D2:  MOVLW  45
27D4:  MOVLB  3
27D6:  MOVWF  x96
....................     header.TypeOfService    = IP_SERVICE; 
27D8:  CLRF   x97
....................     header.TotalLength      = sizeof(header) + len; 
27DA:  MOVLW  14
27DC:  ADDWF  x94,W
27DE:  MOVWF  x98
27E0:  MOVLW  00
27E2:  ADDWFC x95,W
27E4:  MOVWF  x99
....................     header.Identification   = ++_Identifier; 
27E6:  INCF   5A,F
27E8:  BTFSC  FD8.2
27EA:  INCF   5B,F
27EC:  MOVFF  5B,39B
27F0:  MOVFF  5A,39A
....................     header.FragmentInfo     = 0; 
27F4:  CLRF   x9D
27F6:  CLRF   x9C
....................     header.TimeToLive       = MY_IP_TTL; 
27F8:  MOVLW  64
27FA:  MOVWF  x9E
....................     header.Protocol         = protocol; 
27FC:  MOVFF  393,39F
....................     header.HeaderChecksum   = 0; 
2800:  CLRF   xA1
2802:  CLRF   xA0
.................... 	header.SourceAddress = AppConfig.MyIPAddr; 
2804:  MOVFF  1B,3A5
2808:  MOVFF  1A,3A4
280C:  MOVFF  19,3A3
2810:  MOVFF  18,3A2
....................  
....................     header.DestAddress.Val = remote->IPAddr.Val; 
2814:  MOVLW  06
2816:  ADDWF  x91,W
2818:  MOVWF  FE9
281A:  MOVLW  00
281C:  ADDWFC x92,W
281E:  MOVWF  FEA
2820:  MOVFF  FEF,00
2824:  MOVFF  FEC,01
2828:  MOVFF  FEC,02
282C:  MOVFF  FEC,03
2830:  MOVFF  03,3A9
2834:  MOVFF  02,3A8
2838:  MOVFF  01,3A7
283C:  MOVFF  00,3A6
....................  
....................     SwapIPHeader(&header); 
2840:  MOVLW  03
2842:  MOVWF  xAB
2844:  MOVLW  96
2846:  MOVWF  xAA
2848:  MOVLB  0
284A:  CALL   1C22
....................  
.................... #if !defined(MCHP_MAC) 
....................     header.HeaderChecksum   = CalcIPChecksum((BYTE*)&header, 
....................                                                 sizeof(header)); 
.................... #endif 
....................  
....................     MACPutHeader(&remote->MACAddr, MAC_IP, (sizeof(header)+len)); 
284E:  MOVLB  3
2850:  MOVFF  391,01
2854:  MOVFF  392,03
2858:  MOVFF  391,3AA
285C:  MOVFF  392,3AB
2860:  MOVLW  14
2862:  ADDWF  x94,W
2864:  MOVWF  xAC
2866:  MOVLW  00
2868:  ADDWFC x95,W
286A:  MOVWF  xAD
286C:  MOVFF  392,3AF
2870:  MOVFF  391,3AE
2874:  CLRF   xB0
2876:  MOVWF  xB2
2878:  MOVFF  3AC,3B1
287C:  MOVLB  0
287E:  CALL   1588
....................     MACPutArray((BYTE*)&header, sizeof(header)); 
2882:  MOVLW  03
2884:  MOVLB  3
2886:  MOVWF  xAB
2888:  MOVLW  96
288A:  MOVFF  3AB,3B6
288E:  MOVWF  xB5
2890:  CLRF   xB8
2892:  MOVLW  14
2894:  MOVWF  xB7
2896:  MOVLB  0
2898:  CALL   153A
....................  
.................... #if defined(MCHP_MAC) 
.................... 	header.HeaderChecksum = MACCalcTxChecksum(0, sizeof(header)); 
289C:  MOVLB  3
289E:  CLRF   xAB
28A0:  CLRF   xAA
28A2:  CLRF   xAD
28A4:  MOVLW  14
28A6:  MOVWF  xAC
28A8:  MOVLB  0
28AA:  RCALL  26F6
28AC:  MOVFF  02,3A1
28B0:  MOVFF  01,3A0
.................... 	MACSetTxBuffer(CurrentTxBuffer, 10);	// 10 is the offset in header to the HeaderChecksum member 
28B4:  MOVFF  4F,3AA
28B8:  MOVLB  3
28BA:  CLRF   xAC
28BC:  MOVLW  0A
28BE:  MOVWF  xAB
28C0:  MOVLB  0
28C2:  CALL   1472
.................... 	MACPutArray((BYTE*)&header.HeaderChecksum, 2); 
28C6:  MOVLW  03
28C8:  MOVLB  3
28CA:  MOVWF  xAB
28CC:  MOVLW  A0
28CE:  MOVFF  3AB,3B6
28D2:  MOVWF  xB5
28D4:  CLRF   xB8
28D6:  MOVLW  02
28D8:  MOVWF  xB7
28DA:  MOVLB  0
28DC:  CALL   153A
.................... 	MACSetTxBuffer(CurrentTxBuffer, sizeof(header));	// Seek back to the end of the packet 
28E0:  MOVFF  4F,3AA
28E4:  MOVLB  3
28E6:  CLRF   xAC
28E8:  MOVLW  14
28EA:  MOVWF  xAB
28EC:  MOVLB  0
28EE:  CALL   1472
.................... #endif 
....................  
....................     return 0x0; 
28F2:  MOVLW  00
28F4:  MOVWF  01
28F6:  MOVWF  02
.................... } 
28F8:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset) 
.................... { 
.................... 	MACSetRxBuffer(Offset+IPHeaderLen); 
*
2054:  MOVF   5C,W
2056:  MOVLB  3
2058:  ADDWF  x36,W
205A:  MOVWF  x38
205C:  MOVLW  00
205E:  ADDWFC x37,W
2060:  MOVWF  x39
2062:  MOVWF  x3B
2064:  MOVFF  338,33A
2068:  MOVLB  0
206A:  RCALL  1BA6
.................... } 
206C:  RETLW  00
....................  
....................  
....................  
.................... static void SwapIPHeader(IP_HEADER* h) 
.................... { 
....................     h->TotalLength      = swaps(h->TotalLength); 
*
1C22:  MOVLW  02
1C24:  MOVLB  3
1C26:  ADDWF  xAA,W
1C28:  MOVWF  01
1C2A:  MOVLW  00
1C2C:  ADDWFC xAB,W
1C2E:  MOVWF  03
1C30:  MOVFF  01,3AC
1C34:  MOVWF  xAD
1C36:  MOVLW  02
1C38:  ADDWF  xAA,W
1C3A:  MOVWF  FE9
1C3C:  MOVLW  00
1C3E:  ADDWFC xAB,W
1C40:  MOVWF  FEA
1C42:  MOVFF  FEC,3AF
1C46:  MOVF   FED,F
1C48:  MOVFF  FEF,3AE
1C4C:  MOVFF  3AF,3B1
1C50:  MOVFF  3AE,3B0
1C54:  MOVLB  0
1C56:  CALL   1146
1C5A:  MOVFF  3AD,FEA
1C5E:  MOVFF  3AC,FE9
1C62:  MOVFF  02,FEC
1C66:  MOVF   FED,F
1C68:  MOVFF  01,FEF
....................     h->Identification   = swaps(h->Identification); 
1C6C:  MOVLW  04
1C6E:  MOVLB  3
1C70:  ADDWF  xAA,W
1C72:  MOVWF  01
1C74:  MOVLW  00
1C76:  ADDWFC xAB,W
1C78:  MOVWF  03
1C7A:  MOVFF  01,3AC
1C7E:  MOVWF  xAD
1C80:  MOVLW  04
1C82:  ADDWF  xAA,W
1C84:  MOVWF  FE9
1C86:  MOVLW  00
1C88:  ADDWFC xAB,W
1C8A:  MOVWF  FEA
1C8C:  MOVFF  FEC,3AF
1C90:  MOVF   FED,F
1C92:  MOVFF  FEF,3AE
1C96:  MOVFF  3AF,3B1
1C9A:  MOVFF  3AE,3B0
1C9E:  MOVLB  0
1CA0:  CALL   1146
1CA4:  MOVFF  3AD,FEA
1CA8:  MOVFF  3AC,FE9
1CAC:  MOVFF  02,FEC
1CB0:  MOVF   FED,F
1CB2:  MOVFF  01,FEF
....................     h->HeaderChecksum   = swaps(h->HeaderChecksum); 
1CB6:  MOVLW  0A
1CB8:  MOVLB  3
1CBA:  ADDWF  xAA,W
1CBC:  MOVWF  01
1CBE:  MOVLW  00
1CC0:  ADDWFC xAB,W
1CC2:  MOVWF  03
1CC4:  MOVFF  01,3AC
1CC8:  MOVWF  xAD
1CCA:  MOVLW  0A
1CCC:  ADDWF  xAA,W
1CCE:  MOVWF  FE9
1CD0:  MOVLW  00
1CD2:  ADDWFC xAB,W
1CD4:  MOVWF  FEA
1CD6:  MOVFF  FEC,3AF
1CDA:  MOVF   FED,F
1CDC:  MOVFF  FEF,3AE
1CE0:  MOVFF  3AF,3B1
1CE4:  MOVFF  3AE,3B0
1CE8:  MOVLB  0
1CEA:  CALL   1146
1CEE:  MOVFF  3AD,FEA
1CF2:  MOVFF  3AC,FE9
1CF6:  MOVFF  02,FEC
1CFA:  MOVF   FED,F
1CFC:  MOVFF  01,FEF
.................... } 
1D00:  RETLW  00
....................  
....................  
.................... #if STACK_USE_TCP 
....................    #include "tcpip/tcp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  TCP Module for Microchip TCP/IP Stack 
....................  *               Based on RFC 793 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
.................... * FileName:        TCP.C 
.................... * Dependencies:    string.h 
.................... *                  StackTsk.h 
.................... *                  Helpers.h 
.................... *                  IP.h 
.................... *                  MAC.h 
.................... *                  ARP.h 
.................... *                  Tick.h 
.................... *                  TCP.h 
.................... * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
.................... * Complier:        CCS PCH 
.................... * Company:         Microchip Technology, Inc. 
.................... * 
.................... * Software License Agreement 
.................... * 
.................... * This software is owned by Microchip Technology Inc. ("Microchip") 
.................... * and is supplied to you for use exclusively as described in the 
.................... * associated software agreement.  This software is protected by 
.................... * software and other intellectual property laws.  Any use in 
.................... * violation of the software license may subject the user to criminal 
.................... * sanctions as well as civil liability.  Copyright 2006 Microchip 
.................... * Technology Inc.  All rights reserved. 
.................... * 
.................... * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
.................... * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
.................... * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
.................... * INFRINGEMENT.  Microchip shall in no event be liable for special, 
.................... * incidental, or consequential damages. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/8/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Nilesh Rajbharti     11/1/02 Fixed TCPTick() SYN Retry bug. 
....................  * Darren Rook (CCS)    06/28/04  Applied 2.20 fix (above) 
....................  * Darren Rook (CCS)    06/30/04 TCPTick() will not time out an establisehd socket if that socket is in server mode. 
....................  * Darren Rook (CCS)    07/02/04 A bug fix for change made on 06/28/04 
....................  * Darren Rook (CCS)    07/12/04 TCPConnect() will set StartTick to fix a bug with timeout 
....................  * Darren Rook (CCS)    07/12/04 TCPInit() attempts to make _NextPort a random number 
....................  * Darren Rook (CCS)    07/12/06 startTick spelled wrong (case) 
....................  * Nilesh Rajbharti     12/5/02   Modified TCPProcess() 
....................  *                              to include localIP as third param. 
....................  *                              This was done to allow this function 
....................  *                              to calculate checksum correctly. 
....................  * Roy Schofield      10/1/04   TCPConnect() startTick bug fix. 
....................  * Howard Schlunder      1/3/05   Fixed HandleTCPSeg() unexpected 
....................  *                         discard problem identified by Richard 
....................  *                         Shelquist. 
....................  * Howard Schlunder      1/16/06   Fixed an imporbable RX checksum bug 
....................  *                        when using a Microchip Ethernet controller) 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    09/18/06 Added TCPPutAvailable() 
....................  * Howard Schlunder      5/10/06   Revised TCP state machine, add TCP_FIN_2 
....................  * Howard Schlunder      8/01/06 Adjusted response to ACK only in TCP_SYN_SENT state 
....................  * Howard Schlunder      8/03/06 Fixed checksum comparison check 
....................  *                        reported by DouglasPunch on Microchip Forum. 
....................  * Howard Schlunder      8/11/06 Fixed a resource leak causing MAC TX 
....................  *                        Buffers to be obtained but not 
....................  *                        released when many web requests were 
....................  *                        received concurrently. 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8 *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8 *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               10 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/tcp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  TCP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCP.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
....................  * Complier:        CCS PCH 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip")  
....................  * and is supplied to you for use exclusively as described in the  
....................  * associated software agreement.  This software is protected by  
....................  * software and other intellectual property laws.  Any use in  
....................  * violation of the software license may subject the user to criminal  
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL  
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED  
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND  
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,  
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/8/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Nilesh Rajbharti     12/5/03 Modified TCPProcess() prototype. 
....................  *                              See TCP.c for more information. 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef TCP_H 
.................... #define TCP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               10 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... typedef BYTE TCP_SOCKET; 
.................... typedef WORD TCP_PORT; 
....................  
.................... #ifndef TCP_NO_WAIT_FOR_ACK 
....................    #define TCP_NO_WAIT_FOR_ACK   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * Maximum number of times a connection be retried before 
....................  * closing it down. 
....................  */ 
.................... #define MAX_RETRY_COUNTS    (3) 
....................  
.................... #define INVALID_SOCKET      (0xfe) 
.................... #define UNKNOWN_SOCKET      (0xff) 
....................  
.................... #define REMOTE_HOST(s)      (TCB[s].remote) 
....................  
.................... /* 
....................  * TCP States as defined by rfc793 
....................  */ 
.................... typedef enum _TCP_STATE 
.................... { 
....................     TCP_LISTEN = 0, 
....................     TCP_SYN_SENT, 
....................     TCP_SYN_RECEIVED, 
....................     TCP_ESTABLISHED, 
....................     TCP_FIN_WAIT_1, 
....................     TCP_FIN_WAIT_2, 
....................     TCP_CLOSING, 
....................     TCP_TIME_WAIT, 
.................... 	TCP_CLOSE_WAIT, 
....................     TCP_LAST_ACK, 
....................     TCP_CLOSED, 
.................... } TCP_STATE; 
....................  
.................... /* 
....................  * Socket info. 
....................  * Union is used to create anonymous structure members. 
....................  */ 
.................... typedef struct _SOCKET_INFO 
.................... { 
....................     TCP_STATE smState; 
....................  
....................     NODE_INFO remote; 
....................     TCP_PORT localPort; 
....................     TCP_PORT remotePort; 
....................  
....................     BUFFER TxBuffer; 
....................     WORD TxCount; 
....................     WORD RxCount; 
.................... 	WORD RemoteWindow; 
.................... 	 
....................     DWORD SND_SEQ; 
....................     DWORD SND_ACK; 
....................  
....................     BYTE RetryCount; 
....................     TICKTYPE startTick; 
....................     TICKTYPE TimeOut; 
....................  
....................     struct 
....................     { 
....................         int1 bServer        : 1; 
....................         int1 bIsPutReady    : 1; 
....................         int1 bFirstRead     : 1; 
....................         int1 bIsGetReady    : 1; 
....................         int1 bIsTxInProgress : 1; 
....................         int1 bACKValid : 1; 
....................     } Flags; 
....................  
.................... } SOCKET_INFO; 
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TCP is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initialize all socket info. 
....................  * 
....................  * Note:            This function is called only one during lifetime 
....................  *                  of the application. 
....................  ********************************************************************/ 
.................... void        TCPInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TCP_SOCKET TCPListen(TCP_PORT port) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           port    - A TCP port to be opened. 
....................  * 
....................  * Output:          Given port is opened and returned on success 
....................  *                  INVALID_SOCKET if no more sockets left. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TCP_SOCKET  TCPListen(TCP_PORT port); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TCP_SOCKET TCPConnect(NODE_INFO* remote, 
....................  *                                      TCP_PORT remotePort) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           remote      - Remote node address info 
....................  *                  remotePort  - remote port to be connected. 
....................  * 
....................  * Output:          A new socket is created, connection request is 
....................  *                  sent and socket handle is returned. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... TCP_SOCKET TCPConnect(NODE_INFO *remote, TCP_PORT port); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsConnected(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket to be checked for connection. 
....................  * 
....................  * Output:          TRUE    if given socket is connected 
....................  *                  FALSE   if given socket is not connected. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            A socket is said to be connected if it is not 
....................  *                  in LISTEN and CLOSED mode.  Socket may be in 
....................  *                  SYN_RCVD or FIN_WAIT_1 and may contain socket 
....................  *                  data. 
....................  ********************************************************************/ 
.................... BOOL        TCPIsConnected(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPDisconnect(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsPutReady(s) == TRUE 
....................  * 
....................  * Input:           s       - Socket to be disconnected. 
....................  * 
....................  * Output:          A disconnect request is sent for given socket. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void        TCPDisconnect(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsPutReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' is free to transmit 
....................  *                  FALSE if socket 's' is not free to transmit. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Each socket maintains only transmit buffer. 
....................  *                  Hence until a data packet is acknowledeged by 
....................  *                  remote node, socket will not be ready for 
....................  *                  next transmission. 
....................  *                  All control transmission such as Connect, 
....................  *                  Disconnect do not consume/reserve any transmit 
....................  *                  buffer. 
....................  ********************************************************************/ 
.................... BOOL        TCPIsPutReady(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPPut(TCP_SOCKET s, BYTE byte) 
....................  * 
....................  * PreCondition:    TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           s       - socket to use 
....................  *                  byte    - a data byte to send 
....................  * 
....................  * Output:          TRUE if given byte was put in transmit buffer 
....................  *                  FALSE if transmit buffer is full. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPPut(TCP_SOCKET socket, BYTE data); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPFlush(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket whose data is to be transmitted. 
....................  * 
....................  * Output:          All and any data associated with this socket 
....................  *                  is marked as ready for transmission. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPFlush(TCP_SOCKET socket); 
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsGetReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' contains any data. 
....................  *                  FALSE if socket 's' does not contain any data. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPIsGetReady(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPGet(TCP_SOCKET s, BYTE *byte) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  byte    - Pointer to a byte. 
....................  * 
....................  * Output:          TRUE if a byte was read. 
....................  *                  FALSE if byte was not read. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPGet(TCP_SOCKET socket, int8 *data); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD TCPGetArray(TCP_SOCKET s, BYTE *buffer, 
....................  *                                      WORD count) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  buffer  - Buffer to hold received data. 
....................  *                  count   - Buffer length 
....................  * 
....................  * Output:          Number of bytes loaded into buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... WORD        TCPGetArray(TCP_SOCKET s, BYTE *buff, WORD count); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPDiscard(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket 
....................  * 
....................  * Output:          TRUE if socket received data was discarded 
....................  *                  FALSE if socket received data was already 
....................  *                          discarded. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPDiscard(TCP_SOCKET socket); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPProcess(NODE_INFO* remote, 
....................  *                                  IP_ADDR *localIP, 
....................  *                                  WORD len) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCP segment is ready in MAC buffer 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  len         - Total length of TCP semgent. 
....................  * 
....................  * Output:          TRUE if this function has completed its task 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPProcess(NODE_INFO *remote, 
....................                        IP_ADDR *localIP, 
....................                        WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPTick(void) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Each socket FSM is executed for any timeout 
....................  *                  situation. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void        TCPTick(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #define debug_tcp(a,b,c,d,e,f,g,h,i,k,l,m,n,o,p,q,r,s,t,u) 
.................... //#define debug_tcp debug_printf 
....................  
.................... // Max TCP data length is MAC_TX_BUFFER_SIZE - sizeof(TCP_HEADER) - 
.................... // sizeof(IP_HEADER) - sizeof(ETHER_HEADER) 
.................... #define MAX_TCP_DATA_LEN    (MAC_TX_BUFFER_SIZE - 54) 
....................  
.................... // TCP Timeout value to begin with. 
.................... #define TCP_START_TIMEOUT_VAL   (TICKS_PER_SECOND * (TICKTYPE)3) 
....................  
.................... // TCP Flags defined in RFC 
.................... #define FIN     (0x01) 
.................... #define SYN     (0x02) 
.................... #define RST     (0x04) 
.................... #define PSH     (0x08) 
.................... #define ACK     (0x10) 
.................... #define URG     (0x20) 
....................  
....................  
.................... // TCP Header 
.................... typedef struct _TCP_HEADER 
.................... { 
....................     WORD    SourcePort; 
....................     WORD    DestPort; 
....................     DWORD   SeqNumber; 
....................     DWORD   AckNumber; 
....................  
....................     struct 
....................     { 
....................        BYTE Reserved3:4; 
....................        BYTE Val:4; 
....................     } DataOffset; 
....................  
....................  
....................     union 
....................     { 
....................         struct 
....................         { 
....................              int1 flagFIN    : 1; 
....................              int1 flagSYN    : 1; 
....................              int1 flagRST    : 1; 
....................              int1 flagPSH    : 1; 
....................              int1 flagACK    : 1; 
....................              int1 flagURG    : 1; 
....................              int1 Reserved2  : 2; 
....................         } bits; 
....................         BYTE b; 
....................     } Flags; 
....................  
....................     WORD    Window; 
....................     WORD    Checksum; 
....................     WORD    UrgentPointer; 
.................... } TCP_HEADER; 
....................  
....................  
.................... // TCP Options as defined by RFC 
.................... #define TCP_OPTIONS_END_OF_LIST     (0x00) 
.................... #define TCP_OPTIONS_NO_OP           (0x01) 
.................... #define TCP_OPTIONS_MAX_SEG_SIZE    (0x02) 
.................... typedef struct _TCP_OPTIONS 
.................... { 
....................     BYTE        Kind; 
....................     BYTE        Length; 
....................     WORD_VAL    MaxSegSize; 
.................... } TCP_OPTIONS; 
....................  
.................... #define SwapPseudoTCPHeader(h)  (h.TCPLength = swaps(h.TCPLength)) 
....................  
.................... // IP pseudo header as defined by RFC 793 
.................... typedef struct _PSEUDO_HEADER 
.................... { 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................     BYTE Zero; 
....................     BYTE Protocol; 
....................     WORD TCPLength; 
.................... } PSEUDO_HEADER; 
....................  
.................... #define LOCAL_PORT_START_NUMBER (1024) 
.................... #define LOCAL_PORT_END_NUMBER   (5000) 
....................  
.................... // Local temp port numbers. 
.................... static WORD _NextPort = LOCAL_PORT_START_NUMBER; 
....................  
.................... // The TCB array is very large.  With the C18 compiler, one must 
.................... // modify the linker script to make an array that spans more than 
.................... // one memory bank.  To do this, make the necessary changes to your 
.................... // processor's linker script (.lkr).  Here is an example showing 
.................... // gpr11 and 128 bytes of gpr12 being combined into one 384 byte 
.................... // block used exclusively by the TCB_MEM data section: 
.................... // ... 
.................... // //DATABANK   NAME=gpr11      START=0xB00          END=0xBFF 
.................... // //DATABANK   NAME=gpr12      START=0xC00          END=0xCFF 
.................... // DATABANK   NAME=gpr11b     START=0xB00          END=0xC7F           PROTECTED 
.................... // DATABANK   NAME=gpr12      START=0xC80          END=0xCFF 
.................... // ... 
.................... // SECTION    NAME=TCB_MEM    RAM=gpr11b 
.................... // ... 
.................... //#pragma udata TCB_MEM   //not needed in ccs 
.................... SOCKET_INFO TCB[MAX_SOCKETS]; 
.................... //   #pragma udata bla   // Return to any other RAM section   //not needed in ccs 
....................  
.................... static void    HandleTCPSeg(TCP_SOCKET s, 
....................                                NODE_INFO *remote, 
....................                                TCP_HEADER *h, 
....................                                WORD len); 
....................  
.................... static void TransmitTCP(NODE_INFO *remote, 
....................                         TCP_PORT localPort, 
....................                         TCP_PORT remotePort, 
....................                         DWORD tseq, 
....................                         DWORD tack, 
....................                         BYTE flags, 
....................                         BUFFER buff, 
....................                         WORD len); 
....................  
.................... static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, 
....................                                     NODE_INFO *remote); 
.................... static void    SwapTCPHeader(TCP_HEADER* header); 
.................... static void CloseSocket(SOCKET_INFO* ps); 
....................  
.................... #define SendTCP(remote, localPort, remotePort, seq, ack, flags)     \ 
....................         TransmitTCP(remote, localPort, remotePort, seq, ack, flags, \ 
....................                     INVALID_BUFFER, 0) 
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        void TCPInit(void) 
.................... * 
.................... * PreCondition:    None 
.................... * 
.................... * Input:           None 
.................... * 
.................... * Output:          TCP is initialized. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        Initialize all socket states 
.................... * 
.................... * Note:            This function is called only once during lifetime 
.................... *                  of the application. 
.................... ********************************************************************/ 
.................... int16 TCPInit_RandSeed; 
.................... void TCPInit(void) 
.................... { 
....................     TCP_SOCKET s; 
....................     SOCKET_INFO* ps; 
....................  
....................  
....................     // Initialize all sockets. 
....................     for ( s = 0; s < MAX_SOCKETS; s++ ) 
*
0DB4:  MOVLB  3
0DB6:  CLRF   x02
0DB8:  MOVF   x02,W
0DBA:  SUBLW  04
0DBC:  BNC   0E90
....................     { 
....................         ps = &TCB[s]; 
0DBE:  MOVF   x02,W
0DC0:  MULLW  24
0DC2:  MOVF   FF3,W
0DC4:  CLRF   03
0DC6:  ADDLW  5F
0DC8:  MOVWF  01
0DCA:  MOVLW  00
0DCC:  ADDWFC 03,F
0DCE:  MOVFF  01,303
0DD2:  MOVFF  03,304
....................  
....................         ps->smState             = TCP_CLOSED; 
0DD6:  MOVFF  303,FE9
0DDA:  MOVFF  304,FEA
0DDE:  MOVLW  0A
0DE0:  MOVWF  FEF
....................         ps->Flags.bServer       = FALSE; 
0DE2:  MOVLW  23
0DE4:  ADDWF  x03,W
0DE6:  MOVWF  FE9
0DE8:  MOVLW  00
0DEA:  ADDWFC x04,W
0DEC:  MOVWF  FEA
0DEE:  BCF    FEF.0
....................         ps->Flags.bIsPutReady   = TRUE; 
0DF0:  MOVLW  23
0DF2:  ADDWF  x03,W
0DF4:  MOVWF  FE9
0DF6:  MOVLW  00
0DF8:  ADDWFC x04,W
0DFA:  MOVWF  FEA
0DFC:  BSF    FEF.1
....................         ps->Flags.bFirstRead    = TRUE; 
0DFE:  MOVLW  23
0E00:  ADDWF  x03,W
0E02:  MOVWF  FE9
0E04:  MOVLW  00
0E06:  ADDWFC x04,W
0E08:  MOVWF  FEA
0E0A:  BSF    FEF.2
....................         ps->Flags.bIsTxInProgress = FALSE; 
0E0C:  MOVLW  23
0E0E:  ADDWF  x03,W
0E10:  MOVWF  FE9
0E12:  MOVLW  00
0E14:  ADDWFC x04,W
0E16:  MOVWF  FEA
0E18:  BCF    FEF.4
....................         ps->Flags.bIsGetReady   = FALSE; 
0E1A:  MOVLW  23
0E1C:  ADDWF  x03,W
0E1E:  MOVWF  FE9
0E20:  MOVLW  00
0E22:  ADDWFC x04,W
0E24:  MOVWF  FEA
0E26:  BCF    FEF.3
....................       if(ps->TxBuffer != INVALID_BUFFER) 
0E28:  MOVLW  0F
0E2A:  ADDWF  x03,W
0E2C:  MOVWF  FE9
0E2E:  MOVLW  00
0E30:  ADDWFC x04,W
0E32:  MOVWF  FEA
0E34:  INCFSZ FEF,W
0E36:  BRA    0E3A
0E38:  BRA    0E66
....................       { 
....................          MACDiscardTx(ps->TxBuffer); 
0E3A:  MOVLW  0F
0E3C:  ADDWF  x03,W
0E3E:  MOVWF  FE9
0E40:  MOVLW  00
0E42:  ADDWFC x04,W
0E44:  MOVWF  FEA
0E46:  MOVFF  FEF,305
0E4A:  MOVFF  305,355
0E4E:  MOVLB  0
0E50:  CALL   0004
....................          ps->TxBuffer        = INVALID_BUFFER; 
0E54:  MOVLW  0F
0E56:  MOVLB  3
0E58:  ADDWF  x03,W
0E5A:  MOVWF  FE9
0E5C:  MOVLW  00
0E5E:  ADDWFC x04,W
0E60:  MOVWF  FEA
0E62:  MOVLW  FF
0E64:  MOVWF  FEF
....................       } 
....................         ps->TimeOut             = TCP_START_TIMEOUT_VAL; 
0E66:  MOVLW  21
0E68:  ADDWF  x03,W
0E6A:  MOVWF  FE9
0E6C:  MOVLW  00
0E6E:  ADDWFC x04,W
0E70:  MOVWF  FEA
0E72:  CLRF   FEC
0E74:  MOVF   FED,F
0E76:  MOVLW  1E
0E78:  MOVWF  FEF
....................       ps->TxCount            = 0; 
0E7A:  MOVLW  10
0E7C:  ADDWF  x03,W
0E7E:  MOVWF  FE9
0E80:  MOVLW  00
0E82:  ADDWFC x04,W
0E84:  MOVWF  FEA
0E86:  CLRF   FEC
0E88:  MOVF   FED,F
0E8A:  CLRF   FEF
....................    } 
....................  
....................     //_NextPort = LOCAL_PORT_START_NUMBER; 
....................     #if getenv("TIMER0") 
0E8C:  INCF   x02,F
0E8E:  BRA    0DB8
....................     TCPInit_RandSeed+=get_timer0(); 
0E90:  MOVF   FD6,W
0E92:  MOVLB  1
0E94:  ADDWF  x13,F
0E96:  MOVF   FD7,W
0E98:  ADDWFC x14,F
....................     #endif 
....................     #if getenv("TIMER1") 
....................      TCPInit_RandSeed+=get_timer1(); 
0E9A:  MOVF   FCE,W
0E9C:  ADDWF  x13,F
0E9E:  MOVF   FCF,W
0EA0:  ADDWFC x14,F
....................     #endif 
....................     #if getenv("TIMER2") 
....................      TCPInit_RandSeed+=get_timer2(); 
0EA2:  MOVF   FCC,W
0EA4:  ADDWF  x13,F
0EA6:  MOVLW  00
0EA8:  ADDWFC x14,F
....................     #endif 
....................     #if getenv("TIMER3") 
....................      TCPInit_RandSeed+=get_timer3(); 
0EAA:  MOVF   FB2,W
0EAC:  ADDWF  x13,F
0EAE:  MOVF   FB3,W
0EB0:  ADDWFC x14,F
....................     #endif 
....................     #if getenv("TIMER4") 
....................      TCPInit_RandSeed+=get_timer4(); 
....................     #endif 
....................     #if getenv("TIMER5") 
....................      TCPInit_RandSeed+=get_timer5(); 
....................     #endif 
....................     srand(TCPInit_RandSeed); 
0EB2:  MOVLB  3
0EB4:  CLRF   x08
0EB6:  CLRF   x07
0EB8:  MOVFF  114,306
0EBC:  MOVFF  113,305
0EC0:  MOVLB  0
0EC2:  BRA    0C86
....................     _NextPort=rand(); 
0EC4:  BRA    0D40
0EC6:  MOVFF  02,5E
0ECA:  MOVFF  01,5D
....................     _NextPort+=LOCAL_PORT_START_NUMBER; 
0ECE:  MOVLW  04
0ED0:  ADDWF  5E,F
....................     while (_NextPort >= LOCAL_PORT_END_NUMBER) {_NextPort-=LOCAL_PORT_END_NUMBER;} 
0ED2:  MOVF   5E,W
0ED4:  SUBLW  12
0ED6:  BC    0EEC
0ED8:  XORLW  FF
0EDA:  BNZ   0EE2
0EDC:  MOVF   5D,W
0EDE:  SUBLW  87
0EE0:  BC    0EEC
0EE2:  MOVLW  88
0EE4:  SUBWF  5D,F
0EE6:  MOVLW  13
0EE8:  SUBWFB 5E,F
0EEA:  BRA    0ED2
....................     if (_NextPort < LOCAL_PORT_START_NUMBER) {_NextPort+=LOCAL_PORT_START_NUMBER;} 
0EEC:  MOVF   5E,W
0EEE:  SUBLW  03
0EF0:  BNC   0EF6
0EF2:  MOVLW  04
0EF4:  ADDWF  5E,F
.................... } 
0EF6:  GOTO   1070 (RETURN)
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        TCP_SOCKET TCPListen(TCP_PORT port) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           port    - A TCP port to be opened. 
.................... * 
.................... * Output:          Given port is opened and returned on success 
.................... *                  INVALID_SOCKET if no more sockets left. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... TCP_SOCKET TCPListen(TCP_PORT port) 
.................... { 
....................    TCP_SOCKET s; 
....................    SOCKET_INFO* ps; 
....................  
....................    debug_tcp("\r\nTCP LISTEN PORT=%LU -> ", port); 
....................  
....................    for(s = 0; s < MAX_SOCKETS; s++) 
0EFA:  MOVLB  3
0EFC:  CLRF   x07
0EFE:  MOVF   x07,W
0F00:  SUBLW  04
0F02:  BNC   0FEC
....................    { 
....................       ps = &TCB[s]; 
0F04:  MOVF   x07,W
0F06:  MULLW  24
0F08:  MOVF   FF3,W
0F0A:  CLRF   03
0F0C:  ADDLW  5F
0F0E:  MOVWF  01
0F10:  MOVLW  00
0F12:  ADDWFC 03,F
0F14:  MOVFF  01,308
0F18:  MOVFF  03,309
....................  
....................       if(ps->smState == TCP_CLOSED) 
0F1C:  MOVFF  308,FE9
0F20:  MOVFF  309,FEA
0F24:  MOVF   FEF,W
0F26:  SUBLW  0A
0F28:  BNZ   0FE8
....................       { 
....................          // We have a CLOSED socket. 
....................          // Initialize it with LISTENing state info. 
....................          ps->smState             = TCP_LISTEN; 
0F2A:  MOVFF  308,FE9
0F2E:  MOVFF  309,FEA
0F32:  CLRF   FEF
....................          ps->localPort           = port; 
0F34:  MOVLW  0B
0F36:  ADDWF  x08,W
0F38:  MOVWF  FE9
0F3A:  MOVLW  00
0F3C:  ADDWFC x09,W
0F3E:  MOVWF  FEA
0F40:  MOVFF  306,FEC
0F44:  MOVF   FED,F
0F46:  MOVFF  305,FEF
....................          ps->remotePort          = 0; 
0F4A:  MOVLW  0D
0F4C:  ADDWF  x08,W
0F4E:  MOVWF  FE9
0F50:  MOVLW  00
0F52:  ADDWFC x09,W
0F54:  MOVWF  FEA
0F56:  CLRF   FEC
0F58:  MOVF   FED,F
0F5A:  CLRF   FEF
....................  
....................          // There is no remote node IP address info yet. 
....................          ps->remote.IPAddr.Val   = 0x00; 
0F5C:  MOVLW  07
0F5E:  ADDWF  x08,W
0F60:  MOVWF  FE9
0F62:  MOVLW  00
0F64:  ADDWFC x09,W
0F66:  MOVWF  FEA
0F68:  MOVF   FEE,F
0F6A:  MOVF   FEE,F
0F6C:  CLRF   FEC
0F6E:  MOVF   FED,F
0F70:  CLRF   FEF
0F72:  MOVF   FED,F
0F74:  CLRF   FEF
0F76:  MOVF   FED,F
0F78:  CLRF   FEF
....................  
....................          // If a socket is listened on, it is a SERVER. 
....................          ps->Flags.bServer       = TRUE; 
0F7A:  MOVLW  23
0F7C:  ADDWF  x08,W
0F7E:  MOVWF  FE9
0F80:  MOVLW  00
0F82:  ADDWFC x09,W
0F84:  MOVWF  FEA
0F86:  BSF    FEF.0
....................  
....................          ps->Flags.bIsGetReady   = FALSE; 
0F88:  MOVLW  23
0F8A:  ADDWF  x08,W
0F8C:  MOVWF  FE9
0F8E:  MOVLW  00
0F90:  ADDWFC x09,W
0F92:  MOVWF  FEA
0F94:  BCF    FEF.3
....................          if(ps->TxBuffer != INVALID_BUFFER) 
0F96:  MOVLW  0F
0F98:  ADDWF  x08,W
0F9A:  MOVWF  FE9
0F9C:  MOVLW  00
0F9E:  ADDWFC x09,W
0FA0:  MOVWF  FEA
0FA2:  INCFSZ FEF,W
0FA4:  BRA    0FA8
0FA6:  BRA    0FD4
....................          { 
....................             MACDiscardTx(ps->TxBuffer); 
0FA8:  MOVLW  0F
0FAA:  ADDWF  x08,W
0FAC:  MOVWF  FE9
0FAE:  MOVLW  00
0FB0:  ADDWFC x09,W
0FB2:  MOVWF  FEA
0FB4:  MOVFF  FEF,30A
0FB8:  MOVFF  30A,355
0FBC:  MOVLB  0
0FBE:  CALL   0004
....................             ps->TxBuffer        = INVALID_BUFFER; 
0FC2:  MOVLW  0F
0FC4:  MOVLB  3
0FC6:  ADDWF  x08,W
0FC8:  MOVWF  FE9
0FCA:  MOVLW  00
0FCC:  ADDWFC x09,W
0FCE:  MOVWF  FEA
0FD0:  MOVLW  FF
0FD2:  MOVWF  FEF
....................          } 
....................          ps->Flags.bIsPutReady   = TRUE; 
0FD4:  MOVLW  23
0FD6:  ADDWF  x08,W
0FD8:  MOVWF  FE9
0FDA:  MOVLW  00
0FDC:  ADDWFC x09,W
0FDE:  MOVWF  FEA
0FE0:  BSF    FEF.1
....................  
....................          debug_tcp("SOCK=%U", s); 
....................  
....................          return s; 
0FE2:  MOVFF  307,01
0FE6:  BRA    0FF0
....................       } 
....................    } 
0FE8:  INCF   x07,F
0FEA:  BRA    0EFE
....................  
....................    debug_tcp("FAIL"); 
....................  
....................    return INVALID_SOCKET; 
0FEC:  MOVLW  FE
0FEE:  MOVWF  01
.................... } 
0FF0:  MOVLB  0
0FF2:  GOTO   101C (RETURN)
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        TCP_SOCKET TCPConnect(NODE_INFO* remote, 
.................... *                                      TCP_PORT remotePort) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           remote      - Remote node address info 
.................... *                  remotePort  - remote port to be connected. 
.................... * 
.................... * Output:          A new socket is created, connection request is 
.................... *                  sent and socket handle is returned. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... ********************************************************************/ 
.................... TCP_SOCKET TCPConnect(NODE_INFO *remote, TCP_PORT remotePort) 
.................... { 
....................    TCP_SOCKET s; 
....................    SOCKET_INFO* ps; 
....................    BOOL lbFound; 
....................  
....................  
....................    lbFound = FALSE; 
....................  
....................    debug_tcp("\r\nTCP CONNECT PORT=%LU -> ", remotePort); 
....................  
....................    // Find an available socket 
....................    for(s = 0; s < MAX_SOCKETS; s++) 
....................    { 
....................       ps = &TCB[s]; 
....................       if(ps->smState == TCP_CLOSED) 
....................       { 
....................          lbFound = TRUE; 
....................          break; 
....................       } 
....................    } 
....................  
....................    // If there is no socket available, return error. 
....................    if(!lbFound) 
....................       return INVALID_SOCKET; 
....................  
....................    // Each new socket that is opened by this node, gets 
....................    // next sequential port number. 
....................    ps->localPort = ++_NextPort; 
....................    if(_NextPort >= LOCAL_PORT_END_NUMBER) 
....................       _NextPort = LOCAL_PORT_START_NUMBER-1; 
....................  
....................    // This is a client socket. 
....................    ps->Flags.bServer = FALSE; 
....................  
....................    // This is the port, we are trying to connect to. 
....................    ps->remotePort = remotePort; 
....................  
....................    // Each new socket that is opened by this node, will 
....................    // start with next the next seqeuence number (essentially random) 
....................    ps->SND_SEQ++; 
....................    ps->SND_ACK = 0; 
....................  
....................    memcpy((BYTE*)&ps->remote, (void*)remote, sizeof(ps->remote)); 
....................  
....................    // Send SYN message. 
....................    SendTCP(&ps->remote, 
....................       ps->localPort, 
....................       ps->remotePort, 
....................       ps->SND_SEQ, 
....................       ps->SND_ACK, 
....................       SYN); 
....................  
....................    ps->smState = TCP_SYN_SENT; 
....................    ps->SND_SEQ++; 
....................  
....................    // Allow TCPTick() to operate properly 
....................    ps->startTick = TickGet(); 
....................  
....................    debug_tcp("SOCK=%U", s); 
....................  
....................    return s; 
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsConnected(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket to be checked for connection. 
....................  * 
....................  * Output:          TRUE    if given socket is connected 
....................  *                  FALSE   if given socket is not connected. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            A socket is said to be connected if it is not 
....................  *                  in LISTEN and CLOSED mode.  Socket may be in 
....................  *                  SYN_RCVD or FIN_WAIT_1 and may contain socket 
....................  *                  data. 
....................  ********************************************************************/ 
.................... BOOL TCPIsConnected(TCP_SOCKET s) 
.................... { 
....................     return ( TCB[s].smState == TCP_ESTABLISHED ); 
*
3F6A:  MOVLB  3
3F6C:  MOVF   x10,W
3F6E:  MULLW  24
3F70:  MOVF   FF3,W
3F72:  CLRF   x12
3F74:  MOVWF  x11
3F76:  MOVLW  5F
3F78:  ADDWF  x11,W
3F7A:  MOVWF  FE9
3F7C:  MOVLW  00
3F7E:  ADDWFC x12,W
3F80:  MOVWF  FEA
3F82:  MOVF   FEF,W
3F84:  SUBLW  03
3F86:  BZ    3F8C
3F88:  MOVLW  00
3F8A:  BRA    3F8E
3F8C:  MOVLW  01
3F8E:  MOVWF  01
.................... } 
3F90:  MOVLB  0
3F92:  RETLW  00
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        void TCPDisconnect(TCP_SOCKET s) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCPIsPutReady(s) == TRUE 
.................... * 
.................... * Input:           s       - Socket to be disconnected. 
.................... * 
.................... * Output:          A disconnect request is sent for given socket. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... void TCPDisconnect(TCP_SOCKET s) 
.................... { 
....................    SOCKET_INFO *ps; 
....................  
....................    ps = &TCB[s]; 
*
5D98:  MOVLB  3
5D9A:  MOVF   x10,W
5D9C:  MULLW  24
5D9E:  MOVF   FF3,W
5DA0:  CLRF   03
5DA2:  ADDLW  5F
5DA4:  MOVWF  01
5DA6:  MOVLW  00
5DA8:  ADDWFC 03,F
5DAA:  MOVFF  01,311
5DAE:  MOVFF  03,312
....................  
....................    // If socket is not connected, may be it is already closed 
....................    // or in the process of closing.  Since we have called this 
....................    // explicitly, close it forcefully. 
....................    if(ps->smState != TCP_ESTABLISHED && ps->smState != TCP_SYN_RECEIVED) 
5DB2:  MOVFF  311,FE9
5DB6:  MOVFF  312,FEA
5DBA:  MOVF   FEF,W
5DBC:  SUBLW  03
5DBE:  BZ    5DDE
5DC0:  MOVFF  311,FE9
5DC4:  MOVFF  312,FEA
5DC8:  MOVF   FEF,W
5DCA:  SUBLW  02
5DCC:  BZ    5DDE
....................    { 
....................       CloseSocket(ps); 
5DCE:  MOVFF  312,353
5DD2:  MOVFF  311,352
5DD6:  MOVLB  0
5DD8:  CALL   24AE
....................       return; 
5DDC:  BRA    5ED4
....................    } 
....................  
....................    // Discard any outstanding data that is to be read. 
....................    TCPDiscard(s); 
5DDE:  MOVFF  310,313
5DE2:  MOVLB  0
5DE4:  CALL   4F68
....................  
....................    // Send FIN message. 
....................    SendTCP(&ps->remote, 
....................       ps->localPort, 
....................       ps->remotePort, 
....................       ps->SND_SEQ, 
....................       ps->SND_ACK, 
....................       FIN | ACK); 
5DE8:  MOVLW  01
5DEA:  MOVLB  3
5DEC:  ADDWF  x11,W
5DEE:  MOVWF  01
5DF0:  MOVLW  00
5DF2:  ADDWFC x12,W
5DF4:  MOVWF  03
5DF6:  MOVFF  01,313
5DFA:  MOVWF  x14
5DFC:  MOVLW  0B
5DFE:  ADDWF  x11,W
5E00:  MOVWF  FE9
5E02:  MOVLW  00
5E04:  ADDWFC x12,W
5E06:  MOVWF  FEA
5E08:  MOVFF  FEC,316
5E0C:  MOVF   FED,F
5E0E:  MOVFF  FEF,315
5E12:  MOVLW  0D
5E14:  ADDWF  x11,W
5E16:  MOVWF  FE9
5E18:  MOVLW  00
5E1A:  ADDWFC x12,W
5E1C:  MOVWF  FEA
5E1E:  MOVFF  FEC,318
5E22:  MOVF   FED,F
5E24:  MOVFF  FEF,317
5E28:  MOVLW  16
5E2A:  ADDWF  x11,W
5E2C:  MOVWF  FE9
5E2E:  MOVLW  00
5E30:  ADDWFC x12,W
5E32:  MOVWF  FEA
5E34:  MOVFF  FEF,319
5E38:  MOVFF  FEC,31A
5E3C:  MOVFF  FEC,31B
5E40:  MOVFF  FEC,31C
5E44:  MOVLW  1A
5E46:  ADDWF  x11,W
5E48:  MOVWF  FE9
5E4A:  MOVLW  00
5E4C:  ADDWFC x12,W
5E4E:  MOVWF  FEA
5E50:  MOVFF  FEF,31D
5E54:  MOVFF  FEC,31E
5E58:  MOVFF  FEC,31F
5E5C:  MOVFF  FEC,320
5E60:  MOVFF  03,35A
5E64:  MOVFF  01,359
5E68:  MOVFF  316,35C
5E6C:  MOVFF  315,35B
5E70:  MOVFF  318,35E
5E74:  MOVFF  317,35D
5E78:  MOVFF  31C,362
5E7C:  MOVFF  31B,361
5E80:  MOVFF  31A,360
5E84:  MOVFF  319,35F
5E88:  MOVFF  320,366
5E8C:  MOVFF  31F,365
5E90:  MOVFF  31E,364
5E94:  MOVFF  31D,363
5E98:  MOVLW  11
5E9A:  MOVWF  x67
5E9C:  MOVLW  FF
5E9E:  MOVWF  x68
5EA0:  CLRF   x6A
5EA2:  CLRF   x69
5EA4:  MOVLB  0
5EA6:  CALL   28FA
....................    //DebugPrint("."); 
....................  
....................    ps->SND_SEQ++; 
5EAA:  MOVLW  16
5EAC:  MOVLB  3
5EAE:  ADDWF  x11,W
5EB0:  MOVWF  FE9
5EB2:  MOVLW  00
5EB4:  ADDWFC x12,W
5EB6:  MOVWF  FEA
5EB8:  MOVLW  01
5EBA:  ADDWF  FEE,F
5EBC:  BNZ   5EC8
5EBE:  INCF   FEE,F
5EC0:  BNZ   5EC8
5EC2:  INCF   FEE,F
5EC4:  BNZ   5EC8
5EC6:  INCF   FED,F
....................  
....................    ps->smState = TCP_FIN_WAIT_1; 
5EC8:  MOVFF  311,FE9
5ECC:  MOVFF  312,FEA
5ED0:  MOVLW  04
5ED2:  MOVWF  FEF
5ED4:  MOVLB  0
....................  
....................    return; 
.................... } 
5ED6:  GOTO   6B14 (RETURN)
....................  
.................... /********************************************************************* 
.................... * Function:        BOOL TCPFlush(TCP_SOCKET s) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           s       - Socket whose data is to be transmitted. 
.................... * 
.................... * Output:          All and any data associated with this socket 
.................... *                  is marked as ready for transmission. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... BOOL TCPFlush(TCP_SOCKET s) 
.................... { 
....................    SOCKET_INFO *ps; 
....................  
....................    ps = &TCB[s]; 
*
5060:  MOVLB  3
5062:  MOVF   x45,W
5064:  MULLW  24
5066:  MOVF   FF3,W
5068:  CLRF   03
506A:  ADDLW  5F
506C:  MOVWF  01
506E:  MOVLW  00
5070:  ADDWFC 03,F
5072:  MOVFF  01,346
5076:  MOVFF  03,347
....................  
....................    // Make sure that there is TxBuffer assigned to this socket. 
....................    if ( ps->TxBuffer == INVALID_BUFFER ) 
507A:  MOVLW  0F
507C:  ADDWF  x46,W
507E:  MOVWF  FE9
5080:  MOVLW  00
5082:  ADDWFC x47,W
5084:  MOVWF  FEA
5086:  INCFSZ FEF,W
5088:  BRA    5090
....................       return FALSE; 
508A:  MOVLW  00
508C:  MOVWF  01
508E:  BRA    5226
....................  
....................    if ( ps->Flags.bIsPutReady == FALSE ) 
5090:  MOVLW  23
5092:  ADDWF  x46,W
5094:  MOVWF  FE9
5096:  MOVLW  00
5098:  ADDWFC x47,W
509A:  MOVWF  FEA
509C:  MOVLW  00
509E:  BTFSC  FEF.1
50A0:  MOVLW  01
50A2:  ANDLW  01
50A4:  BNZ   50AC
....................       return FALSE; 
50A6:  MOVLW  00
50A8:  MOVWF  01
50AA:  BRA    5226
....................  
....................    TransmitTCP(&ps->remote, 
....................       ps->localPort, 
....................       ps->remotePort, 
....................       ps->SND_SEQ, 
....................       ps->SND_ACK, 
....................       ACK + PSH,      // Use PSH to make sure the end application receives the data right away 
....................       ps->TxBuffer, 
....................       ps->TxCount); 
50AC:  MOVLW  01
50AE:  ADDWF  x46,W
50B0:  MOVWF  01
50B2:  MOVLW  00
50B4:  ADDWFC x47,W
50B6:  MOVWF  03
50B8:  MOVFF  01,348
50BC:  MOVWF  x49
50BE:  MOVLW  0B
50C0:  ADDWF  x46,W
50C2:  MOVWF  FE9
50C4:  MOVLW  00
50C6:  ADDWFC x47,W
50C8:  MOVWF  FEA
50CA:  MOVFF  FEC,34B
50CE:  MOVF   FED,F
50D0:  MOVFF  FEF,34A
50D4:  MOVLW  0D
50D6:  ADDWF  x46,W
50D8:  MOVWF  FE9
50DA:  MOVLW  00
50DC:  ADDWFC x47,W
50DE:  MOVWF  FEA
50E0:  MOVFF  FEC,34D
50E4:  MOVF   FED,F
50E6:  MOVFF  FEF,34C
50EA:  MOVLW  16
50EC:  ADDWF  x46,W
50EE:  MOVWF  FE9
50F0:  MOVLW  00
50F2:  ADDWFC x47,W
50F4:  MOVWF  FEA
50F6:  MOVFF  FEF,34E
50FA:  MOVFF  FEC,34F
50FE:  MOVFF  FEC,350
5102:  MOVFF  FEC,351
5106:  MOVLW  1A
5108:  ADDWF  x46,W
510A:  MOVWF  FE9
510C:  MOVLW  00
510E:  ADDWFC x47,W
5110:  MOVWF  FEA
5112:  MOVFF  FEF,352
5116:  MOVFF  FEC,353
511A:  MOVFF  FEC,354
511E:  MOVFF  FEC,355
5122:  MOVLW  0F
5124:  ADDWF  x46,W
5126:  MOVWF  FE9
5128:  MOVLW  00
512A:  ADDWFC x47,W
512C:  MOVWF  FEA
512E:  MOVFF  FEF,356
5132:  MOVLW  10
5134:  ADDWF  x46,W
5136:  MOVWF  FE9
5138:  MOVLW  00
513A:  ADDWFC x47,W
513C:  MOVWF  FEA
513E:  MOVFF  FEC,358
5142:  MOVF   FED,F
5144:  MOVFF  FEF,357
5148:  MOVFF  03,35A
514C:  MOVFF  01,359
5150:  MOVFF  34B,35C
5154:  MOVFF  34A,35B
5158:  MOVFF  34D,35E
515C:  MOVFF  34C,35D
5160:  MOVFF  351,362
5164:  MOVFF  350,361
5168:  MOVFF  34F,360
516C:  MOVFF  34E,35F
5170:  MOVFF  355,366
5174:  MOVFF  354,365
5178:  MOVFF  353,364
517C:  MOVFF  352,363
5180:  MOVLW  18
5182:  MOVWF  x67
5184:  MOVFF  356,368
5188:  MOVFF  358,36A
518C:  MOVFF  357,369
5190:  MOVLB  0
5192:  CALL   28FA
....................  
....................    ps->SND_SEQ += (DWORD)ps->TxCount; 
5196:  MOVLW  16
5198:  MOVLB  3
519A:  ADDWF  x46,W
519C:  MOVWF  01
519E:  MOVLW  00
51A0:  ADDWFC x47,W
51A2:  MOVWF  03
51A4:  MOVFF  01,348
51A8:  MOVWF  x49
51AA:  MOVWF  FEA
51AC:  MOVFF  01,FE9
51B0:  MOVFF  FEF,34A
51B4:  MOVFF  FEC,34B
51B8:  MOVFF  FEC,34C
51BC:  MOVFF  FEC,34D
51C0:  MOVLW  10
51C2:  ADDWF  x46,W
51C4:  MOVWF  FE9
51C6:  MOVLW  00
51C8:  ADDWFC x47,W
51CA:  MOVWF  FEA
51CC:  MOVFF  FEC,03
51D0:  MOVF   FED,F
51D2:  MOVFF  FEF,00
51D6:  MOVFF  03,01
51DA:  CLRF   02
51DC:  CLRF   03
51DE:  MOVF   x4A,W
51E0:  ADDWF  00,F
51E2:  MOVF   x4B,W
51E4:  ADDWFC 01,F
51E6:  MOVF   x4C,W
51E8:  ADDWFC 02,F
51EA:  MOVF   x4D,W
51EC:  ADDWFC 03,F
51EE:  MOVFF  349,FEA
51F2:  MOVFF  348,FE9
51F6:  MOVFF  00,FEF
51FA:  MOVFF  01,FEC
51FE:  MOVFF  02,FEC
5202:  MOVFF  03,FEC
....................    ps->Flags.bIsPutReady       = FALSE; 
5206:  MOVLW  23
5208:  ADDWF  x46,W
520A:  MOVWF  FE9
520C:  MOVLW  00
520E:  ADDWFC x47,W
5210:  MOVWF  FEA
5212:  BCF    FEF.1
....................    ps->Flags.bIsTxInProgress   = FALSE; 
5214:  MOVLW  23
5216:  ADDWF  x46,W
5218:  MOVWF  FE9
521A:  MOVLW  00
521C:  ADDWFC x47,W
521E:  MOVWF  FEA
5220:  BCF    FEF.4
....................  
.................... #if TCP_NO_WAIT_FOR_ACK 
....................    if(ps->TxBuffer != INVALID_BUFFER) 
....................    { 
....................       MACDiscardTx(ps->TxBuffer); 
....................       ps->TxBuffer        = INVALID_BUFFER; 
....................    } 
....................    ps->Flags.bIsPutReady       = TRUE; 
.................... #endif 
....................  
....................    return TRUE; 
5222:  MOVLW  01
5224:  MOVWF  01
.................... } 
5226:  MOVLB  0
5228:  RETLW  00
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsPutReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' is free to transmit 
....................  *                  FALSE if socket 's' is not free to transmit. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Each socket maintains only transmit buffer. 
....................  *                  Hence until a data packet is acknowledeged by 
....................  *                  remote node, socket will not be ready for 
....................  *                  next transmission. 
....................  *                  All control transmission such as Connect, 
....................  *                  Disconnect do not consume/reserve any transmit 
....................  *                  buffer. 
....................  ********************************************************************/ 
.................... BOOL TCPIsPutReady(TCP_SOCKET s) 
.................... { 
....................    if(TCB[s].RemoteWindow == 0) 
*
4FB6:  MOVLB  3
4FB8:  MOVF   x33,W
4FBA:  MULLW  24
4FBC:  MOVF   FF3,W
4FBE:  CLRF   x35
4FC0:  MOVWF  x34
4FC2:  MOVLW  14
4FC4:  ADDWF  x34,W
4FC6:  MOVWF  01
4FC8:  MOVLW  00
4FCA:  ADDWFC x35,W
4FCC:  MOVWF  03
4FCE:  MOVF   01,W
4FD0:  ADDLW  5F
4FD2:  MOVWF  FE9
4FD4:  MOVLW  00
4FD6:  ADDWFC 03,W
4FD8:  MOVWF  FEA
4FDA:  MOVFF  FEC,337
4FDE:  MOVF   FED,F
4FE0:  MOVFF  FEF,336
4FE4:  MOVF   x36,F
4FE6:  BNZ   4FF2
4FE8:  MOVF   x37,F
4FEA:  BNZ   4FF2
....................       return FALSE; 
4FEC:  MOVLW  00
4FEE:  MOVWF  01
4FF0:  BRA    5054
....................  
....................    if ( TCB[s].TxBuffer == INVALID_BUFFER ) 
4FF2:  MOVF   x33,W
4FF4:  MULLW  24
4FF6:  MOVF   FF3,W
4FF8:  CLRF   x35
4FFA:  MOVWF  x34
4FFC:  MOVLW  0F
4FFE:  ADDWF  x34,W
5000:  MOVWF  01
5002:  MOVLW  00
5004:  ADDWFC x35,W
5006:  MOVWF  03
5008:  MOVF   01,W
500A:  ADDLW  5F
500C:  MOVWF  FE9
500E:  MOVLW  00
5010:  ADDWFC 03,W
5012:  MOVWF  FEA
5014:  INCFSZ FEF,W
5016:  BRA    5028
....................       return IPIsTxReady(FALSE); 
5018:  CLRF   x91
501A:  MOVLB  0
501C:  CALL   25B2
5020:  MOVF   01,W
5022:  MOVLB  3
5024:  BRA    5054
....................    else 
5026:  BRA    5054
....................       return TCB[s].Flags.bIsPutReady; 
5028:  MOVF   x33,W
502A:  MULLW  24
502C:  MOVF   FF3,W
502E:  CLRF   x35
5030:  MOVWF  x34
5032:  MOVLW  23
5034:  ADDWF  x34,W
5036:  MOVWF  x36
5038:  MOVLW  00
503A:  ADDWFC x35,W
503C:  MOVWF  x37
503E:  MOVLW  5F
5040:  ADDWF  x36,W
5042:  MOVWF  FE9
5044:  MOVLW  00
5046:  ADDWFC x37,W
5048:  MOVWF  FEA
504A:  MOVLW  00
504C:  BTFSC  FEF.1
504E:  MOVLW  01
5050:  MOVWF  01
5052:  BRA    5054
.................... } 
5054:  MOVLB  0
5056:  RETLW  00
....................  
....................  
.................... int16 TCPPutAvailable(TCP_SOCKET s) 
.................... { 
....................    int16 txCount, txAvail; 
....................  
....................    if (!TCPIsPutReady(s)) 
*
5440:  MOVFF  32E,333
5444:  RCALL  4FB6
5446:  MOVF   01,F
5448:  BNZ   5452
....................       return(0); 
544A:  MOVLW  00
544C:  MOVWF  01
544E:  MOVWF  02
5450:  BRA    5538
....................  
....................    if ( TCB[s].TxBuffer == INVALID_BUFFER ) 
5452:  MOVLB  3
5454:  MOVF   x2E,W
5456:  MULLW  24
5458:  MOVF   FF3,W
545A:  CLRF   x34
545C:  MOVWF  x33
545E:  MOVLW  0F
5460:  ADDWF  x33,W
5462:  MOVWF  01
5464:  MOVLW  00
5466:  ADDWFC x34,W
5468:  MOVWF  03
546A:  MOVF   01,W
546C:  ADDLW  5F
546E:  MOVWF  FE9
5470:  MOVLW  00
5472:  ADDWFC 03,W
5474:  MOVWF  FEA
5476:  INCFSZ FEF,W
5478:  BRA    5480
....................       txCount = 0; 
547A:  CLRF   x30
547C:  CLRF   x2F
....................    else 
547E:  BRA    54B0
....................       txCount = TCB[s].TxCount; 
5480:  MOVF   x2E,W
5482:  MULLW  24
5484:  MOVF   FF3,W
5486:  CLRF   x34
5488:  MOVWF  x33
548A:  MOVLW  10
548C:  ADDWF  x33,W
548E:  MOVWF  01
5490:  MOVLW  00
5492:  ADDWFC x34,W
5494:  MOVWF  03
5496:  MOVF   01,W
5498:  ADDLW  5F
549A:  MOVWF  FE9
549C:  MOVLW  00
549E:  ADDWFC 03,W
54A0:  MOVWF  FEA
54A2:  MOVFF  FEC,03
54A6:  MOVF   FED,F
54A8:  MOVFF  FEF,32F
54AC:  MOVFF  03,330
....................  
....................    txAvail = MAX_TCP_DATA_LEN - txCount; 
54B0:  MOVLW  CA
54B2:  BSF    FD8.0
54B4:  SUBFWB x2F,W
54B6:  MOVWF  x31
54B8:  MOVLW  03
54BA:  SUBFWB x30,W
54BC:  MOVWF  x32
....................  
....................    txAvail = txAvail > TCB[s].RemoteWindow ? TCB[s].RemoteWindow : txAvail; 
54BE:  MOVF   x2E,W
54C0:  MULLW  24
54C2:  MOVF   FF3,W
54C4:  CLRF   x34
54C6:  MOVWF  x33
54C8:  MOVLW  14
54CA:  ADDWF  x33,W
54CC:  MOVWF  01
54CE:  MOVLW  00
54D0:  ADDWFC x34,W
54D2:  MOVWF  03
54D4:  MOVF   01,W
54D6:  ADDLW  5F
54D8:  MOVWF  FE9
54DA:  MOVLW  00
54DC:  ADDWFC 03,W
54DE:  MOVWF  FEA
54E0:  MOVFF  FEC,03
54E4:  MOVF   FED,F
54E6:  MOVFF  FEF,01
54EA:  MOVF   03,W
54EC:  SUBWF  x32,W
54EE:  BNC   5524
54F0:  BNZ   54F8
54F2:  MOVF   x31,W
54F4:  SUBWF  01,W
54F6:  BC    5524
54F8:  MOVF   x2E,W
54FA:  MULLW  24
54FC:  MOVF   FF3,W
54FE:  CLRF   x36
5500:  MOVWF  x35
5502:  MOVLW  14
5504:  ADDWF  x35,W
5506:  MOVWF  01
5508:  MOVLW  00
550A:  ADDWFC x36,W
550C:  MOVWF  03
550E:  MOVF   01,W
5510:  ADDLW  5F
5512:  MOVWF  FE9
5514:  MOVLW  00
5516:  ADDWFC 03,W
5518:  MOVWF  FEA
551A:  MOVFF  FEC,03
551E:  MOVF   FED,F
5520:  MOVF   FEF,W
5522:  BRA    552A
5524:  MOVFF  332,03
5528:  MOVF   x31,W
552A:  MOVWF  x31
552C:  MOVFF  03,332
....................  
....................    return(txAvail); 
5530:  MOVFF  331,01
5534:  MOVFF  332,02
5538:  MOVLB  0
.................... } 
553A:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        WORD TCPPutArray(TCP_SOCKET s, BYTE *ptr, WORD len) 
....................  * 
....................  * PreCondition:    TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           s      - socket to use 
....................  *                  ptr    - Block of data to send over TCP 
....................  *                  len    - number of bytes to send over TCP 
....................  * 
....................  * Output:          Total number of bytes written to TCP.  If this value 
....................  *                  is not equal len that means we ran out of space in the 
....................  *                  TX buffer -OR- we ran out of space in the remote node's 
....................  *                  window.  In either case you will have to continue later. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... WORD TCPPutArray(TCP_SOCKET s, BYTE *ptr, WORD len) 
.................... { 
....................    SOCKET_INFO* ps; 
....................    WORD n; 
....................  
....................    ps = &TCB[s]; 
....................  
....................    // Make sure that the remote node is able to accept our data 
....................    if(ps->RemoteWindow == 0) 
....................       return 0; 
....................  
....................    if(ps->TxBuffer == INVALID_BUFFER) 
....................    { 
....................       ps->TxBuffer = MACGetTxBuffer(FALSE); 
....................  
....................       // Check to make sure that we received a TX Buffer 
....................       if(ps->TxBuffer == INVALID_BUFFER) 
....................          return 0; 
....................  
....................       ps->TxCount = 0; 
....................  
....................       IPSetTxBuffer(ps->TxBuffer, sizeof(TCP_HEADER)); 
....................    } 
....................  
....................    n = TCPPutAvailable(s); 
....................  
....................    ps->Flags.bIsTxInProgress = TRUE; 
....................  
....................    while (n--) 
....................    { 
....................       MACPut(*ptr++); 
....................       ps->RemoteWindow -= 1; 
....................       ps->TxCount += 1; 
....................    } 
....................  
....................    if(ps->TxCount >= MAX_TCP_DATA_LEN) 
....................       TCPFlush(s); 
....................  
....................    return(len); 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPPut(TCP_SOCKET s, BYTE *ptr, WORD len) 
....................  * 
....................  * PreCondition:    TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           s      - socket to use 
....................  *                  ptr    - Block of data to send over TCP 
....................  *                  len    - number of bytes to send over TCP 
....................  * 
....................  * Output:          Total number of bytes written to TCP.  If this value 
....................  *                  is not equal len that means we ran out of space in the 
....................  *                  TX buffer and you will have to continue later. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPPut(TCP_SOCKET s, BYTE byte) 
.................... { 
....................    SOCKET_INFO* ps; 
....................    WORD tempCount; 
....................  
....................    ps = &TCB[s]; 
*
522A:  MOVLB  3
522C:  MOVF   x3F,W
522E:  MULLW  24
5230:  MOVF   FF3,W
5232:  CLRF   03
5234:  ADDLW  5F
5236:  MOVWF  01
5238:  MOVLW  00
523A:  ADDWFC 03,F
523C:  MOVFF  01,341
5240:  MOVFF  03,342
....................  
....................    // Make sure that the remote node is able to accept our data 
....................    if(ps->RemoteWindow == 0) 
5244:  MOVLW  14
5246:  ADDWF  x41,W
5248:  MOVWF  FE9
524A:  MOVLW  00
524C:  ADDWFC x42,W
524E:  MOVWF  FEA
5250:  MOVFF  FEC,346
5254:  MOVF   FED,F
5256:  MOVFF  FEF,345
525A:  MOVF   x45,F
525C:  BNZ   5268
525E:  MOVF   x46,F
5260:  BNZ   5268
....................       return FALSE; 
5262:  MOVLW  00
5264:  MOVWF  01
5266:  BRA    536E
....................  
....................    if(ps->TxBuffer == INVALID_BUFFER) 
5268:  MOVLW  0F
526A:  ADDWF  x41,W
526C:  MOVWF  FE9
526E:  MOVLW  00
5270:  ADDWFC x42,W
5272:  MOVWF  FEA
5274:  INCFSZ FEF,W
5276:  BRA    52EA
....................    { 
....................       ps->TxBuffer = MACGetTxBuffer(FALSE); 
5278:  MOVLW  0F
527A:  ADDWF  x41,W
527C:  MOVWF  01
527E:  MOVLW  00
5280:  ADDWFC x42,W
5282:  MOVWF  03
5284:  MOVFF  01,345
5288:  MOVWF  x46
528A:  CLRF   x91
528C:  MOVLB  0
528E:  CALL   1448
5292:  MOVFF  346,FEA
5296:  MOVFF  345,FE9
529A:  MOVFF  01,FEF
....................  
....................       // Check to make sure that we received a TX Buffer 
....................       if(ps->TxBuffer == INVALID_BUFFER) 
529E:  MOVLW  0F
52A0:  MOVLB  3
52A2:  ADDWF  x41,W
52A4:  MOVWF  FE9
52A6:  MOVLW  00
52A8:  ADDWFC x42,W
52AA:  MOVWF  FEA
52AC:  INCFSZ FEF,W
52AE:  BRA    52B6
....................          return FALSE; 
52B0:  MOVLW  00
52B2:  MOVWF  01
52B4:  BRA    536E
....................  
....................       ps->TxCount = 0; 
52B6:  MOVLW  10
52B8:  ADDWF  x41,W
52BA:  MOVWF  FE9
52BC:  MOVLW  00
52BE:  ADDWFC x42,W
52C0:  MOVWF  FEA
52C2:  CLRF   FEC
52C4:  MOVF   FED,F
52C6:  CLRF   FEF
....................  
....................       IPSetTxBuffer(ps->TxBuffer, sizeof(TCP_HEADER)); 
52C8:  MOVLW  0F
52CA:  ADDWF  x41,W
52CC:  MOVWF  FE9
52CE:  MOVLW  00
52D0:  ADDWFC x42,W
52D2:  MOVWF  FEA
52D4:  MOVFF  FEF,345
52D8:  MOVFF  345,3AA
52DC:  CLRF   xAC
52DE:  MOVLW  28
52E0:  MOVWF  xAB
52E2:  MOVLB  0
52E4:  CALL   1472
52E8:  MOVLB  3
....................    } 
....................  
....................    ps->Flags.bIsTxInProgress = TRUE; 
52EA:  MOVLW  23
52EC:  ADDWF  x41,W
52EE:  MOVWF  FE9
52F0:  MOVLW  00
52F2:  ADDWFC x42,W
52F4:  MOVWF  FEA
52F6:  BSF    FEF.4
....................  
....................    MACPut(byte); 
52F8:  MOVFF  340,3B4
52FC:  MOVLB  0
52FE:  CALL   151C
....................    ps->RemoteWindow--; 
5302:  MOVLW  14
5304:  MOVLB  3
5306:  ADDWF  x41,W
5308:  MOVWF  FE9
530A:  MOVLW  00
530C:  ADDWFC x42,W
530E:  MOVWF  FEA
5310:  MOVLW  FF
5312:  ADDWF  FEF,F
5314:  BC    531A
5316:  MOVF   FEE,F
5318:  DECF   FED,F
....................  
....................    tempCount = ps->TxCount; 
531A:  MOVLW  10
531C:  ADDWF  x41,W
531E:  MOVWF  FE9
5320:  MOVLW  00
5322:  ADDWFC x42,W
5324:  MOVWF  FEA
5326:  MOVFF  FEC,03
532A:  MOVF   FED,F
532C:  MOVFF  FEF,343
5330:  MOVFF  03,344
....................    tempCount++; 
5334:  INCF   x43,F
5336:  BTFSC  FD8.2
5338:  INCF   x44,F
....................    ps->TxCount = tempCount; 
533A:  MOVLW  10
533C:  ADDWF  x41,W
533E:  MOVWF  FE9
5340:  MOVLW  00
5342:  ADDWFC x42,W
5344:  MOVWF  FEA
5346:  MOVFF  344,FEC
534A:  MOVF   FED,F
534C:  MOVFF  343,FEF
....................    if(tempCount >= MAX_TCP_DATA_LEN) 
5350:  MOVF   x44,W
5352:  SUBLW  02
5354:  BC    536A
5356:  XORLW  FF
5358:  BNZ   5360
535A:  MOVF   x43,W
535C:  SUBLW  C9
535E:  BC    536A
....................       TCPFlush(s); 
5360:  MOVFF  33F,345
5364:  MOVLB  0
5366:  RCALL  5060
5368:  MOVLB  3
....................  
....................    return TRUE; 
536A:  MOVLW  01
536C:  MOVWF  01
.................... } 
536E:  MOVLB  0
5370:  GOTO   537E (RETURN)
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPDiscard(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket 
....................  * 
....................  * Output:          TRUE if socket received data was discarded 
....................  *                  FALSE if socket received data was already 
....................  *                          discarded. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPDiscard(TCP_SOCKET s) 
.................... { 
....................     SOCKET_INFO* ps; 
....................  
....................     ps = &TCB[s]; 
*
4F68:  MOVLB  3
4F6A:  MOVF   x13,W
4F6C:  MULLW  24
4F6E:  MOVF   FF3,W
4F70:  CLRF   03
4F72:  ADDLW  5F
4F74:  MOVWF  01
4F76:  MOVLW  00
4F78:  ADDWFC 03,F
4F7A:  MOVFF  01,314
4F7E:  MOVFF  03,315
....................  
....................     // This socket must contain data for it to be discarded. 
....................     if ( !ps->Flags.bIsGetReady ) 
4F82:  MOVLW  23
4F84:  ADDWF  x14,W
4F86:  MOVWF  FE9
4F88:  MOVLW  00
4F8A:  ADDWFC x15,W
4F8C:  MOVWF  FEA
4F8E:  BTFSC  FEF.3
4F90:  BRA    4F98
....................         return FALSE; 
4F92:  MOVLW  00
4F94:  MOVWF  01
4F96:  BRA    4FB2
....................  
....................     MACDiscardRx(); 
4F98:  MOVLB  0
4F9A:  CALL   1076
....................     ps->Flags.bIsGetReady = FALSE; 
4F9E:  MOVLW  23
4FA0:  MOVLB  3
4FA2:  ADDWF  x14,W
4FA4:  MOVWF  FE9
4FA6:  MOVLW  00
4FA8:  ADDWFC x15,W
4FAA:  MOVWF  FEA
4FAC:  BCF    FEF.3
....................  
....................     return TRUE; 
4FAE:  MOVLW  01
4FB0:  MOVWF  01
.................... } 
4FB2:  MOVLB  0
4FB4:  RETLW  00
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD TCPGetArray(TCP_SOCKET s, BYTE *buffer, 
....................  *                                      WORD count) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  buffer  - Buffer to hold received data. 
....................  *                  count   - Buffer length 
....................  * 
....................  * Output:          Number of bytes loaded into buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... WORD TCPGetArray(TCP_SOCKET s, BYTE *buff, WORD count) 
.................... { 
....................     SOCKET_INFO *ps; 
....................  
....................     ps = &TCB[s]; 
....................  
....................     if ( ps->Flags.bIsGetReady ) 
....................     { 
....................         if ( ps->Flags.bFirstRead ) 
....................         { 
....................          // Position read pointer to begining of TCP data 
....................             IPSetRxBuffer(sizeof(TCP_HEADER)); 
....................  
....................             ps->Flags.bFirstRead = FALSE; 
....................         } 
....................  
....................         ps->Flags.bIsTxInProgress = TRUE; 
....................  
....................         return MACGetArray(buff, count); 
....................     } 
....................     else 
....................         return 0; 
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPGet(TCP_SOCKET s, BYTE *byte) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  byte    - Pointer to a byte. 
....................  * 
....................  * Output:          TRUE if a byte was read. 
....................  *                  FALSE if byte was not read. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPGet(TCP_SOCKET s, BYTE *data) 
.................... { 
....................     SOCKET_INFO* ps; 
....................  
....................     ps = &TCB[s]; 
*
3FC4:  MOVLB  3
3FC6:  MOVF   x10,W
3FC8:  MULLW  24
3FCA:  MOVF   FF3,W
3FCC:  CLRF   03
3FCE:  ADDLW  5F
3FD0:  MOVWF  01
3FD2:  MOVLW  00
3FD4:  ADDWFC 03,F
3FD6:  MOVFF  01,313
3FDA:  MOVFF  03,314
....................  
....................     if ( ps->Flags.bIsGetReady ) 
3FDE:  MOVLW  23
3FE0:  ADDWF  x13,W
3FE2:  MOVWF  FE9
3FE4:  MOVLW  00
3FE6:  ADDWFC x14,W
3FE8:  MOVWF  FEA
3FEA:  BTFSS  FEF.3
3FEC:  BRA    4090
....................     { 
....................         if ( ps->Flags.bFirstRead ) 
3FEE:  MOVLW  23
3FF0:  ADDWF  x13,W
3FF2:  MOVWF  FE9
3FF4:  MOVLW  00
3FF6:  ADDWFC x14,W
3FF8:  MOVWF  FEA
3FFA:  BTFSS  FEF.2
3FFC:  BRA    401A
....................         { 
....................             // Position read pointer to begining of correct 
....................             // buffer. 
....................             IPSetRxBuffer(sizeof(TCP_HEADER)); 
3FFE:  CLRF   x37
4000:  MOVLW  14
4002:  MOVWF  x36
4004:  MOVLB  0
4006:  CALL   2054
....................  
....................             ps->Flags.bFirstRead = FALSE; 
400A:  MOVLW  23
400C:  MOVLB  3
400E:  ADDWF  x13,W
4010:  MOVWF  FE9
4012:  MOVLW  00
4014:  ADDWFC x14,W
4016:  MOVWF  FEA
4018:  BCF    FEF.2
....................         } 
....................  
....................         if ( ps->RxCount == 0 ) 
401A:  MOVLW  12
401C:  ADDWF  x13,W
401E:  MOVWF  FE9
4020:  MOVLW  00
4022:  ADDWFC x14,W
4024:  MOVWF  FEA
4026:  MOVFF  FEC,316
402A:  MOVF   FED,F
402C:  MOVFF  FEF,315
4030:  MOVF   x15,F
4032:  BNZ   4054
4034:  MOVF   x16,F
4036:  BNZ   4054
....................         { 
....................             MACDiscardRx(); 
4038:  MOVLB  0
403A:  CALL   1076
....................             ps->Flags.bIsGetReady = FALSE; 
403E:  MOVLW  23
4040:  MOVLB  3
4042:  ADDWF  x13,W
4044:  MOVWF  FE9
4046:  MOVLW  00
4048:  ADDWFC x14,W
404A:  MOVWF  FEA
404C:  BCF    FEF.3
....................             return FALSE; 
404E:  MOVLW  00
4050:  MOVWF  01
4052:  BRA    4094
....................         } 
....................  
....................          ps->RxCount--; 
4054:  MOVLW  12
4056:  ADDWF  x13,W
4058:  MOVWF  FE9
405A:  MOVLW  00
405C:  ADDWFC x14,W
405E:  MOVWF  FEA
4060:  MOVLW  FF
4062:  ADDWF  FEF,F
4064:  BC    406A
4066:  MOVF   FEE,F
4068:  DECF   FED,F
....................          *data = MACGet(); 
406A:  MOVFF  312,03
406E:  MOVFF  311,315
4072:  MOVFF  312,316
4076:  MOVLB  0
4078:  CALL   1ED0
407C:  MOVFF  316,FEA
4080:  MOVFF  315,FE9
4084:  MOVFF  01,FEF
....................         return TRUE; 
4088:  MOVLW  01
408A:  MOVWF  01
408C:  MOVLB  3
408E:  BRA    4094
....................     } 
....................     return FALSE; 
4090:  MOVLW  00
4092:  MOVWF  01
.................... } 
4094:  MOVLB  0
4096:  RETLW  00
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsGetReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' contains any data. 
....................  *                  FALSE if socket 's' does not contain any data. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPIsGetReady(TCP_SOCKET s) 
.................... { 
....................     /* 
....................      * A socket is said to be "Get" ready when it has already 
....................      * received some data.  Sometime, a socket may be closed, 
....................      * but it still may contain data.  Thus in order to ensure 
....................      * reuse of a socket, caller must make sure that it reads 
....................      * a socket, if is ready. 
....................      */ 
....................     return (TCB[s].Flags.bIsGetReady ); 
*
3F94:  MOVLB  3
3F96:  MOVF   x10,W
3F98:  MULLW  24
3F9A:  MOVF   FF3,W
3F9C:  CLRF   x12
3F9E:  MOVWF  x11
3FA0:  MOVLW  23
3FA2:  ADDWF  x11,W
3FA4:  MOVWF  x13
3FA6:  MOVLW  00
3FA8:  ADDWFC x12,W
3FAA:  MOVWF  x14
3FAC:  MOVLW  5F
3FAE:  ADDWF  x13,W
3FB0:  MOVWF  FE9
3FB2:  MOVLW  00
3FB4:  ADDWFC x14,W
3FB6:  MOVWF  FEA
3FB8:  MOVLW  00
3FBA:  BTFSC  FEF.3
3FBC:  MOVLW  01
3FBE:  MOVWF  01
.................... } 
3FC0:  MOVLB  0
3FC2:  RETLW  00
....................  
.................... //// internal functions ///// 
....................  
.................... void DebugTCPDisplayState(TCP_STATE st) 
.................... { 
....................    switch(st) 
....................    { 
....................       case TCP_LISTEN:        debug_tcp("LISTEN"); break; 
....................       case TCP_SYN_SENT:      debug_tcp("SYN_SENT"); break; 
....................       case TCP_SYN_RECEIVED:  debug_tcp("SYN_RECVD"); break; 
....................       case TCP_ESTABLISHED:   debug_tcp("ESTABLISHED"); break; 
....................       case TCP_FIN_WAIT_1:    debug_tcp("FIN_WAIT_1"); break; 
....................       case TCP_FIN_WAIT_2:    debug_tcp("FIN_WAIT_2"); break; 
....................       case TCP_CLOSING:       debug_tcp("CLOSING"); break; 
....................       case TCP_TIME_WAIT:     debug_tcp("TIME_WAIT"); break; 
....................       case TCP_CLOSE_WAIT:    debug_tcp("CLOSE_WAIT"); break; 
....................       case TCP_LAST_ACK:      debug_tcp("LAST_ACK"); break; 
....................       case TCP_CLOSED:        debug_tcp("CLOSED"); break; 
....................       default:                debug_tcp("UNKNOWN %U",st); break; 
....................    } 
.................... } 
....................  
.................... /********************************************************************* 
.................... * Function:        void TCPTick(void) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           None 
.................... * 
.................... * Output:          Each socket FSM is executed for any timeout 
.................... *                  situation. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... void TCPTick(void) 
.................... { 
....................    TCP_SOCKET s; 
....................    TICKTYPE diffTicks; 
....................    TICKTYPE tick; 
....................    SOCKET_INFO* ps; 
....................    DWORD seq; 
....................    BYTE flags; 
....................    //BYTE debugLastState; 
....................  
....................    flags = 0x00; 
*
3A94:  MOVLB  3
3A96:  CLRF   x13
....................    // Periodically all "not closed" sockets must perform timed operations 
....................    for(s = 0; s < MAX_SOCKETS; s++) 
3A98:  CLRF   x08
3A9A:  MOVF   x08,W
3A9C:  SUBLW  04
3A9E:  BTFSS  FD8.0
3AA0:  BRA    3F2E
....................    { 
....................       ps = &TCB[s]; 
3AA2:  MOVF   x08,W
3AA4:  MULLW  24
3AA6:  MOVF   FF3,W
3AA8:  CLRF   03
3AAA:  ADDLW  5F
3AAC:  MOVWF  01
3AAE:  MOVLW  00
3AB0:  ADDWFC 03,F
3AB2:  MOVFF  01,30D
3AB6:  MOVFF  03,30E
....................  
....................       //debugLastState = TCB[s].smState; 
....................  
....................       if ( ps->Flags.bIsGetReady || ps->Flags.bIsTxInProgress ) 
3ABA:  MOVLW  23
3ABC:  ADDWF  x0D,W
3ABE:  MOVWF  FE9
3AC0:  MOVLW  00
3AC2:  ADDWFC x0E,W
3AC4:  MOVWF  FEA
3AC6:  BTFSC  FEF.3
3AC8:  BRA    3ADA
3ACA:  MOVLW  23
3ACC:  ADDWF  x0D,W
3ACE:  MOVWF  FE9
3AD0:  MOVLW  00
3AD2:  ADDWFC x0E,W
3AD4:  MOVWF  FEA
3AD6:  BTFSS  FEF.4
3AD8:  BRA    3ADC
....................          continue; 
3ADA:  BRA    3F2A
....................  
....................  
....................       // Closed or Passively Listening socket do not care 
....................       // about timeout conditions. 
....................       if ( (ps->smState == TCP_CLOSED) || 
....................          (ps->smState == TCP_LISTEN && 
....................          ps->Flags.bServer == TRUE) ) 
3ADC:  MOVFF  30D,FE9
3AE0:  MOVFF  30E,FEA
3AE4:  MOVF   FEF,W
3AE6:  SUBLW  0A
3AE8:  BZ    3B0E
3AEA:  MOVFF  30D,FE9
3AEE:  MOVFF  30E,FEA
3AF2:  MOVF   FEF,F
3AF4:  BNZ   3B10
3AF6:  MOVLW  23
3AF8:  ADDWF  x0D,W
3AFA:  MOVWF  FE9
3AFC:  MOVLW  00
3AFE:  ADDWFC x0E,W
3B00:  MOVWF  FEA
3B02:  MOVLW  00
3B04:  BTFSC  FEF.0
3B06:  MOVLW  01
3B08:  ANDLW  01
3B0A:  SUBLW  01
3B0C:  BNZ   3B10
....................          continue; 
3B0E:  BRA    3F2A
....................  
....................       //TODO: review this 
....................       //DSR ADD 063004 
....................         //i do this because if i am a server, i don't want to timeout. 
....................       if ( (ps->smState == TCP_ESTABLISHED) && (ps->Flags.bServer == TRUE) ) 
3B10:  MOVFF  30D,FE9
3B14:  MOVFF  30E,FEA
3B18:  MOVF   FEF,W
3B1A:  SUBLW  03
3B1C:  BNZ   3B38
3B1E:  MOVLW  23
3B20:  ADDWF  x0D,W
3B22:  MOVWF  FE9
3B24:  MOVLW  00
3B26:  ADDWFC x0E,W
3B28:  MOVWF  FEA
3B2A:  MOVLW  00
3B2C:  BTFSC  FEF.0
3B2E:  MOVLW  01
3B30:  ANDLW  01
3B32:  SUBLW  01
3B34:  BNZ   3B38
....................          continue; 
3B36:  BRA    3F2A
....................  
....................  
....................       tick = TickGet(); 
3B38:  MOVLB  0
3B3A:  CALL   2494
3B3E:  MOVFF  02,30C
3B42:  MOVFF  01,30B
....................  
....................       // Calculate timeout value for this socket. 
....................       diffTicks = TickGetDiff(tick, ps->startTick); 
3B46:  MOVLW  1F
3B48:  MOVLB  3
3B4A:  ADDWF  x0D,W
3B4C:  MOVWF  FE9
3B4E:  MOVLW  00
3B50:  ADDWFC x0E,W
3B52:  MOVWF  FEA
3B54:  MOVFF  FEC,03
3B58:  MOVF   FED,F
3B5A:  MOVFF  FEF,01
3B5E:  MOVF   x0C,W
3B60:  SUBWF  03,W
3B62:  BNC   3B6C
3B64:  BNZ   3B70
3B66:  MOVF   01,W
3B68:  SUBWF  x0B,W
3B6A:  BNC   3B70
3B6C:  MOVLW  00
3B6E:  BRA    3B72
3B70:  MOVLW  01
3B72:  CLRF   03
3B74:  IORWF  03,W
3B76:  BZ    3BB2
3B78:  MOVLW  1F
3B7A:  ADDWF  x0D,W
3B7C:  MOVWF  FE9
3B7E:  MOVLW  00
3B80:  ADDWFC x0E,W
3B82:  MOVWF  FEA
3B84:  MOVFF  FEC,03
3B88:  MOVF   FED,F
3B8A:  MOVF   FEF,W
3B8C:  SUBLW  FF
3B8E:  MOVWF  x14
3B90:  MOVLW  FF
3B92:  SUBFWB 03,W
3B94:  MOVWF  x15
3B96:  MOVF   x0B,W
3B98:  ADDWF  x14,W
3B9A:  MOVWF  x16
3B9C:  MOVF   x0C,W
3B9E:  ADDWFC x15,W
3BA0:  MOVWF  x17
3BA2:  MOVLW  01
3BA4:  ADDWF  x16,W
3BA6:  MOVWF  01
3BA8:  MOVLW  00
3BAA:  ADDWFC x17,W
3BAC:  MOVWF  03
3BAE:  MOVF   01,W
3BB0:  BRA    3BD2
3BB2:  MOVLW  1F
3BB4:  ADDWF  x0D,W
3BB6:  MOVWF  FE9
3BB8:  MOVLW  00
3BBA:  ADDWFC x0E,W
3BBC:  MOVWF  FEA
3BBE:  MOVFF  FEC,03
3BC2:  MOVF   FED,F
3BC4:  MOVF   FEF,W
3BC6:  SUBWF  x0B,W
3BC8:  MOVWF  00
3BCA:  MOVF   03,W
3BCC:  SUBWFB x0C,W
3BCE:  MOVWF  03
3BD0:  MOVF   00,W
3BD2:  MOVWF  x09
3BD4:  MOVFF  03,30A
....................  
....................       // If timeout has not occured, do not do anything. 
....................       if(diffTicks <= ps->TimeOut) 
3BD8:  MOVLW  21
3BDA:  ADDWF  x0D,W
3BDC:  MOVWF  FE9
3BDE:  MOVLW  00
3BE0:  ADDWFC x0E,W
3BE2:  MOVWF  FEA
3BE4:  MOVFF  FEC,03
3BE8:  MOVF   FED,F
3BEA:  MOVFF  FEF,01
3BEE:  MOVF   x0A,W
3BF0:  SUBWF  03,W
3BF2:  BNC   3BFE
3BF4:  BNZ   3BFC
3BF6:  MOVF   x09,W
3BF8:  SUBWF  01,W
3BFA:  BNC   3BFE
....................          continue; 
3BFC:  BRA    3F2A
....................  
....................       // Most states require retransmission, so check for transmitter 
....................       // availability right here - common for all. 
....................       if(!IPIsTxReady(TRUE)) 
3BFE:  MOVLW  01
3C00:  MOVWF  x91
3C02:  MOVLB  0
3C04:  CALL   25B2
3C08:  MOVF   01,F
3C0A:  BNZ   3C0E
....................          return; 
3C0C:  BRA    3F2E
....................  
....................       // Restart timeout reference. 
....................       ps->startTick = TickGet(); 
3C0E:  MOVLW  1F
3C10:  MOVLB  3
3C12:  ADDWF  x0D,W
3C14:  MOVWF  01
3C16:  MOVLW  00
3C18:  ADDWFC x0E,W
3C1A:  MOVWF  03
3C1C:  MOVFF  01,314
3C20:  MOVWF  x15
3C22:  MOVLB  0
3C24:  CALL   2494
3C28:  MOVFF  315,FEA
3C2C:  MOVFF  314,FE9
3C30:  MOVFF  02,FEC
3C34:  MOVF   FED,F
3C36:  MOVFF  01,FEF
....................  
....................       // Update timeout value if there is need to wait longer. 
....................       ps->TimeOut <<= 1; 
3C3A:  MOVLW  21
3C3C:  MOVLB  3
3C3E:  ADDWF  x0D,W
3C40:  MOVWF  FE9
3C42:  MOVLW  00
3C44:  ADDWFC x0E,W
3C46:  MOVWF  FEA
3C48:  BCF    FD8.0
3C4A:  RLCF   FEF,W
3C4C:  MOVWF  02
3C4E:  RLCF   FEC,W
3C50:  MOVWF  03
3C52:  MOVF   02,W
3C54:  MOVF   FED,F
3C56:  MOVWF  FEF
3C58:  MOVFF  03,FEC
....................  
....................       // This will be one more attempt. 
....................       ps->RetryCount++; 
3C5C:  MOVLW  1E
3C5E:  ADDWF  x0D,W
3C60:  MOVWF  FE9
3C62:  MOVLW  00
3C64:  ADDWFC x0E,W
3C66:  MOVWF  FEA
3C68:  INCF   FEF,F
....................  
....................       // A timeout has occured.  Respond to this timeout condition 
....................       // depending on what state this socket is in. 
....................       switch(ps->smState) 
....................       { 
3C6A:  MOVFF  30D,FE9
3C6E:  MOVFF  30E,FEA
3C72:  MOVLW  01
3C74:  SUBWF  FEF,W
3C76:  ADDLW  F7
3C78:  BTFSC  FD8.0
3C7A:  BRA    3E0A
3C7C:  ADDLW  09
3C7E:  MOVLB  0
3C80:  GOTO   3F34
....................       case TCP_SYN_SENT: 
....................          // Keep sending SYN until we hear from remote node. 
....................          // This may be for infinite time, in that case 
....................          // caller must detect it and do something. 
....................          // Bug Fix: 11/1/02 
....................          flags = SYN; 
3C84:  MOVLW  02
3C86:  MOVLB  3
3C88:  MOVWF  x13
....................          break; 
3C8A:  BRA    3E0A
....................  
....................       case TCP_SYN_RECEIVED: 
....................          // We must receive ACK before timeout expires. 
....................          // If not, resend SYN+ACK. 
....................          // Abort, if maximum attempts counts are reached. 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
3C8C:  MOVLW  1E
3C8E:  MOVLB  3
3C90:  ADDWF  x0D,W
3C92:  MOVWF  FE9
3C94:  MOVLW  00
3C96:  ADDWFC x0E,W
3C98:  MOVWF  FEA
3C9A:  MOVF   FEF,W
3C9C:  SUBLW  03
3C9E:  BNC   3CA6
....................          { 
....................             flags = SYN | ACK; 
3CA0:  MOVLW  12
3CA2:  MOVWF  x13
....................          } 
....................          else 
3CA4:  BRA    3CD2
....................          { 
....................             if(ps->Flags.bServer) 
3CA6:  MOVLW  23
3CA8:  ADDWF  x0D,W
3CAA:  MOVWF  FE9
3CAC:  MOVLW  00
3CAE:  ADDWFC x0E,W
3CB0:  MOVWF  FEA
3CB2:  BTFSS  FEF.0
3CB4:  BRA    3CC2
....................             { 
....................                ps->smState = TCP_LISTEN; 
3CB6:  MOVFF  30D,FE9
3CBA:  MOVFF  30E,FEA
3CBE:  CLRF   FEF
....................             } 
....................             else 
3CC0:  BRA    3CD2
....................             { 
....................                flags = SYN; 
3CC2:  MOVLW  02
3CC4:  MOVWF  x13
....................                ps->smState = TCP_SYN_SENT; 
3CC6:  MOVFF  30D,FE9
3CCA:  MOVFF  30E,FEA
3CCE:  MOVLW  01
3CD0:  MOVWF  FEF
....................             } 
....................          } 
....................          break; 
3CD2:  BRA    3E0A
....................  
....................       case TCP_ESTABLISHED: 
.................... #if !TCP_NO_WAIT_FOR_ACK 
....................          // Don't let this connection idle for very long time. 
....................          // If we did not receive or send any message before timeout 
....................          // expires, close this connection. 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
3CD4:  MOVLW  1E
3CD6:  MOVLB  3
3CD8:  ADDWF  x0D,W
3CDA:  MOVWF  FE9
3CDC:  MOVLW  00
3CDE:  ADDWFC x0E,W
3CE0:  MOVWF  FEA
3CE2:  MOVF   FEF,W
3CE4:  SUBLW  03
3CE6:  BNC   3D2A
....................          { 
....................             if(ps->TxBuffer != INVALID_BUFFER) 
3CE8:  MOVLW  0F
3CEA:  ADDWF  x0D,W
3CEC:  MOVWF  FE9
3CEE:  MOVLW  00
3CF0:  ADDWFC x0E,W
3CF2:  MOVWF  FEA
3CF4:  INCFSZ FEF,W
3CF6:  BRA    3CFA
3CF8:  BRA    3D20
....................             { 
....................                MACSetTxBuffer(ps->TxBuffer, 0); 
3CFA:  MOVLW  0F
3CFC:  ADDWF  x0D,W
3CFE:  MOVWF  FE9
3D00:  MOVLW  00
3D02:  ADDWFC x0E,W
3D04:  MOVWF  FEA
3D06:  MOVFF  FEF,314
3D0A:  MOVFF  314,3AA
3D0E:  CLRF   xAC
3D10:  CLRF   xAB
3D12:  MOVLB  0
3D14:  CALL   1472
....................                MACFlush(); 
3D18:  CALL   1656
....................             } 
....................             else 
3D1C:  BRA    3D26
3D1E:  MOVLB  3
....................                flags = ACK; 
3D20:  MOVLW  10
3D22:  MOVWF  x13
3D24:  MOVLB  0
....................          } 
....................          else 
3D26:  BRA    3D78
3D28:  MOVLB  3
....................          { 
....................             // Forget about previous transmission. 
....................             if(ps->TxBuffer != INVALID_BUFFER) 
3D2A:  MOVLW  0F
3D2C:  ADDWF  x0D,W
3D2E:  MOVWF  FE9
3D30:  MOVLW  00
3D32:  ADDWFC x0E,W
3D34:  MOVWF  FEA
3D36:  INCFSZ FEF,W
3D38:  BRA    3D3C
3D3A:  BRA    3D68
....................             { 
....................                MACDiscardTx(ps->TxBuffer); 
3D3C:  MOVLW  0F
3D3E:  ADDWF  x0D,W
3D40:  MOVWF  FE9
3D42:  MOVLW  00
3D44:  ADDWFC x0E,W
3D46:  MOVWF  FEA
3D48:  MOVFF  FEF,314
3D4C:  MOVFF  314,355
3D50:  MOVLB  0
3D52:  CALL   0004
....................                ps->TxBuffer = INVALID_BUFFER; 
3D56:  MOVLW  0F
3D58:  MOVLB  3
3D5A:  ADDWF  x0D,W
3D5C:  MOVWF  FE9
3D5E:  MOVLW  00
3D60:  ADDWFC x0E,W
3D62:  MOVWF  FEA
3D64:  MOVLW  FF
3D66:  MOVWF  FEF
....................             } 
....................  
.................... #endif 
....................             // Request closure. 
....................             flags = FIN | ACK; 
3D68:  MOVLW  11
3D6A:  MOVWF  x13
....................             //DebugPrint("!"); 
....................  
....................             ps->smState = TCP_FIN_WAIT_1; 
3D6C:  MOVFF  30D,FE9
3D70:  MOVFF  30E,FEA
3D74:  MOVLW  04
3D76:  MOVWF  FEF
.................... #if !TCP_NO_WAIT_FOR_ACK 
....................          } 
.................... #endif 
....................          break; 
3D78:  MOVLB  3
3D7A:  BRA    3E0A
....................  
....................       case TCP_FIN_WAIT_1: 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
3D7C:  MOVLW  1E
3D7E:  MOVLB  3
3D80:  ADDWF  x0D,W
3D82:  MOVWF  FE9
3D84:  MOVLW  00
3D86:  ADDWFC x0E,W
3D88:  MOVWF  FEA
3D8A:  MOVF   FEF,W
3D8C:  SUBLW  03
3D8E:  BNC   3D96
....................          { 
....................                // Send another FIN 
....................                flags = FIN; 
3D90:  MOVLW  01
3D92:  MOVWF  x13
....................          } 
....................          else 
3D94:  BRA    3DA6
....................          { 
....................             // Close on our own, we can't seem to communicate 
....................             // with the remote node anymore 
....................             CloseSocket(ps); 
3D96:  MOVFF  30E,353
3D9A:  MOVFF  30D,352
3D9E:  MOVLB  0
3DA0:  CALL   24AE
3DA4:  MOVLB  3
....................          } 
....................          break; 
3DA6:  BRA    3E0A
....................  
....................       case TCP_FIN_WAIT_2: 
....................       case TCP_CLOSING: 
....................          // Close on our own, we can't seem to communicate 
....................          // with the remote node anymore 
....................          CloseSocket(ps); 
3DA8:  MOVFF  30E,353
3DAC:  MOVFF  30D,352
3DB0:  CALL   24AE
....................          break; 
3DB4:  MOVLB  3
3DB6:  BRA    3E0A
....................  
....................       case TCP_TIME_WAIT: 
....................          // Wait around for a while (2MSL) and then goto closed state 
....................          CloseSocket(ps); 
3DB8:  MOVFF  30E,353
3DBC:  MOVFF  30D,352
3DC0:  CALL   24AE
....................          break; 
3DC4:  MOVLB  3
3DC6:  BRA    3E0A
....................  
....................       case TCP_CLOSE_WAIT: 
....................          flags = FIN; 
3DC8:  MOVLW  01
3DCA:  MOVLB  3
3DCC:  MOVWF  x13
....................          ps->smState = TCP_LAST_ACK; 
3DCE:  MOVFF  30D,FE9
3DD2:  MOVFF  30E,FEA
3DD6:  MOVLW  09
3DD8:  MOVWF  FEF
....................          break; 
3DDA:  BRA    3E0A
....................  
....................       case TCP_LAST_ACK: 
....................          // Send some more FINs or close anyway 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
3DDC:  MOVLW  1E
3DDE:  MOVLB  3
3DE0:  ADDWF  x0D,W
3DE2:  MOVWF  FE9
3DE4:  MOVLW  00
3DE6:  ADDWFC x0E,W
3DE8:  MOVWF  FEA
3DEA:  MOVF   FEF,W
3DEC:  SUBLW  03
3DEE:  BNC   3DF6
....................             flags = FIN; 
3DF0:  MOVLW  01
3DF2:  MOVWF  x13
....................          else 
3DF4:  BRA    3E06
....................             CloseSocket(ps); 
3DF6:  MOVFF  30E,353
3DFA:  MOVFF  30D,352
3DFE:  MOVLB  0
3E00:  CALL   24AE
3E04:  MOVLB  3
....................          break; 
3E06:  BRA    3E0A
3E08:  MOVLB  3
....................       } 
....................  
....................  
....................       if(flags) 
3E0A:  MOVF   x13,F
3E0C:  BTFSC  FD8.2
3E0E:  BRA    3F2A
....................       { 
....................          if(flags & ACK) 
3E10:  BTFSS  x13.4
3E12:  BRA    3E42
....................             seq = ps->SND_SEQ; 
3E14:  MOVLW  16
3E16:  ADDWF  x0D,W
3E18:  MOVWF  FE9
3E1A:  MOVLW  00
3E1C:  ADDWFC x0E,W
3E1E:  MOVWF  FEA
3E20:  MOVFF  FEF,00
3E24:  MOVFF  FEC,01
3E28:  MOVFF  FEC,02
3E2C:  MOVFF  FEC,03
3E30:  MOVFF  03,312
3E34:  MOVFF  02,311
3E38:  MOVFF  01,310
3E3C:  MOVFF  00,30F
....................          else 
3E40:  BRA    3E84
....................             seq = ps->SND_SEQ++; 
3E42:  MOVLW  16
3E44:  ADDWF  x0D,W
3E46:  MOVWF  FE9
3E48:  MOVLW  00
3E4A:  ADDWFC x0E,W
3E4C:  MOVWF  FEA
3E4E:  MOVF   FEE,F
3E50:  MOVF   FEE,F
3E52:  MOVF   FEE,F
3E54:  MOVFF  FED,03
3E58:  MOVFF  FED,02
3E5C:  MOVFF  FED,01
3E60:  MOVFF  FEF,00
3E64:  MOVLW  01
3E66:  ADDWF  FEE,F
3E68:  BNZ   3E74
3E6A:  INCF   FEE,F
3E6C:  BNZ   3E74
3E6E:  INCF   FEE,F
3E70:  BNZ   3E74
3E72:  INCF   FED,F
3E74:  MOVFF  03,312
3E78:  MOVFF  02,311
3E7C:  MOVFF  01,310
3E80:  MOVFF  00,30F
....................  
....................          SendTCP(&ps->remote, 
....................             ps->localPort, 
....................             ps->remotePort, 
....................             seq, 
....................             ps->SND_ACK, 
....................             flags); 
3E84:  MOVLW  01
3E86:  ADDWF  x0D,W
3E88:  MOVWF  01
3E8A:  MOVLW  00
3E8C:  ADDWFC x0E,W
3E8E:  MOVWF  03
3E90:  MOVFF  01,314
3E94:  MOVWF  x15
3E96:  MOVLW  0B
3E98:  ADDWF  x0D,W
3E9A:  MOVWF  FE9
3E9C:  MOVLW  00
3E9E:  ADDWFC x0E,W
3EA0:  MOVWF  FEA
3EA2:  MOVFF  FEC,317
3EA6:  MOVF   FED,F
3EA8:  MOVFF  FEF,316
3EAC:  MOVLW  0D
3EAE:  ADDWF  x0D,W
3EB0:  MOVWF  FE9
3EB2:  MOVLW  00
3EB4:  ADDWFC x0E,W
3EB6:  MOVWF  FEA
3EB8:  MOVFF  FEC,319
3EBC:  MOVF   FED,F
3EBE:  MOVFF  FEF,318
3EC2:  MOVLW  1A
3EC4:  ADDWF  x0D,W
3EC6:  MOVWF  FE9
3EC8:  MOVLW  00
3ECA:  ADDWFC x0E,W
3ECC:  MOVWF  FEA
3ECE:  MOVFF  FEF,31A
3ED2:  MOVFF  FEC,31B
3ED6:  MOVFF  FEC,31C
3EDA:  MOVFF  FEC,31D
3EDE:  MOVFF  03,35A
3EE2:  MOVFF  01,359
3EE6:  MOVFF  317,35C
3EEA:  MOVFF  316,35B
3EEE:  MOVFF  319,35E
3EF2:  MOVFF  318,35D
3EF6:  MOVFF  312,362
3EFA:  MOVFF  311,361
3EFE:  MOVFF  310,360
3F02:  MOVFF  30F,35F
3F06:  MOVFF  31D,366
3F0A:  MOVFF  31C,365
3F0E:  MOVFF  31B,364
3F12:  MOVFF  31A,363
3F16:  MOVFF  313,367
3F1A:  MOVLW  FF
3F1C:  MOVWF  x68
3F1E:  CLRF   x6A
3F20:  CLRF   x69
3F22:  MOVLB  0
3F24:  CALL   28FA
3F28:  MOVLB  3
....................       } 
....................  
....................       /*if (debugLastState != ps->smState) 
....................       { 
....................          debug_tcp("\r\nTCP TICK %u - ", s); 
....................          DebugTCPDisplayState(debugLastState); 
....................          debug_tcp(" -> "); 
....................          DebugTCPDisplayState(ps->smState); 
....................       }*/ 
....................    } 
3F2A:  INCF   x08,F
3F2C:  BRA    3A9A
3F2E:  MOVLB  0
.................... } 
3F30:  GOTO   6D04 (RETURN)
....................  
.................... /********************************************************************* 
.................... * Function:        BOOL TCPProcess(NODE_INFO* remote, 
.................... *                                  IP_ADDR *localIP, 
.................... *                                  WORD len) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCP segment is ready in MAC buffer 
.................... * 
.................... * Input:           remote      - Remote node info 
.................... *                  len         - Total length of TCP semgent. 
.................... * 
.................... * Output:          TRUE if this function has completed its task 
.................... *                  FALSE otherwise 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... BOOL TCPProcess(NODE_INFO *remote, IP_ADDR *localIP, WORD len) 
.................... { 
....................    TCP_HEADER      TCPHeader; 
....................    PSEUDO_HEADER   pseudoHeader; 
....................    TCP_SOCKET      socket; 
....................    WORD_VAL        checksum1; 
....................    WORD_VAL        checksum2; 
....................    BYTE            optionsSize; 
....................    
....................    // Calculate IP pseudoheader checksum. 
....................    pseudoHeader.SourceAddress      = remote->IPAddr; 
*
361E:  MOVLW  06
3620:  MOVLB  3
3622:  ADDWF  x08,W
3624:  MOVWF  FE9
3626:  MOVLW  00
3628:  ADDWFC x09,W
362A:  MOVWF  FEA
362C:  MOVFF  FEF,00
3630:  MOVFF  FEC,01
3634:  MOVFF  FEC,02
3638:  MOVFF  FEC,03
363C:  MOVFF  03,325
3640:  MOVFF  02,324
3644:  MOVFF  01,323
3648:  MOVFF  00,322
....................    pseudoHeader.DestAddress        = *localIP; 
364C:  MOVFF  30A,FE9
3650:  MOVFF  30B,FEA
3654:  MOVFF  FEF,00
3658:  MOVFF  FEC,01
365C:  MOVFF  FEC,02
3660:  MOVFF  FEC,03
3664:  MOVFF  03,329
3668:  MOVFF  02,328
366C:  MOVFF  01,327
3670:  MOVFF  00,326
....................    pseudoHeader.Zero               = 0x0; 
3674:  CLRF   x2A
....................    pseudoHeader.Protocol           = IP_PROT_TCP; 
3676:  MOVLW  06
3678:  MOVWF  x2B
....................    pseudoHeader.TCPLength          = len; 
367A:  MOVFF  30D,32D
367E:  MOVFF  30C,32C
....................  
....................    SwapPseudoTCPHeader(pseudoHeader); 
3682:  MOVFF  32D,3B1
3686:  MOVFF  32C,3B0
368A:  MOVLB  0
368C:  CALL   1146
3690:  MOVFF  02,32D
3694:  MOVFF  01,32C
....................  
....................    checksum1.Val = ~CalcIPChecksum((BYTE*)&pseudoHeader, 
....................       sizeof(pseudoHeader)); 
3698:  MOVLW  03
369A:  MOVLB  3
369C:  MOVWF  x35
369E:  MOVLW  22
36A0:  MOVFF  335,394
36A4:  MOVWF  x93
36A6:  CLRF   x96
36A8:  MOVLW  0C
36AA:  MOVWF  x95
36AC:  MOVLB  0
36AE:  CALL   1DE2
36B2:  MOVFF  01,32F
36B6:  MOVLB  3
36B8:  COMF   x2F,F
36BA:  MOVFF  02,330
36BE:  COMF   x30,F
....................  
....................  
....................    // Now calculate TCP packet checksum in NIC RAM - should match 
....................    // pesudo header checksum 
....................    checksum2.Val = CalcIPBufferChecksum(len); 
36C0:  MOVFF  30D,392
36C4:  MOVFF  30C,391
36C8:  MOVLB  0
36CA:  CALL   1EFC
36CE:  MOVFF  02,332
36D2:  MOVFF  01,331
....................  
....................    // Compare checksums.  Note that the endianness is different. 
....................    if(checksum1.v[0] != checksum2.v[1] || checksum1.v[1] != checksum2.v[0]) 
36D6:  MOVLB  3
36D8:  MOVF   x32,W
36DA:  SUBWF  x2F,W
36DC:  BNZ   36E4
36DE:  MOVF   x31,W
36E0:  SUBWF  x30,W
36E2:  BZ    36F2
....................    { 
....................       MACDiscardRx(); 
36E4:  MOVLB  0
36E6:  CALL   1076
....................       return TRUE; 
36EA:  MOVLW  01
36EC:  MOVWF  01
36EE:  BRA    37C6
36F0:  MOVLB  3
....................    } 
....................  
....................    // Retrieve TCP header. 
....................    IPSetRxBuffer(0); 
36F2:  CLRF   x37
36F4:  CLRF   x36
36F6:  MOVLB  0
36F8:  CALL   2054
....................    MACGetArray((BYTE*)&TCPHeader, sizeof(TCPHeader)); 
36FC:  MOVLW  03
36FE:  MOVLB  3
3700:  MOVWF  x35
3702:  MOVLW  0E
3704:  MOVFF  335,3A0
3708:  MOVWF  x9F
370A:  CLRF   xA2
370C:  MOVLW  14
370E:  MOVWF  xA1
3710:  MOVLB  0
3712:  CALL   10E2
....................    SwapTCPHeader(&TCPHeader); 
3716:  MOVLW  03
3718:  MOVLB  3
371A:  MOVWF  x92
371C:  MOVLW  0E
371E:  MOVWF  x91
3720:  MOVLB  0
3722:  CALL   2090
....................  
....................  
....................    // Skip over options and retrieve all data bytes. 
....................    optionsSize = (BYTE)((TCPHeader.DataOffset.Val << 2)- 
....................       sizeof(TCPHeader)); 
3726:  MOVLB  3
3728:  SWAPF  x1A,W
372A:  ANDLW  0F
372C:  MOVWF  00
372E:  RLCF   00,W
3730:  MOVWF  x35
3732:  RLCF   x35,F
3734:  MOVLW  FC
3736:  ANDWF  x35,F
3738:  MOVLW  14
373A:  SUBWF  x35,W
373C:  MOVWF  x33
....................    len = len - optionsSize - sizeof(TCPHeader); 
373E:  MOVF   x33,W
3740:  SUBWF  x0C,W
3742:  MOVWF  x34
3744:  MOVLW  00
3746:  SUBWFB x0D,W
3748:  MOVWF  x35
374A:  MOVLW  14
374C:  SUBWF  x34,W
374E:  MOVWF  x0C
3750:  MOVLW  00
3752:  SUBWFB x35,W
3754:  MOVWF  x0D
....................  
....................    // Position packet read pointer to start of data area. 
....................    IPSetRxBuffer((TCPHeader.DataOffset.Val << 2)); 
3756:  SWAPF  x1A,W
3758:  ANDLW  0F
375A:  MOVWF  00
375C:  RLCF   00,W
375E:  MOVWF  x35
3760:  RLCF   x35,F
3762:  MOVLW  FC
3764:  ANDWF  x35,F
3766:  CLRF   x37
3768:  MOVFF  335,336
376C:  MOVLB  0
376E:  CALL   2054
....................  
....................    // Find matching socket. 
....................    socket =FindMatching_TCP_Socket(&TCPHeader, remote); 
3772:  MOVLW  03
3774:  MOVLB  3
3776:  MOVWF  x35
3778:  MOVLW  0E
377A:  MOVWF  x34
377C:  MOVFF  309,337
3780:  MOVFF  308,336
3784:  MOVLB  0
3786:  GOTO   22B6
378A:  MOVFF  01,32E
....................    if(socket != INVALID_SOCKET) 
378E:  MOVLB  3
3790:  MOVF   x2E,W
3792:  SUBLW  FE
3794:  BZ    37BC
....................    { 
....................       HandleTCPSeg(socket, remote, &TCPHeader, len); 
3796:  MOVFF  32E,334
379A:  MOVFF  309,336
379E:  MOVFF  308,335
37A2:  MOVLW  03
37A4:  MOVWF  x38
37A6:  MOVLW  0E
37A8:  MOVWF  x37
37AA:  MOVFF  30D,33A
37AE:  MOVFF  30C,339
37B2:  MOVLB  0
37B4:  GOTO   2B28
....................    } 
....................    else 
37B8:  BRA    37C2
37BA:  MOVLB  3
....................    { 
....................       // If this is an unknown socket, or we don't have any 
....................       // listening sockets available, discard it we can't 
....................       // process it right now 
....................       MACDiscardRx(); 
37BC:  MOVLB  0
37BE:  CALL   1076
....................  
.................... //      // Send a RESET to the remote node is it knows that we 
.................... //      // are not available 
.................... //      TCPHeader.AckNumber += len; 
.................... //      if( TCPHeader.Flags.bits.flagSYN || 
.................... //         TCPHeader.Flags.bits.flagFIN ) 
.................... //         TCPHeader.AckNumber++; 
.................... // 
.................... //      SendTCP(remote, 
.................... //         TCPHeader.DestPort, 
.................... //         TCPHeader.SourcePort, 
.................... //         TCPHeader.AckNumber, 
.................... //         TCPHeader.SeqNumber, 
.................... //         RST); 
....................    } 
....................  
....................    return TRUE; 
37C2:  MOVLW  01
37C4:  MOVWF  01
.................... } 
37C6:  GOTO   6C40 (RETURN)
....................  
.................... /********************************************************************* 
.................... * Function:        static void TransmitTCP(NODE_INFO* remote 
.................... *                                          TCP_PORT localPort, 
.................... *                                          TCP_PORT remotePort, 
.................... *                                          DWORD seq, 
.................... *                                          DWORD ack, 
.................... *                                          BYTE flags, 
.................... *                                          BUFFER buffer, 
.................... *                                          WORD len) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCPIsPutReady() == TRUE 
.................... * 
.................... * Input:           remote      - Remote node info 
.................... *                  localPort   - Source port number 
.................... *                  remotePort  - Destination port number 
.................... *                  seq         - Segment sequence number 
.................... *                  ack         - Segment acknowledge number 
.................... *                  flags       - Segment flags 
.................... *                  buffer      - Buffer to which this segment 
.................... *                                is to be transmitted 
.................... *                  len         - Total data length for this segment. 
.................... * 
.................... * Output:          A TCP segment is assembled and put to transmit. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... static void TransmitTCP(NODE_INFO *remote, 
....................                   TCP_PORT localPort, 
....................                   TCP_PORT remotePort, 
....................                   DWORD tseq, 
....................                   DWORD tack, 
....................                   BYTE flags, 
....................                   BUFFER buff, 
....................                   WORD len) 
.................... { 
....................    WORD_VAL        checkSum; 
....................    TCP_HEADER      header; 
....................    TCP_OPTIONS     options; 
....................    PSEUDO_HEADER   pseudoHeader; 
....................  
....................    debug_tcp("\r\n\nTCP OUT => LP:%LX RP:%LX SEQ:%LX ACK:%LX LEN:%LX FL:%X", 
....................       localPort, 
....................       remotePort, 
....................       tseq, 
....................       tack, 
....................       len, 
....................       flags 
....................    ); 
....................  
....................    //  Make sure that this Tx buffer isn't currently being transmitted 
....................    while( !IPIsTxReady(TRUE) );   //TODO: This may need to be conditionally false 
*
28FA:  MOVLW  01
28FC:  MOVLB  3
28FE:  MOVWF  x91
2900:  MOVLB  0
2902:  RCALL  25B2
2904:  MOVF   01,F
2906:  BZ    28FA
....................  
....................    // Obtain an AutoFree buffer if this packet is a control packet 
....................    // only (contains no application data in an already allocated 
....................    // buffer) 
....................    if(buff == INVALID_BUFFER) 
2908:  MOVLB  3
290A:  INCFSZ x68,W
290C:  BRA    291E
....................       buff = MACGetTxBuffer(TRUE); 
290E:  MOVLW  01
2910:  MOVWF  x91
2912:  MOVLB  0
2914:  CALL   1448
2918:  MOVFF  01,368
291C:  MOVLB  3
....................  
....................    if(buff == INVALID_BUFFER) 
291E:  INCFSZ x68,W
2920:  BRA    2924
....................       return; 
2922:  BRA    2B24
....................  
....................    IPSetTxBuffer(buff, 0); 
2924:  MOVFF  368,3AA
2928:  CLRF   xAC
292A:  MOVLW  14
292C:  MOVWF  xAB
292E:  MOVLB  0
2930:  CALL   1472
....................  
....................    header.SourcePort           = localPort; 
2934:  MOVFF  35C,36E
2938:  MOVFF  35B,36D
....................    header.DestPort             = remotePort; 
293C:  MOVFF  35E,370
2940:  MOVFF  35D,36F
....................    header.SeqNumber            = tseq; 
2944:  MOVFF  362,374
2948:  MOVFF  361,373
294C:  MOVFF  360,372
2950:  MOVFF  35F,371
....................    header.AckNumber            = tack; 
2954:  MOVFF  366,378
2958:  MOVFF  365,377
295C:  MOVFF  364,376
2960:  MOVFF  363,375
....................    header.Flags.bits.Reserved2 = 0; 
2964:  MOVLW  3F
2966:  MOVLB  3
2968:  ANDWF  x7A,W
296A:  MOVWF  x7A
....................    header.DataOffset.Reserved3 = 0; 
296C:  MOVLW  F0
296E:  ANDWF  x79,W
2970:  MOVWF  x79
....................    header.Flags.b              = flags; 
2972:  MOVFF  367,37A
....................    // Receive window = MAC Free buffer size - TCP header (20) - IP header (20) 
....................    //                  - ETHERNET header (14 if using NIC) . 
....................    header.Window               = MACGetFreeRxSize(); 
2976:  MOVLB  0
2978:  BRA    25DC
297A:  MOVFF  02,37C
297E:  MOVFF  01,37B
.................... #if !defined(STACK_USE_SLIP) 
....................    /* 
....................    * Limit one segment at a time from remote host. 
....................    * This limit increases overall throughput as remote host does not 
....................    * flood us with packets and later retry with significant delay. 
....................    */ 
....................    if ( header.Window >= MAC_RX_BUFFER_SIZE ) 
....................       header.Window = MAC_RX_BUFFER_SIZE; 
....................  
....................    else if ( header.Window > 54 ) 
....................    { 
....................       header.Window -= 54; 
....................    } 
....................    else 
....................       header.Window = 0; 
.................... #else 
....................    if ( header.Window > 40 ) 
2982:  MOVLB  3
2984:  MOVF   x7C,F
2986:  BNZ   298E
2988:  MOVF   x7B,W
298A:  SUBLW  28
298C:  BC    2998
....................    { 
....................       header.Window -= 40; 
298E:  MOVLW  28
2990:  SUBWF  x7B,F
2992:  MOVLW  00
2994:  SUBWFB x7C,F
....................    } 
....................    else 
2996:  BRA    299C
....................       header.Window = 0; 
2998:  CLRF   x7C
299A:  CLRF   x7B
.................... #endif 
....................  
....................    header.Checksum             = 0; 
299C:  CLRF   x7E
299E:  CLRF   x7D
....................    header.UrgentPointer        = 0; 
29A0:  CLRF   x80
29A2:  CLRF   x7F
....................  
....................    SwapTCPHeader(&header); 
29A4:  MOVLW  03
29A6:  MOVWF  x92
29A8:  MOVLW  6D
29AA:  MOVWF  x91
29AC:  MOVLB  0
29AE:  CALL   2090
....................  
....................    len += sizeof(header); 
29B2:  MOVLW  14
29B4:  MOVLB  3
29B6:  ADDWF  x69,F
29B8:  MOVLW  00
29BA:  ADDWFC x6A,F
....................  
....................    if ( flags & SYN ) 
29BC:  BTFSS  x67.1
29BE:  BRA    29DE
....................    { 
....................       len += sizeof(options); 
29C0:  MOVLW  04
29C2:  ADDWF  x69,F
29C4:  MOVLW  00
29C6:  ADDWFC x6A,F
....................       options.Kind = TCP_OPTIONS_MAX_SEG_SIZE; 
29C8:  MOVLW  02
29CA:  MOVWF  x81
....................       options.Length = 0x04; 
29CC:  MOVLW  04
29CE:  MOVWF  x82
....................  
....................       // Load MSS in already swapped order. 
....................       options.MaxSegSize.v[0]  = (MAC_RX_BUFFER_SIZE >> 8); // 0x05; 
29D0:  MOVWF  x83
....................       options.MaxSegSize.v[1]  = (MAC_RX_BUFFER_SIZE & 0xff); // 0xb4; 
29D2:  CLRF   x84
....................  
....................       header.DataOffset.Val   = (sizeof(header) + sizeof(options)) >> 2; 
29D4:  MOVLW  0F
29D6:  ANDWF  x79,W
29D8:  IORLW  60
29DA:  MOVWF  x79
....................    } 
....................    else 
29DC:  BRA    29E6
....................       header.DataOffset.Val   = sizeof(header) >> 2; 
29DE:  MOVLW  0F
29E0:  ANDWF  x79,W
29E2:  IORLW  50
29E4:  MOVWF  x79
....................  
....................  
....................    // Calculate IP pseudoheader checksum. 
....................    pseudoHeader.SourceAddress   = AppConfig.MyIPAddr; 
29E6:  MOVFF  1B,388
29EA:  MOVFF  1A,387
29EE:  MOVFF  19,386
29F2:  MOVFF  18,385
....................    pseudoHeader.DestAddress    = remote->IPAddr; 
29F6:  MOVLW  06
29F8:  ADDWF  x59,W
29FA:  MOVWF  FE9
29FC:  MOVLW  00
29FE:  ADDWFC x5A,W
2A00:  MOVWF  FEA
2A02:  MOVFF  FEF,00
2A06:  MOVFF  FEC,01
2A0A:  MOVFF  FEC,02
2A0E:  MOVFF  FEC,03
2A12:  MOVFF  03,38C
2A16:  MOVFF  02,38B
2A1A:  MOVFF  01,38A
2A1E:  MOVFF  00,389
....................    pseudoHeader.Zero           = 0x0; 
2A22:  CLRF   x8D
....................    pseudoHeader.Protocol       = IP_PROT_TCP; 
2A24:  MOVLW  06
2A26:  MOVWF  x8E
....................    pseudoHeader.TCPLength      = len; 
2A28:  MOVFF  36A,390
2A2C:  MOVFF  369,38F
....................  
....................    SwapPseudoTCPHeader(pseudoHeader); 
2A30:  MOVFF  390,3B1
2A34:  MOVFF  38F,3B0
2A38:  MOVLB  0
2A3A:  CALL   1146
2A3E:  MOVFF  02,390
2A42:  MOVFF  01,38F
....................  
....................    header.Checksum = ~CalcIPChecksum((BYTE*)&pseudoHeader, 
....................       sizeof(pseudoHeader)); 
2A46:  MOVLW  03
2A48:  MOVLB  3
2A4A:  MOVWF  x92
2A4C:  MOVLW  85
2A4E:  MOVFF  392,394
2A52:  MOVWF  x93
2A54:  CLRF   x96
2A56:  MOVLW  0C
2A58:  MOVWF  x95
2A5A:  MOVLB  0
2A5C:  CALL   1DE2
2A60:  MOVFF  01,37D
2A64:  MOVLB  3
2A66:  COMF   x7D,F
2A68:  MOVFF  02,37E
2A6C:  COMF   x7E,F
....................    checkSum.Val = header.Checksum; 
2A6E:  MOVFF  37E,36C
2A72:  MOVFF  37D,36B
....................  
....................    // Write IP header. 
....................    IPPutHeader(remote, IP_PROT_TCP, len); 
2A76:  MOVFF  35A,392
2A7A:  MOVFF  359,391
2A7E:  MOVLW  06
2A80:  MOVWF  x93
2A82:  MOVFF  36A,395
2A86:  MOVFF  369,394
2A8A:  MOVLB  0
2A8C:  RCALL  27CE
....................    IPPutArray((BYTE*)&header, sizeof(header)); 
2A8E:  MOVLW  03
2A90:  MOVLB  3
2A92:  MOVWF  x92
2A94:  MOVLW  6D
2A96:  MOVFF  392,3B6
2A9A:  MOVWF  xB5
2A9C:  CLRF   xB8
2A9E:  MOVLW  14
2AA0:  MOVWF  xB7
2AA2:  MOVLB  0
2AA4:  CALL   153A
....................  
....................    if ( flags & SYN ) 
2AA8:  MOVLB  3
2AAA:  BTFSS  x67.1
2AAC:  BRA    2AC8
....................       IPPutArray((BYTE*)&options, sizeof(options)); 
2AAE:  MOVLW  03
2AB0:  MOVWF  x92
2AB2:  MOVLW  81
2AB4:  MOVFF  392,3B6
2AB8:  MOVWF  xB5
2ABA:  CLRF   xB8
2ABC:  MOVLW  04
2ABE:  MOVWF  xB7
2AC0:  MOVLB  0
2AC2:  CALL   153A
2AC6:  MOVLB  3
....................  
....................    IPSetTxBuffer(buff, 0); 
2AC8:  MOVFF  368,3AA
2ACC:  CLRF   xAC
2ACE:  MOVLW  14
2AD0:  MOVWF  xAB
2AD2:  MOVLB  0
2AD4:  CALL   1472
....................  
....................    checkSum.Val = CalcIPBufferChecksum(len); 
2AD8:  MOVFF  36A,392
2ADC:  MOVFF  369,391
2AE0:  CALL   1EFC
2AE4:  MOVFF  02,36C
2AE8:  MOVFF  01,36B
....................  
....................    // Update the checksum. 
....................    IPSetTxBuffer(buff, 16); 
2AEC:  MOVFF  368,3AA
2AF0:  MOVLB  3
2AF2:  CLRF   xAC
2AF4:  MOVLW  24
2AF6:  MOVWF  xAB
2AF8:  MOVLB  0
2AFA:  CALL   1472
....................    MACPut(checkSum.v[1]); 
2AFE:  MOVFF  36C,3B4
2B02:  CALL   151C
....................    MACPut(checkSum.v[0]); 
2B06:  MOVFF  36B,3B4
2B0A:  CALL   151C
....................    MACSetTxBuffer(buff, 0); 
2B0E:  MOVFF  368,3AA
2B12:  MOVLB  3
2B14:  CLRF   xAC
2B16:  CLRF   xAB
2B18:  MOVLB  0
2B1A:  CALL   1472
....................  
....................    MACFlush(); 
2B1E:  CALL   1656
2B22:  MOVLB  3
....................  
.................... #if !TCP_NO_WAIT_FOR_ACK /*&& !defined(DEBUG)*/ 
....................    // If we send the packet again, the remote node might think that we timed 
....................    // out and retransmitted.  It could thus immediately send back an ACK and 
....................    // dramatically improve throuput. 
....................    //while(!IPIsTxReady(TRUE)); 
....................    //MACFlush(); 
.................... #endif 
.................... } 
2B24:  MOVLB  0
2B26:  RETLW  00
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, 
....................  *                                      NODE_INFO* remote) 
....................  * 
....................  * PreCondition:    TCPInit() is already called 
....................  * 
....................  * Input:           h           - TCP Header to be matched against. 
....................  *                  remote      - Node who sent this header. 
....................  * 
....................  * Output:          A socket that matches with given header and remote 
....................  *                  node is searched. 
....................  *                  If such socket is found, its index is returned 
....................  *                  else INVALID_SOCKET is returned. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, NODE_INFO *remote) 
.................... { 
....................    SOCKET_INFO *ps; 
....................    TCP_SOCKET s; 
....................    TCP_SOCKET partialMatch; 
....................  
....................    partialMatch = INVALID_SOCKET; 
*
22B6:  MOVLW  FE
22B8:  MOVLB  3
22BA:  MOVWF  x3B
....................  
....................    for ( s = 0; s < MAX_SOCKETS; s++ ) 
22BC:  CLRF   x3A
22BE:  MOVF   x3A,W
22C0:  SUBLW  04
22C2:  BTFSS  FD8.0
22C4:  BRA    23BA
....................    { 
....................       ps = &TCB[s]; 
22C6:  MOVF   x3A,W
22C8:  MULLW  24
22CA:  MOVF   FF3,W
22CC:  CLRF   03
22CE:  ADDLW  5F
22D0:  MOVWF  01
22D2:  MOVLW  00
22D4:  ADDWFC 03,F
22D6:  MOVFF  01,338
22DA:  MOVFF  03,339
....................  
....................       if ( ps->smState != TCP_CLOSED ) 
22DE:  MOVFF  338,FE9
22E2:  MOVFF  339,FEA
22E6:  MOVF   FEF,W
22E8:  SUBLW  0A
22EA:  BZ    23B6
....................       { 
....................          if ( ps->localPort == h->DestPort ) 
22EC:  MOVLW  0B
22EE:  ADDWF  x38,W
22F0:  MOVWF  FE9
22F2:  MOVLW  00
22F4:  ADDWFC x39,W
22F6:  MOVWF  FEA
22F8:  MOVFF  FEC,33D
22FC:  MOVF   FED,F
22FE:  MOVFF  FEF,33C
2302:  MOVLW  02
2304:  ADDWF  x34,W
2306:  MOVWF  FE9
2308:  MOVLW  00
230A:  ADDWFC x35,W
230C:  MOVWF  FEA
230E:  MOVFF  FEC,03
2312:  MOVF   FED,F
2314:  MOVF   FEF,W
2316:  SUBWF  x3C,W
2318:  BNZ   23B6
231A:  MOVF   03,W
231C:  SUBWF  x3D,W
231E:  BNZ   23B6
....................          { 
....................             if ( ps->smState == TCP_LISTEN ) 
2320:  MOVFF  338,FE9
2324:  MOVFF  339,FEA
2328:  MOVF   FEF,F
232A:  BNZ   2330
....................                partialMatch = s; 
232C:  MOVFF  33A,33B
....................  
....................             if ( ps->remotePort == h->SourcePort && 
....................                ps->remote.IPAddr.Val == remote->IPAddr.Val ) 
2330:  MOVLW  0D
2332:  ADDWF  x38,W
2334:  MOVWF  FE9
2336:  MOVLW  00
2338:  ADDWFC x39,W
233A:  MOVWF  FEA
233C:  MOVFF  FEC,33D
2340:  MOVF   FED,F
2342:  MOVFF  FEF,33C
2346:  MOVFF  334,FE9
234A:  MOVFF  335,FEA
234E:  MOVFF  FEC,03
2352:  MOVF   FED,F
2354:  MOVF   FEF,W
2356:  SUBWF  x3C,W
2358:  BNZ   23B6
235A:  MOVF   03,W
235C:  SUBWF  x3D,W
235E:  BNZ   23B6
2360:  MOVLW  07
2362:  ADDWF  x38,W
2364:  MOVWF  FE9
2366:  MOVLW  00
2368:  ADDWFC x39,W
236A:  MOVWF  FEA
236C:  MOVFF  FEF,33E
2370:  MOVFF  FEC,33F
2374:  MOVFF  FEC,340
2378:  MOVFF  FEC,341
237C:  MOVLW  06
237E:  ADDWF  x36,W
2380:  MOVWF  FE9
2382:  MOVLW  00
2384:  ADDWFC x37,W
2386:  MOVWF  FEA
2388:  MOVFF  FEF,00
238C:  MOVFF  FEC,01
2390:  MOVFF  FEC,02
2394:  MOVFF  FEC,03
2398:  MOVF   00,W
239A:  SUBWF  x3E,W
239C:  BNZ   23B6
239E:  MOVF   01,W
23A0:  SUBWF  x3F,W
23A2:  BNZ   23B6
23A4:  MOVF   02,W
23A6:  SUBWF  x40,W
23A8:  BNZ   23B6
23AA:  MOVF   03,W
23AC:  SUBWF  x41,W
23AE:  BNZ   23B6
....................             { 
....................                return s; 
23B0:  MOVFF  33A,01
23B4:  BRA    248E
....................             } 
....................          } 
....................       } 
....................    } 
23B6:  INCF   x3A,F
23B8:  BRA    22BE
....................  
....................    // We are not listening on this port 
....................    if(partialMatch == INVALID_SOCKET) 
23BA:  MOVF   x3B,W
23BC:  SUBLW  FE
23BE:  BNZ   23C6
....................       return INVALID_SOCKET; 
23C0:  MOVLW  FE
23C2:  MOVWF  01
23C4:  BRA    248E
....................  
....................    // Copy the remote node IP/MAC address and source TCP port 
....................    // number into our TCB and return this socket to the caller 
....................    ps = &TCB[partialMatch]; 
23C6:  MOVF   x3B,W
23C8:  MULLW  24
23CA:  MOVF   FF3,W
23CC:  CLRF   03
23CE:  ADDLW  5F
23D0:  MOVWF  01
23D2:  MOVLW  00
23D4:  ADDWFC 03,F
23D6:  MOVFF  01,338
23DA:  MOVFF  03,339
....................    memcpy((void*)&ps->remote, (void*)remote, sizeof(*remote)); 
23DE:  MOVLW  01
23E0:  ADDWF  x38,W
23E2:  MOVWF  x3C
23E4:  MOVLW  00
23E6:  ADDWFC x39,W
23E8:  MOVWF  x3D
23EA:  MOVWF  FEA
23EC:  MOVFF  33C,FE9
23F0:  MOVFF  337,FE2
23F4:  MOVFF  336,FE1
23F8:  MOVLW  0A
23FA:  MOVWF  01
23FC:  MOVFF  FE6,FEE
2400:  DECFSZ 01,F
2402:  BRA    23FC
....................    ps->remotePort          = h->SourcePort; 
2404:  MOVLW  0D
2406:  ADDWF  x38,W
2408:  MOVWF  01
240A:  MOVLW  00
240C:  ADDWFC x39,W
240E:  MOVFF  334,FE9
2412:  MOVFF  335,FEA
2416:  MOVFF  FEC,03
241A:  MOVF   FED,F
241C:  MOVFF  FEF,33E
2420:  MOVWF  FEA
2422:  MOVFF  01,FE9
2426:  MOVFF  03,FEC
242A:  MOVF   FED,F
242C:  MOVFF  33E,FEF
....................    ps->Flags.bIsGetReady   = FALSE; 
2430:  MOVLW  23
2432:  ADDWF  x38,W
2434:  MOVWF  FE9
2436:  MOVLW  00
2438:  ADDWFC x39,W
243A:  MOVWF  FEA
243C:  BCF    FEF.3
....................    if(ps->TxBuffer != INVALID_BUFFER) 
243E:  MOVLW  0F
2440:  ADDWF  x38,W
2442:  MOVWF  FE9
2444:  MOVLW  00
2446:  ADDWFC x39,W
2448:  MOVWF  FEA
244A:  INCFSZ FEF,W
244C:  BRA    2450
244E:  BRA    247C
....................    { 
....................       MACDiscardTx(ps->TxBuffer); 
2450:  MOVLW  0F
2452:  ADDWF  x38,W
2454:  MOVWF  FE9
2456:  MOVLW  00
2458:  ADDWFC x39,W
245A:  MOVWF  FEA
245C:  MOVFF  FEF,33C
2460:  MOVFF  33C,355
2464:  MOVLB  0
2466:  CALL   0004
....................       ps->TxBuffer        = INVALID_BUFFER; 
246A:  MOVLW  0F
246C:  MOVLB  3
246E:  ADDWF  x38,W
2470:  MOVWF  FE9
2472:  MOVLW  00
2474:  ADDWFC x39,W
2476:  MOVWF  FEA
2478:  MOVLW  FF
247A:  MOVWF  FEF
....................    } 
....................    ps->Flags.bIsPutReady   = TRUE; 
247C:  MOVLW  23
247E:  ADDWF  x38,W
2480:  MOVWF  FE9
2482:  MOVLW  00
2484:  ADDWFC x39,W
2486:  MOVWF  FEA
2488:  BSF    FEF.1
....................  
....................    return partialMatch; 
248A:  MOVFF  33B,01
.................... } 
248E:  MOVLB  0
2490:  GOTO   378A (RETURN)
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static void SwapTCPHeader(TCP_HEADER* header) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           header      - TCP Header to be swapped. 
....................  * 
....................  * Output:          Given header is swapped. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void SwapTCPHeader(TCP_HEADER* header) 
.................... { 
....................     header->SourcePort      = swaps(header->SourcePort); 
*
2090:  MOVLB  3
2092:  MOVFF  391,01
2096:  MOVFF  392,03
209A:  MOVFF  391,393
209E:  MOVFF  392,394
20A2:  MOVFF  391,FE9
20A6:  MOVFF  392,FEA
20AA:  MOVFF  FEC,396
20AE:  MOVF   FED,F
20B0:  MOVFF  FEF,395
20B4:  MOVFF  396,3B1
20B8:  MOVFF  395,3B0
20BC:  MOVLB  0
20BE:  CALL   1146
20C2:  MOVFF  394,FEA
20C6:  MOVFF  393,FE9
20CA:  MOVFF  02,FEC
20CE:  MOVF   FED,F
20D0:  MOVFF  01,FEF
....................     header->DestPort        = swaps(header->DestPort); 
20D4:  MOVLW  02
20D6:  MOVLB  3
20D8:  ADDWF  x91,W
20DA:  MOVWF  01
20DC:  MOVLW  00
20DE:  ADDWFC x92,W
20E0:  MOVWF  03
20E2:  MOVFF  01,393
20E6:  MOVWF  x94
20E8:  MOVLW  02
20EA:  ADDWF  x91,W
20EC:  MOVWF  FE9
20EE:  MOVLW  00
20F0:  ADDWFC x92,W
20F2:  MOVWF  FEA
20F4:  MOVFF  FEC,396
20F8:  MOVF   FED,F
20FA:  MOVFF  FEF,395
20FE:  MOVFF  396,3B1
2102:  MOVFF  395,3B0
2106:  MOVLB  0
2108:  CALL   1146
210C:  MOVFF  394,FEA
2110:  MOVFF  393,FE9
2114:  MOVFF  02,FEC
2118:  MOVF   FED,F
211A:  MOVFF  01,FEF
....................     header->SeqNumber       = swapl(header->SeqNumber); 
211E:  MOVLW  04
2120:  MOVLB  3
2122:  ADDWF  x91,W
2124:  MOVWF  01
2126:  MOVLW  00
2128:  ADDWFC x92,W
212A:  MOVWF  03
212C:  MOVFF  01,393
2130:  MOVWF  x94
2132:  MOVLW  04
2134:  ADDWF  x91,W
2136:  MOVWF  FE9
2138:  MOVLW  00
213A:  ADDWFC x92,W
213C:  MOVWF  FEA
213E:  MOVFF  FEF,395
2142:  MOVFF  FEC,396
2146:  MOVFF  FEC,397
214A:  MOVFF  FEC,398
214E:  MOVFF  398,39C
2152:  MOVFF  397,39B
2156:  MOVFF  396,39A
215A:  MOVFF  395,399
215E:  MOVLB  0
2160:  RCALL  206E
2162:  MOVFF  394,FEA
2166:  MOVFF  393,FE9
216A:  MOVFF  00,FEF
216E:  MOVFF  01,FEC
2172:  MOVFF  02,FEC
2176:  MOVFF  03,FEC
....................     header->AckNumber       = swapl(header->AckNumber); 
217A:  MOVLW  08
217C:  MOVLB  3
217E:  ADDWF  x91,W
2180:  MOVWF  01
2182:  MOVLW  00
2184:  ADDWFC x92,W
2186:  MOVWF  03
2188:  MOVFF  01,393
218C:  MOVWF  x94
218E:  MOVLW  08
2190:  ADDWF  x91,W
2192:  MOVWF  FE9
2194:  MOVLW  00
2196:  ADDWFC x92,W
2198:  MOVWF  FEA
219A:  MOVFF  FEF,395
219E:  MOVFF  FEC,396
21A2:  MOVFF  FEC,397
21A6:  MOVFF  FEC,398
21AA:  MOVFF  398,39C
21AE:  MOVFF  397,39B
21B2:  MOVFF  396,39A
21B6:  MOVFF  395,399
21BA:  MOVLB  0
21BC:  RCALL  206E
21BE:  MOVFF  394,FEA
21C2:  MOVFF  393,FE9
21C6:  MOVFF  00,FEF
21CA:  MOVFF  01,FEC
21CE:  MOVFF  02,FEC
21D2:  MOVFF  03,FEC
....................     header->Window          = swaps(header->Window); 
21D6:  MOVLW  0E
21D8:  MOVLB  3
21DA:  ADDWF  x91,W
21DC:  MOVWF  01
21DE:  MOVLW  00
21E0:  ADDWFC x92,W
21E2:  MOVWF  03
21E4:  MOVFF  01,393
21E8:  MOVWF  x94
21EA:  MOVLW  0E
21EC:  ADDWF  x91,W
21EE:  MOVWF  FE9
21F0:  MOVLW  00
21F2:  ADDWFC x92,W
21F4:  MOVWF  FEA
21F6:  MOVFF  FEC,396
21FA:  MOVF   FED,F
21FC:  MOVFF  FEF,395
2200:  MOVFF  396,3B1
2204:  MOVFF  395,3B0
2208:  MOVLB  0
220A:  CALL   1146
220E:  MOVFF  394,FEA
2212:  MOVFF  393,FE9
2216:  MOVFF  02,FEC
221A:  MOVF   FED,F
221C:  MOVFF  01,FEF
....................     header->Checksum        = swaps(header->Checksum); 
2220:  MOVLW  10
2222:  MOVLB  3
2224:  ADDWF  x91,W
2226:  MOVWF  01
2228:  MOVLW  00
222A:  ADDWFC x92,W
222C:  MOVWF  03
222E:  MOVFF  01,393
2232:  MOVWF  x94
2234:  MOVLW  10
2236:  ADDWF  x91,W
2238:  MOVWF  FE9
223A:  MOVLW  00
223C:  ADDWFC x92,W
223E:  MOVWF  FEA
2240:  MOVFF  FEC,396
2244:  MOVF   FED,F
2246:  MOVFF  FEF,395
224A:  MOVFF  396,3B1
224E:  MOVFF  395,3B0
2252:  MOVLB  0
2254:  CALL   1146
2258:  MOVFF  394,FEA
225C:  MOVFF  393,FE9
2260:  MOVFF  02,FEC
2264:  MOVF   FED,F
2266:  MOVFF  01,FEF
....................     header->UrgentPointer   = swaps(header->UrgentPointer); 
226A:  MOVLW  12
226C:  MOVLB  3
226E:  ADDWF  x91,W
2270:  MOVWF  01
2272:  MOVLW  00
2274:  ADDWFC x92,W
2276:  MOVWF  03
2278:  MOVFF  01,393
227C:  MOVWF  x94
227E:  MOVLW  12
2280:  ADDWF  x91,W
2282:  MOVWF  FE9
2284:  MOVLW  00
2286:  ADDWFC x92,W
2288:  MOVWF  FEA
228A:  MOVFF  FEC,396
228E:  MOVF   FED,F
2290:  MOVFF  FEF,395
2294:  MOVFF  396,3B1
2298:  MOVFF  395,3B0
229C:  MOVLB  0
229E:  CALL   1146
22A2:  MOVFF  394,FEA
22A6:  MOVFF  393,FE9
22AA:  MOVFF  02,FEC
22AE:  MOVF   FED,F
22B0:  MOVFF  01,FEF
.................... } 
22B4:  RETLW  00
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static void CloseSocket(SOCKET_INFO* ps) 
....................  * 
....................  * PreCondition:    TCPInit() is already called 
....................  * 
....................  * Input:           ps  - Pointer to a socket info that is to be 
....................  *                          closed. 
....................  * 
....................  * Output:          Given socket information is reset and any 
....................  *                  buffer held by this socket is discarded. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void CloseSocket(SOCKET_INFO* ps) 
.................... { 
....................    debug_tcp("\r\nTCP SOCKET CLOSED"); 
....................  
....................     if ( ps->TxBuffer != INVALID_BUFFER ) 
*
24AE:  MOVLW  0F
24B0:  MOVLB  3
24B2:  ADDWF  x52,W
24B4:  MOVWF  FE9
24B6:  MOVLW  00
24B8:  ADDWFC x53,W
24BA:  MOVWF  FEA
24BC:  INCFSZ FEF,W
24BE:  BRA    24C2
24C0:  BRA    24FC
....................     { 
....................         MACDiscardTx(ps->TxBuffer); 
24C2:  MOVLW  0F
24C4:  ADDWF  x52,W
24C6:  MOVWF  FE9
24C8:  MOVLW  00
24CA:  ADDWFC x53,W
24CC:  MOVWF  FEA
24CE:  MOVFF  FEF,354
24D2:  MOVFF  354,355
24D6:  MOVLB  0
24D8:  CALL   0004
....................         ps->TxBuffer            = INVALID_BUFFER; 
24DC:  MOVLW  0F
24DE:  MOVLB  3
24E0:  ADDWF  x52,W
24E2:  MOVWF  FE9
24E4:  MOVLW  00
24E6:  ADDWFC x53,W
24E8:  MOVWF  FEA
24EA:  MOVLW  FF
24EC:  MOVWF  FEF
....................         ps->Flags.bIsPutReady   = TRUE; 
24EE:  MOVLW  23
24F0:  ADDWF  x52,W
24F2:  MOVWF  FE9
24F4:  MOVLW  00
24F6:  ADDWFC x53,W
24F8:  MOVWF  FEA
24FA:  BSF    FEF.1
....................     } 
....................  
....................     ps->remote.IPAddr.Val = 0x00; 
24FC:  MOVLW  07
24FE:  ADDWF  x52,W
2500:  MOVWF  FE9
2502:  MOVLW  00
2504:  ADDWFC x53,W
2506:  MOVWF  FEA
2508:  MOVF   FEE,F
250A:  MOVF   FEE,F
250C:  CLRF   FEC
250E:  MOVF   FED,F
2510:  CLRF   FEF
2512:  MOVF   FED,F
2514:  CLRF   FEF
2516:  MOVF   FED,F
2518:  CLRF   FEF
....................     ps->remotePort = 0x00; 
251A:  MOVLW  0D
251C:  ADDWF  x52,W
251E:  MOVWF  FE9
2520:  MOVLW  00
2522:  ADDWFC x53,W
2524:  MOVWF  FEA
2526:  CLRF   FEC
2528:  MOVF   FED,F
252A:  CLRF   FEF
....................     if ( ps->Flags.bIsGetReady ) 
252C:  MOVLW  23
252E:  ADDWF  x52,W
2530:  MOVWF  FE9
2532:  MOVLW  00
2534:  ADDWFC x53,W
2536:  MOVWF  FEA
2538:  BTFSS  FEF.3
253A:  BRA    2544
....................     { 
....................         MACDiscardRx(); 
253C:  MOVLB  0
253E:  CALL   1076
2542:  MOVLB  3
....................     } 
....................     ps->Flags.bIsGetReady       = FALSE; 
2544:  MOVLW  23
2546:  ADDWF  x52,W
2548:  MOVWF  FE9
254A:  MOVLW  00
254C:  ADDWFC x53,W
254E:  MOVWF  FEA
2550:  BCF    FEF.3
....................     ps->TimeOut                 = TCP_START_TIMEOUT_VAL; 
2552:  MOVLW  21
2554:  ADDWF  x52,W
2556:  MOVWF  FE9
2558:  MOVLW  00
255A:  ADDWFC x53,W
255C:  MOVWF  FEA
255E:  CLRF   FEC
2560:  MOVF   FED,F
2562:  MOVLW  1E
2564:  MOVWF  FEF
....................  
....................     ps->Flags.bIsTxInProgress   = FALSE; 
2566:  MOVLW  23
2568:  ADDWF  x52,W
256A:  MOVWF  FE9
256C:  MOVLW  00
256E:  ADDWFC x53,W
2570:  MOVWF  FEA
2572:  BCF    FEF.4
....................  
....................     if ( ps->Flags.bServer ) 
2574:  MOVLW  23
2576:  ADDWF  x52,W
2578:  MOVWF  FE9
257A:  MOVLW  00
257C:  ADDWFC x53,W
257E:  MOVWF  FEA
2580:  BTFSS  FEF.0
2582:  BRA    2590
....................     { 
....................         ps->smState = TCP_LISTEN; 
2584:  MOVFF  352,FE9
2588:  MOVFF  353,FEA
258C:  CLRF   FEF
....................     } 
....................     else 
258E:  BRA    259C
....................     { 
....................         ps->smState = TCP_CLOSED; 
2590:  MOVFF  352,FE9
2594:  MOVFF  353,FEA
2598:  MOVLW  0A
259A:  MOVWF  FEF
....................     } 
....................  
....................    ps->TxCount = 0; 
259C:  MOVLW  10
259E:  ADDWF  x52,W
25A0:  MOVWF  FE9
25A2:  MOVLW  00
25A4:  ADDWFC x53,W
25A6:  MOVWF  FEA
25A8:  CLRF   FEC
25AA:  MOVF   FED,F
25AC:  CLRF   FEF
....................  
....................     return; 
.................... } 
25AE:  MOVLB  0
25B0:  RETLW  00
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        static void HandleTCPSeg(TCP_SOCKET s, 
.................... *                                      NODE_INFO *remote, 
.................... *                                      TCP_HEADER* h, 
.................... *                                      WORD len) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCPProcess() is the caller. 
.................... * 
.................... * Input:           s           - Socket that owns this segment 
.................... *                  remote      - Remote node info 
.................... *                  h           - TCP Header 
.................... *                  len         - Total buffer length. 
.................... * 
.................... * Output:          TCP FSM is executed on given socket with 
.................... *                  given TCP segment. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... static void HandleTCPSeg(TCP_SOCKET s, 
....................                    NODE_INFO *remote, 
....................                    TCP_HEADER *h, 
....................                    WORD len) 
.................... { 
....................    DWORD ack; 
....................    DWORD seq; 
....................    DWORD prevAck, prevSeq; 
....................    SOCKET_INFO *ps; 
....................    BYTE flags; 
....................    //BYTE debugLastState; 
....................    signed int32 temp; 
....................  
....................    ps = &TCB[s]; 
*
2B28:  MOVLB  3
2B2A:  MOVF   x34,W
2B2C:  MULLW  24
2B2E:  MOVF   FF3,W
2B30:  CLRF   03
2B32:  ADDLW  5F
2B34:  MOVWF  01
2B36:  MOVLW  00
2B38:  ADDWFC 03,F
2B3A:  MOVFF  01,34B
2B3E:  MOVFF  03,34C
....................    //debugLastState = TCB[s].smState; 
....................  
....................    flags = 0x00; 
2B42:  CLRF   x4D
....................  
....................    // Clear timeout info 
....................    ps->RetryCount  = 0; 
2B44:  MOVLW  1E
2B46:  ADDWF  x4B,W
2B48:  MOVWF  FE9
2B4A:  MOVLW  00
2B4C:  ADDWFC x4C,W
2B4E:  MOVWF  FEA
2B50:  CLRF   FEF
....................    ps->startTick   = TickGet(); 
2B52:  MOVLW  1F
2B54:  ADDWF  x4B,W
2B56:  MOVWF  01
2B58:  MOVLW  00
2B5A:  ADDWFC x4C,W
2B5C:  MOVWF  03
2B5E:  MOVFF  01,352
2B62:  MOVWF  x53
2B64:  MOVLB  0
2B66:  RCALL  2494
2B68:  MOVFF  353,FEA
2B6C:  MOVFF  352,FE9
2B70:  MOVFF  02,FEC
2B74:  MOVF   FED,F
2B76:  MOVFF  01,FEF
....................    ps->TimeOut = TCP_START_TIMEOUT_VAL; 
2B7A:  MOVLW  21
2B7C:  MOVLB  3
2B7E:  ADDWF  x4B,W
2B80:  MOVWF  FE9
2B82:  MOVLW  00
2B84:  ADDWFC x4C,W
2B86:  MOVWF  FEA
2B88:  CLRF   FEC
2B8A:  MOVF   FED,F
2B8C:  MOVLW  1E
2B8E:  MOVWF  FEF
....................  
....................    debug_tcp("\r\nTCP IN <= SP:%LX DP:%LX SEQ:%LX ACK:%LX LEN:%LX FL:%X\r\n", 
....................       h->SourcePort, 
....................       h->DestPort, 
....................       h->SeqNumber, 
....................       h->AckNumber, 
....................       len, 
....................       h->Flags 
....................    ); 
....................  
....................  
....................    // Reset FSM, if RST is received. 
....................    if(h->Flags.bits.flagRST) 
2B90:  MOVLW  0D
2B92:  ADDWF  x37,W
2B94:  MOVWF  FE9
2B96:  MOVLW  00
2B98:  ADDWFC x38,W
2B9A:  MOVWF  FEA
2B9C:  BTFSS  FEF.2
2B9E:  BRA    2BDC
....................    { 
....................       MACDiscardRx(); 
2BA0:  MOVLB  0
2BA2:  CALL   1076
....................       ps->smState = ps->Flags.bServer ? TCP_LISTEN : TCP_SYN_SENT; 
2BA6:  MOVLB  3
2BA8:  MOVFF  34B,01
2BAC:  MOVFF  34C,03
2BB0:  MOVFF  34B,352
2BB4:  MOVFF  34C,353
2BB8:  MOVLW  23
2BBA:  ADDWF  x4B,W
2BBC:  MOVWF  FE9
2BBE:  MOVLW  00
2BC0:  ADDWFC x4C,W
2BC2:  MOVWF  FEA
2BC4:  BTFSS  FEF.0
2BC6:  BRA    2BCC
2BC8:  MOVLW  00
2BCA:  BRA    2BCE
2BCC:  MOVLW  01
2BCE:  MOVFF  353,FEA
2BD2:  MOVFF  352,FE9
2BD6:  MOVWF  FEF
....................       return; 
2BD8:  GOTO   3618
....................    } 
....................  
....................    seq = ps->SND_SEQ; 
2BDC:  MOVLW  16
2BDE:  ADDWF  x4B,W
2BE0:  MOVWF  FE9
2BE2:  MOVLW  00
2BE4:  ADDWFC x4C,W
2BE6:  MOVWF  FEA
2BE8:  MOVFF  FEF,00
2BEC:  MOVFF  FEC,01
2BF0:  MOVFF  FEC,02
2BF4:  MOVFF  FEC,03
2BF8:  MOVFF  03,342
2BFC:  MOVFF  02,341
2C00:  MOVFF  01,340
2C04:  MOVFF  00,33F
....................  
....................    temp = (signed int32)h->Window - ((signed int32)seq - (signed int32)h->AckNumber) - (signed int32)ps->TxCount; 
2C08:  MOVLW  0E
2C0A:  ADDWF  x37,W
2C0C:  MOVWF  FE9
2C0E:  MOVLW  00
2C10:  ADDWFC x38,W
2C12:  MOVWF  FEA
2C14:  MOVFF  FEC,03
2C18:  MOVF   FED,F
2C1A:  MOVFF  FEF,352
2C1E:  MOVFF  03,353
2C22:  CLRF   x54
2C24:  CLRF   x55
2C26:  MOVLW  08
2C28:  ADDWF  x37,W
2C2A:  MOVWF  FE9
2C2C:  MOVLW  00
2C2E:  ADDWFC x38,W
2C30:  MOVWF  FEA
2C32:  MOVFF  FEF,00
2C36:  MOVFF  FEC,01
2C3A:  MOVFF  FEC,02
2C3E:  MOVFF  FEC,03
2C42:  MOVF   00,W
2C44:  SUBWF  x3F,W
2C46:  MOVWF  00
2C48:  MOVF   01,W
2C4A:  SUBWFB x40,W
2C4C:  MOVWF  01
2C4E:  MOVF   02,W
2C50:  SUBWFB x41,W
2C52:  MOVWF  02
2C54:  MOVF   03,W
2C56:  SUBWFB x42,W
2C58:  MOVWF  03
2C5A:  MOVF   00,W
2C5C:  SUBWF  x52,W
2C5E:  MOVWF  x56
2C60:  MOVF   01,W
2C62:  SUBWFB x53,W
2C64:  MOVWF  x57
2C66:  MOVF   02,W
2C68:  SUBWFB x54,W
2C6A:  MOVWF  x58
2C6C:  MOVF   03,W
2C6E:  SUBWFB x55,W
2C70:  MOVWF  x59
2C72:  MOVLW  10
2C74:  ADDWF  x4B,W
2C76:  MOVWF  FE9
2C78:  MOVLW  00
2C7A:  ADDWFC x4C,W
2C7C:  MOVWF  FEA
2C7E:  MOVFF  FEC,03
2C82:  MOVF   FED,F
2C84:  MOVFF  FEF,00
2C88:  MOVFF  03,01
2C8C:  CLRF   02
2C8E:  CLRF   03
2C90:  MOVF   00,W
2C92:  SUBWF  x56,W
2C94:  MOVWF  x4E
2C96:  MOVF   01,W
2C98:  SUBWFB x57,W
2C9A:  MOVWF  x4F
2C9C:  MOVF   02,W
2C9E:  SUBWFB x58,W
2CA0:  MOVWF  x50
2CA2:  MOVF   03,W
2CA4:  SUBWFB x59,W
2CA6:  MOVWF  x51
....................    if(temp < 0) 
2CA8:  BTFSC  x51.7
2CAA:  BRA    2CAE
2CAC:  BRA    2CC2
....................    { 
....................       ps->RemoteWindow = 0; 
2CAE:  MOVLW  14
2CB0:  ADDWF  x4B,W
2CB2:  MOVWF  FE9
2CB4:  MOVLW  00
2CB6:  ADDWFC x4C,W
2CB8:  MOVWF  FEA
2CBA:  CLRF   FEC
2CBC:  MOVF   FED,F
2CBE:  CLRF   FEF
....................       debug_tcp("\r\nRW1 => %LX, res=%LX W=%LX S=%LX A=%LX C=%LX\r\n", 
....................             ps->RemoteWindow, 
....................             temp, 
....................             h->Window, 
....................             seq, 
....................             h->AckNumber, 
....................             ps->TxCount 
....................          ); 
....................    } 
....................    else 
2CC0:  BRA    2CD6
....................    { 
....................       ps->RemoteWindow = ack; 
2CC2:  MOVLW  14
2CC4:  ADDWF  x4B,W
2CC6:  MOVWF  FE9
2CC8:  MOVLW  00
2CCA:  ADDWFC x4C,W
2CCC:  MOVWF  FEA
2CCE:  MOVFF  33B,FEF
2CD2:  MOVFF  33C,FEC
....................       debug_tcp("\r\nRW2 => %LX\r\n", ps->RemoteWindow); 
....................    } 
....................  
....................    // Handle TCP_SYN_SENT state 
....................    // The TCP_SYN_SENT state occurs when an application 
....................    // calls TCPConnect().  After an initial SYN is sent, 
....................    // we expect a SYN + ACK before establishing the 
....................    // connection. 
....................    if(ps->smState == TCP_SYN_SENT) 
2CD6:  MOVFF  34B,FE9
2CDA:  MOVFF  34C,FEA
2CDE:  DECFSZ FEF,W
2CE0:  BRA    2E68
....................    { 
....................       // Check if this is a SYN packet.  Unsynchronized, we cannot 
....................       // handle any other packet types. 
....................       if(!h->Flags.bits.flagSYN) 
2CE2:  MOVLW  0D
2CE4:  ADDWF  x37,W
2CE6:  MOVWF  FE9
2CE8:  MOVLW  00
2CEA:  ADDWFC x38,W
2CEC:  MOVWF  FEA
2CEE:  BTFSC  FEF.1
2CF0:  BRA    2D16
....................       { 
....................          MACDiscardRx(); 
2CF2:  MOVLB  0
2CF4:  CALL   1076
....................  
....................          // Send out a RESET if the remote node thinks a connection is already established 
....................           if(h->Flags.bits.flagACK) 
2CF8:  MOVLW  0D
2CFA:  MOVLB  3
2CFC:  ADDWF  x37,W
2CFE:  MOVWF  FE9
2D00:  MOVLW  00
2D02:  ADDWFC x38,W
2D04:  MOVWF  FEA
2D06:  BTFSS  FEF.4
2D08:  BRA    2D12
....................           { 
....................             flags = RST; 
2D0A:  MOVLW  04
2D0C:  MOVWF  x4D
....................             goto SendTCPControlPacket; 
2D0E:  GOTO   35A0
....................            } 
....................  
....................          return; 
2D12:  GOTO   3618
....................       } 
....................  
....................       // We now have a sequence number for the remote node 
....................       ps->SND_ACK = h->SeqNumber + len + 1; 
2D16:  MOVLW  1A
2D18:  ADDWF  x4B,W
2D1A:  MOVWF  01
2D1C:  MOVLW  00
2D1E:  ADDWFC x4C,W
2D20:  MOVFF  01,352
2D24:  MOVWF  x53
2D26:  MOVLW  04
2D28:  ADDWF  x37,W
2D2A:  MOVWF  FE9
2D2C:  MOVLW  00
2D2E:  ADDWFC x38,W
2D30:  MOVWF  FEA
2D32:  MOVFF  FEF,354
2D36:  MOVFF  FEC,355
2D3A:  MOVFF  FEC,356
2D3E:  MOVFF  FEC,357
2D42:  MOVF   x39,W
2D44:  ADDWF  x54,W
2D46:  MOVWF  x58
2D48:  MOVF   x3A,W
2D4A:  ADDWFC x55,W
2D4C:  MOVWF  x59
2D4E:  MOVLW  00
2D50:  ADDWFC x56,W
2D52:  MOVWF  x5A
2D54:  MOVLW  00
2D56:  ADDWFC x57,W
2D58:  MOVWF  x5B
2D5A:  MOVLW  01
2D5C:  ADDWF  x58,W
2D5E:  MOVWF  00
2D60:  MOVLW  00
2D62:  ADDWFC x59,W
2D64:  MOVWF  01
2D66:  MOVLW  00
2D68:  ADDWFC x5A,W
2D6A:  MOVWF  02
2D6C:  MOVLW  00
2D6E:  ADDWFC x5B,W
2D70:  MOVFF  353,FEA
2D74:  MOVFF  352,FE9
2D78:  MOVFF  00,FEF
2D7C:  MOVFF  01,FEC
2D80:  MOVFF  02,FEC
2D84:  MOVWF  FEC
....................       ack = ps->SND_ACK; 
2D86:  MOVLW  1A
2D88:  ADDWF  x4B,W
2D8A:  MOVWF  FE9
2D8C:  MOVLW  00
2D8E:  ADDWFC x4C,W
2D90:  MOVWF  FEA
2D92:  MOVFF  FEF,00
2D96:  MOVFF  FEC,01
2D9A:  MOVFF  FEC,02
2D9E:  MOVFF  FEC,03
2DA2:  MOVFF  03,33E
2DA6:  MOVFF  02,33D
2DAA:  MOVFF  01,33C
2DAE:  MOVFF  00,33B
....................  
....................       // If there is no ACK, we must go to TCP_SYN_RECEIVED.  With an ACK, 
....................       // we can establish the connection now. 
....................       if(!h->Flags.bits.flagACK) 
2DB2:  MOVLW  0D
2DB4:  ADDWF  x37,W
2DB6:  MOVWF  FE9
2DB8:  MOVLW  00
2DBA:  ADDWFC x38,W
2DBC:  MOVWF  FEA
2DBE:  BTFSC  FEF.4
2DC0:  BRA    2DDE
....................       { 
....................          ps->smState = TCP_SYN_RECEIVED; 
2DC2:  MOVFF  34B,FE9
2DC6:  MOVFF  34C,FEA
2DCA:  MOVLW  02
2DCC:  MOVWF  FEF
....................          MACDiscardRx(); 
2DCE:  MOVLB  0
2DD0:  CALL   1076
....................          // Send out a SYN+ACK for simultaneous connection open 
....................          flags = SYN | ACK; 
2DD4:  MOVLW  12
2DD6:  MOVLB  3
2DD8:  MOVWF  x4D
....................          goto SendTCPControlPacket; 
2DDA:  GOTO   35A0
....................       } 
....................  
....................       // We received SYN+ACK, establish the connection now 
....................       ps->smState = TCP_ESTABLISHED; 
2DDE:  MOVFF  34B,FE9
2DE2:  MOVFF  34C,FEA
2DE6:  MOVLW  03
2DE8:  MOVWF  FEF
....................       // Send out an ACK 
....................       flags = ACK; 
2DEA:  MOVLW  10
2DEC:  MOVWF  x4D
....................  
....................       ps->RemoteWindow = h->Window; 
2DEE:  MOVLW  14
2DF0:  ADDWF  x4B,W
2DF2:  MOVWF  01
2DF4:  MOVLW  00
2DF6:  ADDWFC x4C,W
2DF8:  MOVWF  03
2DFA:  MOVWF  x53
2DFC:  MOVLW  0E
2DFE:  ADDWF  x37,W
2E00:  MOVWF  FE9
2E02:  MOVLW  00
2E04:  ADDWFC x38,W
2E06:  MOVWF  FEA
2E08:  MOVFF  FEC,03
2E0C:  MOVF   FED,F
2E0E:  MOVFF  FEF,354
2E12:  MOVFF  353,FEA
2E16:  MOVFF  01,FE9
2E1A:  MOVFF  03,FEC
2E1E:  MOVF   FED,F
2E20:  MOVFF  354,FEF
....................       debug_tcp("\r\nRW3 => %LX\r\n", ps->RemoteWindow); 
....................  
....................       // Check for application data and make it 
....................       // available, if present 
....................       if(len) 
2E24:  MOVF   x39,W
2E26:  IORWF  x3A,W
2E28:  BZ    2E5E
....................       { 
....................          ps->Flags.bIsGetReady   = TRUE; 
2E2A:  MOVLW  23
2E2C:  ADDWF  x4B,W
2E2E:  MOVWF  FE9
2E30:  MOVLW  00
2E32:  ADDWFC x4C,W
2E34:  MOVWF  FEA
2E36:  BSF    FEF.3
....................          ps->RxCount             = len; 
2E38:  MOVLW  12
2E3A:  ADDWF  x4B,W
2E3C:  MOVWF  FE9
2E3E:  MOVLW  00
2E40:  ADDWFC x4C,W
2E42:  MOVWF  FEA
2E44:  MOVFF  33A,FEC
2E48:  MOVF   FED,F
2E4A:  MOVFF  339,FEF
....................          ps->Flags.bFirstRead    = TRUE; 
2E4E:  MOVLW  23
2E50:  ADDWF  x4B,W
2E52:  MOVWF  FE9
2E54:  MOVLW  00
2E56:  ADDWFC x4C,W
2E58:  MOVWF  FEA
2E5A:  BSF    FEF.2
....................       } 
....................       else   // No application data in this packet 
2E5C:  BRA    2E66
....................       { 
....................          MACDiscardRx(); 
2E5E:  MOVLB  0
2E60:  CALL   1076
2E64:  MOVLB  3
....................       } 
....................       goto SendTCPControlPacket; 
2E66:  BRA    35A0
....................    } 
....................  
....................    // Handle TCP_LISTEN state 
....................    if(ps->smState == TCP_LISTEN ) 
2E68:  MOVFF  34B,FE9
2E6C:  MOVFF  34C,FEA
2E70:  MOVF   FEF,F
2E72:  BTFSS  FD8.2
2E74:  BRA    300C
....................    { 
....................       MACDiscardRx(); 
2E76:  MOVLB  0
2E78:  CALL   1076
....................  
....................       // Send a RST if this isn't a SYN packet 
....................       if(!h->Flags.bits.flagSYN) 
2E7C:  MOVLW  0D
2E7E:  MOVLB  3
2E80:  ADDWF  x37,W
2E82:  MOVWF  FE9
2E84:  MOVLW  00
2E86:  ADDWFC x38,W
2E88:  MOVWF  FEA
2E8A:  BTFSC  FEF.1
2E8C:  BRA    2E94
....................       { 
....................          flags = RST; 
2E8E:  MOVLW  04
2E90:  MOVWF  x4D
....................          goto SendTCPControlPacket; 
2E92:  BRA    35A0
....................       } 
....................  
....................       ps->SND_ACK = h->SeqNumber + len + 1; 
2E94:  MOVLW  1A
2E96:  ADDWF  x4B,W
2E98:  MOVWF  01
2E9A:  MOVLW  00
2E9C:  ADDWFC x4C,W
2E9E:  MOVFF  01,352
2EA2:  MOVWF  x53
2EA4:  MOVLW  04
2EA6:  ADDWF  x37,W
2EA8:  MOVWF  FE9
2EAA:  MOVLW  00
2EAC:  ADDWFC x38,W
2EAE:  MOVWF  FEA
2EB0:  MOVFF  FEF,354
2EB4:  MOVFF  FEC,355
2EB8:  MOVFF  FEC,356
2EBC:  MOVFF  FEC,357
2EC0:  MOVF   x39,W
2EC2:  ADDWF  x54,W
2EC4:  MOVWF  x58
2EC6:  MOVF   x3A,W
2EC8:  ADDWFC x55,W
2ECA:  MOVWF  x59
2ECC:  MOVLW  00
2ECE:  ADDWFC x56,W
2ED0:  MOVWF  x5A
2ED2:  MOVLW  00
2ED4:  ADDWFC x57,W
2ED6:  MOVWF  x5B
2ED8:  MOVLW  01
2EDA:  ADDWF  x58,W
2EDC:  MOVWF  00
2EDE:  MOVLW  00
2EE0:  ADDWFC x59,W
2EE2:  MOVWF  01
2EE4:  MOVLW  00
2EE6:  ADDWFC x5A,W
2EE8:  MOVWF  02
2EEA:  MOVLW  00
2EEC:  ADDWFC x5B,W
2EEE:  MOVFF  353,FEA
2EF2:  MOVFF  352,FE9
2EF6:  MOVFF  00,FEF
2EFA:  MOVFF  01,FEC
2EFE:  MOVFF  02,FEC
2F02:  MOVWF  FEC
....................       ps->RemoteWindow = h->Window; 
2F04:  MOVLW  14
2F06:  ADDWF  x4B,W
2F08:  MOVWF  01
2F0A:  MOVLW  00
2F0C:  ADDWFC x4C,W
2F0E:  MOVWF  03
2F10:  MOVWF  x53
2F12:  MOVLW  0E
2F14:  ADDWF  x37,W
2F16:  MOVWF  FE9
2F18:  MOVLW  00
2F1A:  ADDWFC x38,W
2F1C:  MOVWF  FEA
2F1E:  MOVFF  FEC,03
2F22:  MOVF   FED,F
2F24:  MOVFF  FEF,354
2F28:  MOVFF  353,FEA
2F2C:  MOVFF  01,FE9
2F30:  MOVFF  03,FEC
2F34:  MOVF   FED,F
2F36:  MOVFF  354,FEF
....................       debug_tcp("\r\nRW4 => %LX\r\n", ps->RemoteWindow); 
....................  
....................       // This socket has received connection request (SYN). 
....................       // Remember calling node, assign next segment seq. number 
....................       // for this potential connection. 
....................       memcpy((void*)&ps->remote, (void*)remote, sizeof(*remote)); 
2F3A:  MOVLW  01
2F3C:  ADDWF  x4B,W
2F3E:  MOVWF  x52
2F40:  MOVLW  00
2F42:  ADDWFC x4C,W
2F44:  MOVWF  x53
2F46:  MOVWF  FEA
2F48:  MOVFF  352,FE9
2F4C:  MOVFF  336,FE2
2F50:  MOVFF  335,FE1
2F54:  MOVLW  0A
2F56:  MOVWF  01
2F58:  MOVFF  FE6,FEE
2F5C:  DECFSZ 01,F
2F5E:  BRA    2F58
....................       ps->remotePort = h->SourcePort; 
2F60:  MOVLW  0D
2F62:  ADDWF  x4B,W
2F64:  MOVWF  01
2F66:  MOVLW  00
2F68:  ADDWFC x4C,W
2F6A:  MOVFF  337,FE9
2F6E:  MOVFF  338,FEA
2F72:  MOVFF  FEC,03
2F76:  MOVF   FED,F
2F78:  MOVFF  FEF,354
2F7C:  MOVWF  FEA
2F7E:  MOVFF  01,FE9
2F82:  MOVFF  03,FEC
2F86:  MOVF   FED,F
2F88:  MOVFF  354,FEF
....................  
....................       // Grant connection request. 
....................       ps->smState = TCP_SYN_RECEIVED; 
2F8C:  MOVFF  34B,FE9
2F90:  MOVFF  34C,FEA
2F94:  MOVLW  02
2F96:  MOVWF  FEF
....................       seq = ps->SND_SEQ++; 
2F98:  MOVLW  16
2F9A:  ADDWF  x4B,W
2F9C:  MOVWF  FE9
2F9E:  MOVLW  00
2FA0:  ADDWFC x4C,W
2FA2:  MOVWF  FEA
2FA4:  MOVF   FEE,F
2FA6:  MOVF   FEE,F
2FA8:  MOVF   FEE,F
2FAA:  MOVFF  FED,03
2FAE:  MOVFF  FED,02
2FB2:  MOVFF  FED,01
2FB6:  MOVFF  FEF,00
2FBA:  MOVLW  01
2FBC:  ADDWF  FEE,F
2FBE:  BNZ   2FCA
2FC0:  INCF   FEE,F
2FC2:  BNZ   2FCA
2FC4:  INCF   FEE,F
2FC6:  BNZ   2FCA
2FC8:  INCF   FED,F
2FCA:  MOVFF  03,342
2FCE:  MOVFF  02,341
2FD2:  MOVFF  01,340
2FD6:  MOVFF  00,33F
....................       ack =  ps->SND_ACK; 
2FDA:  MOVLW  1A
2FDC:  ADDWF  x4B,W
2FDE:  MOVWF  FE9
2FE0:  MOVLW  00
2FE2:  ADDWFC x4C,W
2FE4:  MOVWF  FEA
2FE6:  MOVFF  FEF,00
2FEA:  MOVFF  FEC,01
2FEE:  MOVFF  FEC,02
2FF2:  MOVFF  FEC,03
2FF6:  MOVFF  03,33E
2FFA:  MOVFF  02,33D
2FFE:  MOVFF  01,33C
3002:  MOVFF  00,33B
....................       flags = SYN | ACK; 
3006:  MOVLW  12
3008:  MOVWF  x4D
....................       goto SendTCPControlPacket; 
300A:  BRA    35A0
....................    } 
....................  
....................  
....................    // Remember current seq and ack for our connection so that if 
....................    // we have to silently discard this packet, we can go back to 
....................    // previous ack and seq numbers. 
....................    prevAck = ps->SND_ACK; 
300C:  MOVLW  1A
300E:  ADDWF  x4B,W
3010:  MOVWF  FE9
3012:  MOVLW  00
3014:  ADDWFC x4C,W
3016:  MOVWF  FEA
3018:  MOVFF  FEF,00
301C:  MOVFF  FEC,01
3020:  MOVFF  FEC,02
3024:  MOVFF  FEC,03
3028:  MOVFF  03,346
302C:  MOVFF  02,345
3030:  MOVFF  01,344
3034:  MOVFF  00,343
....................    prevSeq = ps->SND_SEQ; 
3038:  MOVLW  16
303A:  ADDWF  x4B,W
303C:  MOVWF  FE9
303E:  MOVLW  00
3040:  ADDWFC x4C,W
3042:  MOVWF  FEA
3044:  MOVFF  FEF,00
3048:  MOVFF  FEC,01
304C:  MOVFF  FEC,02
3050:  MOVFF  FEC,03
3054:  MOVFF  03,34A
3058:  MOVFF  02,349
305C:  MOVFF  01,348
3060:  MOVFF  00,347
....................  
....................    ack = h->SeqNumber; 
3064:  MOVLW  04
3066:  ADDWF  x37,W
3068:  MOVWF  FE9
306A:  MOVLW  00
306C:  ADDWFC x38,W
306E:  MOVWF  FEA
3070:  MOVFF  FEF,00
3074:  MOVFF  FEC,01
3078:  MOVFF  FEC,02
307C:  MOVFF  FEC,03
3080:  MOVFF  03,33E
3084:  MOVFF  02,33D
3088:  MOVFF  01,33C
308C:  MOVFF  00,33B
....................    ack += (DWORD)len; 
3090:  CLRF   02
3092:  CLRF   03
3094:  MOVF   x39,W
3096:  ADDWF  x3B,F
3098:  MOVF   x3A,W
309A:  ADDWFC x3C,F
309C:  MOVF   02,W
309E:  ADDWFC x3D,F
30A0:  MOVF   03,W
30A2:  ADDWFC x3E,F
....................    seq = ps->SND_SEQ; 
30A4:  MOVLW  16
30A6:  ADDWF  x4B,W
30A8:  MOVWF  FE9
30AA:  MOVLW  00
30AC:  ADDWFC x4C,W
30AE:  MOVWF  FEA
30B0:  MOVFF  FEF,00
30B4:  MOVFF  FEC,01
30B8:  MOVFF  FEC,02
30BC:  MOVFF  FEC,03
30C0:  MOVFF  03,342
30C4:  MOVFF  02,341
30C8:  MOVFF  01,340
30CC:  MOVFF  00,33F
....................  
....................    // State is something other than TCP_LISTEN, handle it. 
....................    { 
....................       // Check to see if the incomming sequence number is what 
....................       // we expect (last transmitted ACK value).  Throw this packet 
....................       // away if it is wrong. 
....................       if(h->SeqNumber == prevAck) 
30D0:  MOVLW  04
30D2:  ADDWF  x37,W
30D4:  MOVWF  FE9
30D6:  MOVLW  00
30D8:  ADDWFC x38,W
30DA:  MOVWF  FEA
30DC:  MOVFF  FEF,352
30E0:  MOVFF  FEC,353
30E4:  MOVFF  FEC,354
30E8:  MOVFF  FEC,355
30EC:  MOVF   x43,W
30EE:  SUBWF  x52,W
30F0:  BTFSS  FD8.2
30F2:  BRA    3584
30F4:  MOVF   x44,W
30F6:  SUBWF  x53,W
30F8:  BTFSS  FD8.2
30FA:  BRA    3584
30FC:  MOVF   x45,W
30FE:  SUBWF  x54,W
3100:  BTFSS  FD8.2
3102:  BRA    3584
3104:  MOVF   x46,W
3106:  SUBWF  x55,W
3108:  BTFSS  FD8.2
310A:  BRA    3584
....................       { 
....................          // After receiving a SYNchronization request, we expect an 
....................          // ACK to our transmitted SYN 
....................          if(ps->smState == TCP_SYN_RECEIVED) 
310C:  MOVFF  34B,FE9
3110:  MOVFF  34C,FEA
3114:  MOVF   FEF,W
3116:  SUBLW  02
3118:  BNZ   31A0
....................          { 
....................             if(h->Flags.bits.flagACK) 
311A:  MOVLW  0D
311C:  ADDWF  x37,W
311E:  MOVWF  FE9
3120:  MOVLW  00
3122:  ADDWFC x38,W
3124:  MOVWF  FEA
3126:  BTFSS  FEF.4
3128:  BRA    3196
....................             { 
....................                // ACK received as expected, this connection is 
....................                // now established 
....................                ps->SND_ACK = ack; 
312A:  MOVLW  1A
312C:  ADDWF  x4B,W
312E:  MOVWF  FE9
3130:  MOVLW  00
3132:  ADDWFC x4C,W
3134:  MOVWF  FEA
3136:  MOVFF  33B,FEF
313A:  MOVFF  33C,FEC
313E:  MOVFF  33D,FEC
3142:  MOVFF  33E,FEC
....................                ps->smState = TCP_ESTABLISHED; 
3146:  MOVFF  34B,FE9
314A:  MOVFF  34C,FEA
314E:  MOVLW  03
3150:  MOVWF  FEF
....................  
....................                // Check if this first packet has application data 
....................                // in it.  Make it available if so. 
....................                if(len) 
3152:  MOVF   x39,W
3154:  IORWF  x3A,W
3156:  BZ    318C
....................                { 
....................                   ps->Flags.bIsGetReady   = TRUE; 
3158:  MOVLW  23
315A:  ADDWF  x4B,W
315C:  MOVWF  FE9
315E:  MOVLW  00
3160:  ADDWFC x4C,W
3162:  MOVWF  FEA
3164:  BSF    FEF.3
....................                   ps->RxCount             = len; 
3166:  MOVLW  12
3168:  ADDWF  x4B,W
316A:  MOVWF  FE9
316C:  MOVLW  00
316E:  ADDWFC x4C,W
3170:  MOVWF  FEA
3172:  MOVFF  33A,FEC
3176:  MOVF   FED,F
3178:  MOVFF  339,FEF
....................                   ps->Flags.bFirstRead    = TRUE; 
317C:  MOVLW  23
317E:  ADDWF  x4B,W
3180:  MOVWF  FE9
3182:  MOVLW  00
3184:  ADDWFC x4C,W
3186:  MOVWF  FEA
3188:  BSF    FEF.2
....................                } 
....................                else 
318A:  BRA    3194
....................                   MACDiscardRx(); 
318C:  MOVLB  0
318E:  CALL   1076
3192:  MOVLB  3
....................             } 
....................             else   // No ACK to our SYN 
3194:  BRA    319E
....................             { 
....................                MACDiscardRx(); 
3196:  MOVLB  0
3198:  CALL   1076
319C:  MOVLB  3
....................             } 
....................          } 
....................          // Connection is established, closing, or otherwise 
....................          else 
319E:  BRA    3582
....................          { 
....................  
....................             // Save the seq+len value of the packet for our future 
....................             // ACK transmission, and so out of sequence packets 
....................             // can be detected in the future. 
....................             ps->SND_ACK = ack; 
31A0:  MOVLW  1A
31A2:  ADDWF  x4B,W
31A4:  MOVWF  FE9
31A6:  MOVLW  00
31A8:  ADDWFC x4C,W
31AA:  MOVWF  FEA
31AC:  MOVFF  33B,FEF
31B0:  MOVFF  33C,FEC
31B4:  MOVFF  33D,FEC
31B8:  MOVFF  33E,FEC
....................  
....................             // Handle packets received while connection established. 
....................             if(ps->smState == TCP_ESTABLISHED) 
31BC:  MOVFF  34B,FE9
31C0:  MOVFF  34C,FEA
31C4:  MOVF   FEF,W
31C6:  SUBLW  03
31C8:  BTFSS  FD8.2
31CA:  BRA    3394
....................             { 
....................                // If this packet has the ACK set, mark all 
....................                // previous TX packets as no longer needed for 
....................                // possible retransmission. 
....................                // TODO: Make this more sophisticated so that partial ACKs due to fragmentation are handled correctly.  i.e. Keep a real output stream buffer with slidable window capability. 
....................                if(h->Flags.bits.flagACK && !ps->Flags.bIsPutReady) 
31CC:  MOVLW  0D
31CE:  ADDWF  x37,W
31D0:  MOVWF  FE9
31D2:  MOVLW  00
31D4:  ADDWFC x38,W
31D6:  MOVWF  FEA
31D8:  BTFSS  FEF.4
31DA:  BRA    3238
31DC:  MOVLW  23
31DE:  ADDWF  x4B,W
31E0:  MOVWF  FE9
31E2:  MOVLW  00
31E4:  ADDWFC x4C,W
31E6:  MOVWF  FEA
31E8:  BTFSC  FEF.1
31EA:  BRA    3238
....................                { 
....................                   if(ps->TxBuffer != INVALID_BUFFER) 
31EC:  MOVLW  0F
31EE:  ADDWF  x4B,W
31F0:  MOVWF  FE9
31F2:  MOVLW  00
31F4:  ADDWFC x4C,W
31F6:  MOVWF  FEA
31F8:  INCFSZ FEF,W
31FA:  BRA    31FE
31FC:  BRA    3238
....................                   { 
....................                      MACDiscardTx(ps->TxBuffer); 
31FE:  MOVLW  0F
3200:  ADDWF  x4B,W
3202:  MOVWF  FE9
3204:  MOVLW  00
3206:  ADDWFC x4C,W
3208:  MOVWF  FEA
320A:  MOVFF  FEF,352
320E:  MOVFF  352,355
3212:  MOVLB  0
3214:  CALL   0004
....................                      ps->TxBuffer            = INVALID_BUFFER; 
3218:  MOVLW  0F
321A:  MOVLB  3
321C:  ADDWF  x4B,W
321E:  MOVWF  FE9
3220:  MOVLW  00
3222:  ADDWFC x4C,W
3224:  MOVWF  FEA
3226:  MOVLW  FF
3228:  MOVWF  FEF
....................                      ps->Flags.bIsPutReady   = TRUE; 
322A:  MOVLW  23
322C:  ADDWF  x4B,W
322E:  MOVWF  FE9
3230:  MOVLW  00
3232:  ADDWFC x4C,W
3234:  MOVWF  FEA
3236:  BSF    FEF.1
....................                   } 
....................                } 
....................  
....................                // Check if the remote node is closing the connection 
....................                if(h->Flags.bits.flagFIN) 
3238:  MOVLW  0D
323A:  ADDWF  x37,W
323C:  MOVWF  FE9
323E:  MOVLW  00
3240:  ADDWFC x38,W
3242:  MOVWF  FEA
3244:  BTFSS  FEF.0
3246:  BRA    32FC
....................                { 
....................                   //DebugPrint("|"); 
....................                   flags = FIN | ACK; 
3248:  MOVLW  11
324A:  MOVWF  x4D
....................                   seq = ps->SND_SEQ++; 
324C:  MOVLW  16
324E:  ADDWF  x4B,W
3250:  MOVWF  FE9
3252:  MOVLW  00
3254:  ADDWFC x4C,W
3256:  MOVWF  FEA
3258:  MOVF   FEE,F
325A:  MOVF   FEE,F
325C:  MOVF   FEE,F
325E:  MOVFF  FED,03
3262:  MOVFF  FED,02
3266:  MOVFF  FED,01
326A:  MOVFF  FEF,00
326E:  MOVLW  01
3270:  ADDWF  FEE,F
3272:  BNZ   327E
3274:  INCF   FEE,F
3276:  BNZ   327E
3278:  INCF   FEE,F
327A:  BNZ   327E
327C:  INCF   FED,F
327E:  MOVFF  03,342
3282:  MOVFF  02,341
3286:  MOVFF  01,340
328A:  MOVFF  00,33F
....................                   //ack = ++ps->SND_ACK;   /////TODO HUGE BUG HERE? 
....................               ps->SND_ACK += 1; 
328E:  MOVLW  1A
3290:  ADDWF  x4B,W
3292:  MOVWF  FE9
3294:  MOVLW  00
3296:  ADDWFC x4C,W
3298:  MOVWF  FEA
329A:  MOVLW  01
329C:  ADDWF  FEF,W
329E:  MOVWF  00
32A0:  MOVLW  00
32A2:  ADDWFC FEC,W
32A4:  MOVWF  01
32A6:  MOVLW  00
32A8:  ADDWFC FEC,W
32AA:  MOVWF  02
32AC:  MOVLW  00
32AE:  ADDWFC FEC,W
32B0:  MOVF   FED,F
32B2:  MOVF   FED,F
32B4:  MOVF   FED,F
32B6:  MOVFF  00,FEF
32BA:  MOVFF  01,FEC
32BE:  MOVFF  02,FEC
32C2:  MOVWF  FEC
....................               ack = ps->SND_ACK; 
32C4:  MOVLW  1A
32C6:  ADDWF  x4B,W
32C8:  MOVWF  FE9
32CA:  MOVLW  00
32CC:  ADDWFC x4C,W
32CE:  MOVWF  FEA
32D0:  MOVFF  FEF,00
32D4:  MOVFF  FEC,01
32D8:  MOVFF  FEC,02
32DC:  MOVFF  FEC,03
32E0:  MOVFF  03,33E
32E4:  MOVFF  02,33D
32E8:  MOVFF  01,33C
32EC:  MOVFF  00,33B
....................                   ps->smState = TCP_LAST_ACK; 
32F0:  MOVFF  34B,FE9
32F4:  MOVFF  34C,FEA
32F8:  MOVLW  09
32FA:  MOVWF  FEF
....................                } 
....................  
....................                // Check if there is any application data in 
....................                // this packet. 
....................                if(len) 
32FC:  MOVF   x39,W
32FE:  IORWF  x3A,W
3300:  BZ    338A
....................                { 
....................                   // There is data.  Make it available if we 
....................                   // don't already have data available. 
....................                   if(!ps->Flags.bIsGetReady) 
3302:  MOVLW  23
3304:  ADDWF  x4B,W
3306:  MOVWF  FE9
3308:  MOVLW  00
330A:  ADDWFC x4C,W
330C:  MOVWF  FEA
330E:  BTFSC  FEF.3
3310:  BRA    3348
....................                   { 
....................                      ps->Flags.bIsGetReady   = TRUE; 
3312:  MOVLW  23
3314:  ADDWF  x4B,W
3316:  MOVWF  FE9
3318:  MOVLW  00
331A:  ADDWFC x4C,W
331C:  MOVWF  FEA
331E:  BSF    FEF.3
....................                      ps->RxCount             = len; 
3320:  MOVLW  12
3322:  ADDWF  x4B,W
3324:  MOVWF  FE9
3326:  MOVLW  00
3328:  ADDWFC x4C,W
332A:  MOVWF  FEA
332C:  MOVFF  33A,FEC
3330:  MOVF   FED,F
3332:  MOVFF  339,FEF
....................                      ps->Flags.bFirstRead    = TRUE; 
3336:  MOVLW  23
3338:  ADDWF  x4B,W
333A:  MOVWF  FE9
333C:  MOVLW  00
333E:  ADDWFC x4C,W
3340:  MOVWF  FEA
3342:  BSF    FEF.2
....................  
....................                      // 4/1/02 
....................                      flags |= ACK; 
3344:  BSF    x4D.4
....................                   } 
....................                   // There is data, but we cannot handle it at this time. 
....................                   else 
3346:  BRA    3388
....................                   { 
....................                      //DebugPrint("D"); 
....................                      // Since we cannot accept this packet, 
....................                      // restore to previous seq and ack. 
....................                      // and do not send anything back. 
....................                      // Host has to resend this packet when 
....................                      // we are ready. 
....................                      ps->SND_SEQ = prevSeq; 
3348:  MOVLW  16
334A:  ADDWF  x4B,W
334C:  MOVWF  FE9
334E:  MOVLW  00
3350:  ADDWFC x4C,W
3352:  MOVWF  FEA
3354:  MOVFF  347,FEF
3358:  MOVFF  348,FEC
335C:  MOVFF  349,FEC
3360:  MOVFF  34A,FEC
....................                      ps->SND_ACK = prevAck; 
3364:  MOVLW  1A
3366:  ADDWF  x4B,W
3368:  MOVWF  FE9
336A:  MOVLW  00
336C:  ADDWFC x4C,W
336E:  MOVWF  FEA
3370:  MOVFF  343,FEF
3374:  MOVFF  344,FEC
3378:  MOVFF  345,FEC
337C:  MOVFF  346,FEC
....................  
....................                      MACDiscardRx(); 
3380:  MOVLB  0
3382:  CALL   1076
3386:  MOVLB  3
....................                   } 
....................                } 
....................                // There is no data in this packet, and thus it 
....................                // can be thrown away. 
....................                else 
3388:  BRA    3392
....................                { 
....................                   MACDiscardRx(); 
338A:  MOVLB  0
338C:  CALL   1076
3390:  MOVLB  3
....................                } 
....................             } 
....................             // Connection is not established; check if we've sent 
....................             // a FIN and expect our last ACK 
....................             else if(ps->smState == TCP_LAST_ACK) 
3392:  BRA    3582
3394:  MOVFF  34B,FE9
3398:  MOVFF  34C,FEA
339C:  MOVF   FEF,W
339E:  SUBLW  09
33A0:  BNZ   33CC
....................             { 
....................                MACDiscardRx(); 
33A2:  MOVLB  0
33A4:  CALL   1076
....................  
....................                if(h->Flags.bits.flagACK) 
33A8:  MOVLW  0D
33AA:  MOVLB  3
33AC:  ADDWF  x37,W
33AE:  MOVWF  FE9
33B0:  MOVLW  00
33B2:  ADDWFC x38,W
33B4:  MOVWF  FEA
33B6:  BTFSS  FEF.4
33B8:  BRA    33CA
....................                { 
....................                   CloseSocket(ps); 
33BA:  MOVFF  34C,353
33BE:  MOVFF  34B,352
33C2:  MOVLB  0
33C4:  CALL   24AE
33C8:  MOVLB  3
....................                } 
....................             } 
....................             else if(ps->smState == TCP_FIN_WAIT_1) 
33CA:  BRA    3582
33CC:  MOVFF  34B,FE9
33D0:  MOVFF  34C,FEA
33D4:  MOVF   FEF,W
33D6:  SUBLW  04
33D8:  BNZ   34AE
....................             { 
....................                MACDiscardRx(); 
33DA:  MOVLB  0
33DC:  CALL   1076
....................  
....................                if(h->Flags.bits.flagFIN) 
33E0:  MOVLW  0D
33E2:  MOVLB  3
33E4:  ADDWF  x37,W
33E6:  MOVWF  FE9
33E8:  MOVLW  00
33EA:  ADDWFC x38,W
33EC:  MOVWF  FEA
33EE:  BTFSS  FEF.0
33F0:  BRA    348C
....................                { 
....................                   flags = ACK; 
33F2:  MOVLW  10
33F4:  MOVWF  x4D
....................                   //ack = ++ps->SND_ACK;   ////TODO HUGE BUG HERE? 
....................               ps->SND_ACK += 1; 
33F6:  MOVLW  1A
33F8:  ADDWF  x4B,W
33FA:  MOVWF  FE9
33FC:  MOVLW  00
33FE:  ADDWFC x4C,W
3400:  MOVWF  FEA
3402:  MOVLW  01
3404:  ADDWF  FEF,W
3406:  MOVWF  00
3408:  MOVLW  00
340A:  ADDWFC FEC,W
340C:  MOVWF  01
340E:  MOVLW  00
3410:  ADDWFC FEC,W
3412:  MOVWF  02
3414:  MOVLW  00
3416:  ADDWFC FEC,W
3418:  MOVF   FED,F
341A:  MOVF   FED,F
341C:  MOVF   FED,F
341E:  MOVFF  00,FEF
3422:  MOVFF  01,FEC
3426:  MOVFF  02,FEC
342A:  MOVWF  FEC
....................               ack = ps->SND_ACK; 
342C:  MOVLW  1A
342E:  ADDWF  x4B,W
3430:  MOVWF  FE9
3432:  MOVLW  00
3434:  ADDWFC x4C,W
3436:  MOVWF  FEA
3438:  MOVFF  FEF,00
343C:  MOVFF  FEC,01
3440:  MOVFF  FEC,02
3444:  MOVFF  FEC,03
3448:  MOVFF  03,33E
344C:  MOVFF  02,33D
3450:  MOVFF  01,33C
3454:  MOVFF  00,33B
....................                   if(h->Flags.bits.flagACK) 
3458:  MOVLW  0D
345A:  ADDWF  x37,W
345C:  MOVWF  FE9
345E:  MOVLW  00
3460:  ADDWFC x38,W
3462:  MOVWF  FEA
3464:  BTFSS  FEF.4
3466:  BRA    347A
....................                   { 
....................                      CloseSocket(ps); 
3468:  MOVFF  34C,353
346C:  MOVFF  34B,352
3470:  MOVLB  0
3472:  CALL   24AE
....................                   } 
....................                   else 
3476:  BRA    3488
3478:  MOVLB  3
....................                   { 
....................                      ps->smState = TCP_CLOSING; 
347A:  MOVFF  34B,FE9
347E:  MOVFF  34C,FEA
3482:  MOVLW  06
3484:  MOVWF  FEF
3486:  MOVLB  0
....................                   } 
....................                } 
....................                else if(h->Flags.bits.flagACK) 
3488:  BRA    34AA
348A:  MOVLB  3
348C:  MOVLW  0D
348E:  ADDWF  x37,W
3490:  MOVWF  FE9
3492:  MOVLW  00
3494:  ADDWFC x38,W
3496:  MOVWF  FEA
3498:  BTFSS  FEF.4
349A:  BRA    34A8
....................                { 
....................                   ps->smState = TCP_FIN_WAIT_2; 
349C:  MOVFF  34B,FE9
34A0:  MOVFF  34C,FEA
34A4:  MOVLW  05
34A6:  MOVWF  FEF
34A8:  MOVLB  0
....................                } 
....................             } 
....................             else if(ps->smState == TCP_FIN_WAIT_2) 
34AA:  BRA    3580
34AC:  MOVLB  3
34AE:  MOVFF  34B,FE9
34B2:  MOVFF  34C,FEA
34B6:  MOVF   FEF,W
34B8:  SUBLW  05
34BA:  BNZ   354C
....................             { 
....................                MACDiscardRx(); 
34BC:  MOVLB  0
34BE:  CALL   1076
....................  
....................                if(h->Flags.bits.flagFIN) 
34C2:  MOVLW  0D
34C4:  MOVLB  3
34C6:  ADDWF  x37,W
34C8:  MOVWF  FE9
34CA:  MOVLW  00
34CC:  ADDWFC x38,W
34CE:  MOVWF  FEA
34D0:  BTFSS  FEF.0
34D2:  BRA    354A
....................                { 
....................                   flags = ACK; 
34D4:  MOVLW  10
34D6:  MOVWF  x4D
....................                   //ack = ++ps->SND_ACK;   ////TODO HUGE BUG HERE? 
....................               ps->SND_ACK += 1; 
34D8:  MOVLW  1A
34DA:  ADDWF  x4B,W
34DC:  MOVWF  FE9
34DE:  MOVLW  00
34E0:  ADDWFC x4C,W
34E2:  MOVWF  FEA
34E4:  MOVLW  01
34E6:  ADDWF  FEF,W
34E8:  MOVWF  00
34EA:  MOVLW  00
34EC:  ADDWFC FEC,W
34EE:  MOVWF  01
34F0:  MOVLW  00
34F2:  ADDWFC FEC,W
34F4:  MOVWF  02
34F6:  MOVLW  00
34F8:  ADDWFC FEC,W
34FA:  MOVF   FED,F
34FC:  MOVF   FED,F
34FE:  MOVF   FED,F
3500:  MOVFF  00,FEF
3504:  MOVFF  01,FEC
3508:  MOVFF  02,FEC
350C:  MOVWF  FEC
....................               ack = ps->SND_ACK; 
350E:  MOVLW  1A
3510:  ADDWF  x4B,W
3512:  MOVWF  FE9
3514:  MOVLW  00
3516:  ADDWFC x4C,W
3518:  MOVWF  FEA
351A:  MOVFF  FEF,00
351E:  MOVFF  FEC,01
3522:  MOVFF  FEC,02
3526:  MOVFF  FEC,03
352A:  MOVFF  03,33E
352E:  MOVFF  02,33D
3532:  MOVFF  01,33C
3536:  MOVFF  00,33B
....................                   CloseSocket(ps); 
353A:  MOVFF  34C,353
353E:  MOVFF  34B,352
3542:  MOVLB  0
3544:  CALL   24AE
3548:  MOVLB  3
....................                } 
....................             } 
....................             else if ( ps->smState == TCP_CLOSING ) 
354A:  BRA    3582
354C:  MOVFF  34B,FE9
3550:  MOVFF  34C,FEA
3554:  MOVF   FEF,W
3556:  SUBLW  06
3558:  BNZ   3582
....................             { 
....................                MACDiscardRx(); 
355A:  MOVLB  0
355C:  CALL   1076
....................  
....................                if ( h->Flags.bits.flagACK ) 
3560:  MOVLW  0D
3562:  MOVLB  3
3564:  ADDWF  x37,W
3566:  MOVWF  FE9
3568:  MOVLW  00
356A:  ADDWFC x38,W
356C:  MOVWF  FEA
356E:  BTFSS  FEF.4
3570:  BRA    3582
....................                { 
....................                   CloseSocket(ps); 
3572:  MOVFF  34C,353
3576:  MOVFF  34B,352
357A:  MOVLB  0
357C:  CALL   24AE
3580:  MOVLB  3
....................                } 
....................             } 
....................          } 
....................       } 
....................       // This packet's sequence number does not match what we were 
....................       // expecting (the last value we ACKed).  Throw this packet 
....................       // away.  This may happen if packets are delivered out of order. 
....................       // Not enough memory is available on our PIC or Ethernet 
....................       // controller to implement a robust stream reconstruction 
....................       // buffer.  As a result, the remote node will just have to 
....................       // retransmit its packets starting with the proper sequence number. 
....................       else 
3582:  BRA    35A0
....................       { 
....................          MACDiscardRx(); 
3584:  MOVLB  0
3586:  CALL   1076
....................  
....................          // Send a new ACK out in case if the previous one was lost 
....................          // (ACKs aren't ACKed).  This is required to prevent an 
....................          // unlikely but possible situation which would cause the 
....................          // connection to time out if the ACK was lost and the 
....................          // remote node keeps sending us older data than we are 
....................          // expecting. 
....................          flags = ACK; 
358A:  MOVLW  10
358C:  MOVLB  3
358E:  MOVWF  x4D
....................          ack = prevAck; 
3590:  MOVFF  346,33E
3594:  MOVFF  345,33D
3598:  MOVFF  344,33C
359C:  MOVFF  343,33B
....................       } 
....................    } 
....................  
.................... SendTCPControlPacket: 
....................    if(flags) 
35A0:  MOVF   x4D,F
35A2:  BZ    3618
....................    { 
....................       SendTCP(remote, 
....................          h->DestPort, 
....................          h->SourcePort, 
....................          seq, 
....................          ack, 
....................          flags); 
35A4:  MOVLW  02
35A6:  ADDWF  x37,W
35A8:  MOVWF  FE9
35AA:  MOVLW  00
35AC:  ADDWFC x38,W
35AE:  MOVWF  FEA
35B0:  MOVFF  FEC,353
35B4:  MOVF   FED,F
35B6:  MOVFF  FEF,352
35BA:  MOVFF  337,FE9
35BE:  MOVFF  338,FEA
35C2:  MOVFF  FEC,355
35C6:  MOVF   FED,F
35C8:  MOVFF  FEF,354
35CC:  MOVFF  336,35A
35D0:  MOVFF  335,359
35D4:  MOVFF  353,35C
35D8:  MOVFF  352,35B
35DC:  MOVFF  355,35E
35E0:  MOVFF  354,35D
35E4:  MOVFF  342,362
35E8:  MOVFF  341,361
35EC:  MOVFF  340,360
35F0:  MOVFF  33F,35F
35F4:  MOVFF  33E,366
35F8:  MOVFF  33D,365
35FC:  MOVFF  33C,364
3600:  MOVFF  33B,363
3604:  MOVFF  34D,367
3608:  MOVLW  FF
360A:  MOVWF  x68
360C:  CLRF   x6A
360E:  CLRF   x69
3610:  MOVLB  0
3612:  CALL   28FA
3616:  MOVLB  3
....................    } 
....................  
....................    /*if (debugLastState != ps->smState) 
....................    { 
....................       debug_tcp("\r\nHANDLE TCP SEG %U - ", s); 
....................       DebugTCPDisplayState(debugLastState); 
....................       debug_tcp(" -> "); 
....................       DebugTCPDisplayState(ps->smState); 
....................    }*/ 
.................... } 
3618:  MOVLB  0
361A:  GOTO   37B8 (RETURN)
....................  
.................... #endif 
....................  
.................... #if STACK_USE_ICMP 
....................    #include "tcpip/icmp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ICMP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.C 
....................  * Dependencies:    ICMP.h 
....................  *                  string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  IP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/30/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/29/04 SwapICMPPacket() no longer static 
....................  * Howard Schlunder      9/9/04   Added ENC28J60 DMA checksum support 
....................  * Howard Schlunder      1/5/06   Increased DMA checksum efficiency 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8 *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8 *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/icmp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ICMP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  IP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    07/13/06 Increased MAX_ICMP_DATA to 64 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef ICMP_H 
.................... #define ICMP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... // Windows ping uses 32 bytes, while MAC uses 56 bytes. 
.................... //#define MAX_ICMP_DATA       (32) 
.................... #define MAX_ICMP_DATA       (64) 
....................  
.................... #define MAX_ICMP_DATA_LEN   (MAX_ICMP_DATA) 
....................  
....................  
.................... typedef enum _ICMP_CODE 
.................... { 
....................     ICMP_ECHO_REPLY = 0, 
....................     ICMP_ECHO_REQUEST = 8 
.................... } ICMP_CODE, ICMP_REQUESTS; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPIsTxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is ready 
....................  *                  FALSE if transmit buffer is not ready 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define ICMPIsTxReady()     MACIsTxReady(TRUE) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPPut(NODE_INFO *remote, 
....................  *                               ICMP_CODE code, 
....................  *                               BYTE *data, 
....................  *                               BYTE len, 
....................  *                               WORD id, 
....................  *                               WORD seq) 
....................  * 
....................  * PreCondition:    ICMPIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  code        - ICMP_ECHO_REPLY or ICMP_ECHO_REQUEST 
....................  *                  data        - Data bytes 
....................  *                  len         - Number of bytes to send 
....................  *                  id          - ICMP identifier 
....................  *                  seq         - ICMP sequence number 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            A ICMP packet is created and put on MAC. 
....................  * 
....................  ********************************************************************/ 
.................... void ICMPPut(NODE_INFO *remote, 
....................              ICMP_CODE code, 
....................              BYTE *data, 
....................              BYTE len, 
....................              WORD id, 
....................              WORD seq); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPGet(ICMP_CODE *code, 
....................  *                              BYTE *data, 
....................  *                              BYTE *len, 
....................  *                              WORD *id, 
....................  *                              WORD *seq) 
....................  * 
....................  * PreCondition:    MAC buffer contains ICMP type packet. 
....................  * 
....................  * Input:           code    - Buffer to hold ICMP code value 
....................  *                  data    - Buffer to hold ICMP data 
....................  *                  len     - Buffer to hold ICMP data length 
....................  *                  id      - Buffer to hold ICMP id 
....................  *                  seq     - Buffer to hold ICMP seq 
....................  * 
....................  * Output:          TRUE if valid ICMP packet was received 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ICMPGet(ICMP_CODE *code, 
....................              BYTE *data, 
....................              BYTE *len, 
....................              WORD *id, 
....................              WORD *seq); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... #define debug_icmp 
.................... //#define debug_icmp   debug_printf 
....................  
.................... //#define MAX_ICMP_DATA       32 //moved to icmp.h 
....................  
.................... /* 
....................  * ICMP packet definition 
....................  */ 
.................... typedef struct _ICMP_PACKET 
.................... { 
....................     BYTE    Type; 
....................     BYTE    Code; 
....................     WORD    Checksum; 
....................     WORD    Identifier; 
....................     WORD    SequenceNumber; 
....................     BYTE    Data[MAX_ICMP_DATA]; 
.................... } ICMP_PACKET; 
.................... #define ICMP_HEADER_SIZE    (sizeof(ICMP_PACKET) - MAX_ICMP_DATA) 
....................  
.................... static void SwapICMPPacket(ICMP_PACKET* p); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPGet(ICMP_CODE *code, 
....................  *                              BYTE *data, 
....................  *                              BYTE *len, 
....................  *                              WORD *id, 
....................  *                              WORD *seq) 
....................  * 
....................  * PreCondition:    MAC buffer contains ICMP type packet. 
....................  * 
....................  * Input:           code    - Buffer to hold ICMP code value 
....................  *                  data    - Buffer to hold ICMP data 
....................  *                  len     - Buffer to hold ICMP data length 
....................  *                  id      - Buffer to hold ICMP id 
....................  *                  seq     - Buffer to hold ICMP seq 
....................  * 
....................  * Output:          TRUE if valid ICMP packet was received 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ICMPGet(ICMP_CODE *code, 
....................              BYTE *data, 
....................              BYTE *len, 
....................              WORD *id, 
....................              WORD *seq) 
.................... { 
....................     ICMP_PACKET packet; 
....................     WORD CalcChecksum; 
....................     WORD ReceivedChecksum; 
.................... #if !defined(MCHP_MAC) 
....................     WORD checksums[2]; 
.................... #endif 
....................  
.................... //    debug_icmp("\r\nICMP GET "); 
....................  
....................     // Obtain the ICMP Header 
....................     MACGetArray((BYTE*)&packet, ICMP_HEADER_SIZE); 
*
38AA:  MOVLW  03
38AC:  MOVLB  3
38AE:  MOVWF  x61
38B0:  MOVLW  14
38B2:  MOVFF  361,3A0
38B6:  MOVWF  x9F
38B8:  CLRF   xA2
38BA:  MOVLW  08
38BC:  MOVWF  xA1
38BE:  MOVLB  0
38C0:  CALL   10E2
....................  
....................  
.................... #if defined(MCHP_MAC) 
....................    // Calculate the checksum using the Microchip MAC's DMA module 
....................    // The checksum data includes the precomputed checksum in the 
....................    // header, so a valid packet will always have a checksum of 
....................    // 0x0000 if the packet is not disturbed. 
....................    ReceivedChecksum = 0x0000; 
38C4:  MOVLB  3
38C6:  CLRF   x5F
38C8:  CLRF   x5E
....................    CalcChecksum = MACCalcRxChecksum(0+sizeof(IP_HEADER), *len); 
38CA:  MOVFF  30F,03
38CE:  MOVFF  30E,FE9
38D2:  MOVFF  30F,FEA
38D6:  MOVFF  FEF,360
38DA:  CLRF   x62
38DC:  MOVLW  14
38DE:  MOVWF  x61
38E0:  CLRF   x64
38E2:  MOVFF  360,363
38E6:  MOVLB  0
38E8:  CALL   1A9E
38EC:  MOVFF  02,35D
38F0:  MOVFF  01,35C
.................... #endif 
....................  
....................    // Obtain the ICMP data payload 
....................     *len -= ICMP_HEADER_SIZE; 
38F4:  MOVLB  3
38F6:  MOVFF  30E,FE9
38FA:  MOVFF  30F,FEA
38FE:  MOVLW  08
3900:  SUBWF  FEF,W
3902:  MOVWF  FEF
....................     MACGetArray(data, *len); 
3904:  MOVFF  30F,03
3908:  MOVFF  30E,FE9
390C:  MOVFF  30F,FEA
3910:  MOVFF  FEF,360
3914:  MOVFF  30D,3A0
3918:  MOVFF  30C,39F
391C:  CLRF   xA2
391E:  MOVFF  360,3A1
3922:  MOVLB  0
3924:  CALL   10E2
....................  
....................  
.................... #if !defined(MCHP_MAC) 
....................    // Calculte the checksum in local memory without hardware help 
....................     ReceivedChecksum = packet.Checksum; 
....................     packet.Checksum = 0; 
....................  
....................     checksums[0] = ~CalcIPChecksum((BYTE*)&packet, ICMP_HEADER_SIZE); 
....................     checksums[1] = ~CalcIPChecksum(data, *len); 
....................  
....................     CalcChecksum = CalcIPChecksum((BYTE*)checksums, 2 * sizeof(WORD)); 
.................... #endif 
....................  
....................     SwapICMPPacket(&packet); 
3928:  MOVLW  03
392A:  MOVLB  3
392C:  MOVWF  x61
392E:  MOVLW  14
3930:  MOVWF  x60
3932:  MOVLB  0
3934:  RCALL  37CA
....................  
....................     *code = packet.Type; 
3936:  MOVLB  3
3938:  MOVFF  30A,FE9
393C:  MOVFF  30B,FEA
3940:  MOVFF  314,FEF
....................     *id = packet.Identifier; 
3944:  MOVFF  310,FE9
3948:  MOVFF  311,FEA
394C:  MOVFF  319,FEC
3950:  MOVF   FED,F
3952:  MOVFF  318,FEF
....................     *seq = packet.SequenceNumber; 
3956:  MOVFF  312,FE9
395A:  MOVFF  313,FEA
395E:  MOVFF  31B,FEC
3962:  MOVF   FED,F
3964:  MOVFF  31A,FEF
....................  
.................... //    debug_icmp("%U", CalcChecksum == ReceivedChecksum); 
....................  
....................     return ( CalcChecksum == ReceivedChecksum ); 
3968:  MOVF   x5E,W
396A:  SUBWF  x5C,W
396C:  BNZ   3974
396E:  MOVF   x5F,W
3970:  SUBWF  x5D,W
3972:  BZ    3978
3974:  MOVLW  00
3976:  BRA    397A
3978:  MOVLW  01
397A:  MOVWF  01
.................... } 
397C:  MOVLB  0
397E:  GOTO   6C92 (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPPut(NODE_INFO *remote, 
....................  *                               ICMP_CODE code, 
....................  *                               BYTE *data, 
....................  *                               BYTE len, 
....................  *                               WORD id, 
....................  *                               WORD seq) 
....................  * 
....................  * PreCondition:    ICMPIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  code        - ICMP_ECHO_REPLY or ICMP_ECHO_REQUEST 
....................  *                  data        - Data bytes 
....................  *                  len         - Number of bytes to send 
....................  *                  id          - ICMP identifier 
....................  *                  seq         - ICMP sequence number 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            A ICMP packet is created and put on MAC. 
....................  * 
....................  ********************************************************************/ 
.................... void ICMPPut(NODE_INFO *remote, 
....................              ICMP_CODE code, 
....................              BYTE *data, 
....................              BYTE len, 
....................              WORD id, 
....................              WORD seq) 
.................... { 
....................     ICMP_PACKET   packet; 
....................     WORD ICMPLen; 
....................    BUFFER MyTxBuffer; 
....................    MyTxBuffer = MACGetTxBuffer(TRUE); 
3982:  MOVLW  01
3984:  MOVLB  3
3986:  MOVWF  x91
3988:  MOVLB  0
398A:  CALL   1448
398E:  MOVFF  01,35C
....................  
....................    // Abort if there is no where in the Ethernet controller to 
....................    // store this packet. 
....................    if(MyTxBuffer == INVALID_BUFFER) 
3992:  MOVLB  3
3994:  INCFSZ x5C,W
3996:  BRA    399A
....................       return; 
3998:  BRA    3A8E
....................  
....................    IPSetTxBuffer(MyTxBuffer, 0); 
399A:  MOVFF  35C,3AA
399E:  CLRF   xAC
39A0:  MOVLW  14
39A2:  MOVWF  xAB
39A4:  MOVLB  0
39A6:  CALL   1472
....................  
....................  
....................    ICMPLen = ICMP_HEADER_SIZE + (WORD)len; 
39AA:  CLRF   03
39AC:  MOVLB  3
39AE:  MOVF   x0D,W
39B0:  ADDLW  08
39B2:  MOVWF  x5A
39B4:  MOVLW  00
39B6:  ADDWFC 03,W
39B8:  MOVWF  x5B
....................  
....................     packet.Code             = 0; 
39BA:  CLRF   x13
....................     packet.Type             = code; 
39BC:  MOVFF  30A,312
....................     packet.Checksum         = 0; 
39C0:  CLRF   x15
39C2:  CLRF   x14
....................     packet.Identifier       = id; 
39C4:  MOVFF  30F,317
39C8:  MOVFF  30E,316
....................     packet.SequenceNumber   = seq; 
39CC:  MOVFF  311,319
39D0:  MOVFF  310,318
....................  
....................     memcpy((void*)packet.Data, (void*)data, len); 
39D4:  MOVLW  03
39D6:  MOVWF  FEA
39D8:  MOVLW  1A
39DA:  MOVWF  FE9
39DC:  MOVFF  30C,FE2
39E0:  MOVFF  30B,FE1
39E4:  MOVF   x0D,W
39E6:  MOVWF  01
39E8:  BZ    39F2
39EA:  MOVFF  FE6,FEE
39EE:  DECFSZ 01,F
39F0:  BRA    39EA
....................  
....................     SwapICMPPacket(&packet); 
39F2:  MOVLW  03
39F4:  MOVWF  x61
39F6:  MOVLW  12
39F8:  MOVWF  x60
39FA:  MOVLB  0
39FC:  RCALL  37CA
....................  
.................... #if !defined(MCHP_MAC) 
....................     packet.Checksum         = CalcIPChecksum((BYTE*)&packet, 
....................                                     ICMPLen); 
.................... #endif 
....................  
....................     IPPutHeader(remote, 
....................                 IP_PROT_ICMP, 
....................                 (WORD)(ICMP_HEADER_SIZE + len)); 
39FE:  MOVLW  08
3A00:  MOVLB  3
3A02:  ADDWF  x0D,W
3A04:  CLRF   x5E
3A06:  MOVWF  x5D
3A08:  MOVFF  309,392
3A0C:  MOVFF  308,391
3A10:  MOVLW  01
3A12:  MOVWF  x93
3A14:  MOVFF  35E,395
3A18:  MOVFF  35D,394
3A1C:  MOVLB  0
3A1E:  CALL   27CE
....................  
....................     IPPutArray((BYTE*)&packet, ICMPLen); 
3A22:  MOVLW  03
3A24:  MOVLB  3
3A26:  MOVWF  x5E
3A28:  MOVLW  12
3A2A:  MOVFF  35E,3B6
3A2E:  MOVWF  xB5
3A30:  MOVFF  35B,3B8
3A34:  MOVFF  35A,3B7
3A38:  MOVLB  0
3A3A:  CALL   153A
....................  
.................... #if defined(MCHP_MAC) 
....................     // Calculate and write the ICMP checksum using the Microchip MAC's DMA 
....................    packet.Checksum = MACCalcTxChecksum(sizeof(IP_HEADER), ICMPLen); 
3A3E:  MOVLB  3
3A40:  CLRF   xAB
3A42:  MOVLW  14
3A44:  MOVWF  xAA
3A46:  MOVFF  35B,3AD
3A4A:  MOVFF  35A,3AC
3A4E:  MOVLB  0
3A50:  CALL   26F6
3A54:  MOVFF  02,315
3A58:  MOVFF  01,314
....................    IPSetTxBuffer(MyTxBuffer, 2); 
3A5C:  MOVFF  35C,3AA
3A60:  MOVLB  3
3A62:  CLRF   xAC
3A64:  MOVLW  16
3A66:  MOVWF  xAB
3A68:  MOVLB  0
3A6A:  CALL   1472
....................    MACPutArray((BYTE*)&packet.Checksum, 2); 
3A6E:  MOVLW  03
3A70:  MOVLB  3
3A72:  MOVWF  x5E
3A74:  MOVLW  14
3A76:  MOVFF  35E,3B6
3A7A:  MOVWF  xB5
3A7C:  CLRF   xB8
3A7E:  MOVLW  02
3A80:  MOVWF  xB7
3A82:  MOVLB  0
3A84:  CALL   153A
.................... #endif 
....................  
....................  
....................     MACFlush(); 
3A88:  CALL   1656
3A8C:  MOVLB  3
.................... } 
3A8E:  MOVLB  0
3A90:  GOTO   6CF0 (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        void SwapICMPPacket(ICMP_PACKET* p) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           p - ICMP packet header 
....................  * 
....................  * Output:          ICMP packet is swapped 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void SwapICMPPacket(ICMP_PACKET* p) 
.................... { 
....................     p->Identifier           = swaps(p->Identifier); 
*
37CA:  MOVLW  04
37CC:  MOVLB  3
37CE:  ADDWF  x60,W
37D0:  MOVWF  01
37D2:  MOVLW  00
37D4:  ADDWFC x61,W
37D6:  MOVWF  03
37D8:  MOVFF  01,362
37DC:  MOVWF  x63
37DE:  MOVLW  04
37E0:  ADDWF  x60,W
37E2:  MOVWF  FE9
37E4:  MOVLW  00
37E6:  ADDWFC x61,W
37E8:  MOVWF  FEA
37EA:  MOVFF  FEC,365
37EE:  MOVF   FED,F
37F0:  MOVFF  FEF,364
37F4:  MOVFF  365,3B1
37F8:  MOVFF  364,3B0
37FC:  MOVLB  0
37FE:  CALL   1146
3802:  MOVFF  363,FEA
3806:  MOVFF  362,FE9
380A:  MOVFF  02,FEC
380E:  MOVF   FED,F
3810:  MOVFF  01,FEF
....................     p->SequenceNumber       = swaps(p->SequenceNumber); 
3814:  MOVLW  06
3816:  MOVLB  3
3818:  ADDWF  x60,W
381A:  MOVWF  01
381C:  MOVLW  00
381E:  ADDWFC x61,W
3820:  MOVWF  03
3822:  MOVFF  01,362
3826:  MOVWF  x63
3828:  MOVLW  06
382A:  ADDWF  x60,W
382C:  MOVWF  FE9
382E:  MOVLW  00
3830:  ADDWFC x61,W
3832:  MOVWF  FEA
3834:  MOVFF  FEC,365
3838:  MOVF   FED,F
383A:  MOVFF  FEF,364
383E:  MOVFF  365,3B1
3842:  MOVFF  364,3B0
3846:  MOVLB  0
3848:  CALL   1146
384C:  MOVFF  363,FEA
3850:  MOVFF  362,FE9
3854:  MOVFF  02,FEC
3858:  MOVF   FED,F
385A:  MOVFF  01,FEF
....................     p->Checksum             = swaps(p->Checksum); 
385E:  MOVLW  02
3860:  MOVLB  3
3862:  ADDWF  x60,W
3864:  MOVWF  01
3866:  MOVLW  00
3868:  ADDWFC x61,W
386A:  MOVWF  03
386C:  MOVFF  01,362
3870:  MOVWF  x63
3872:  MOVLW  02
3874:  ADDWF  x60,W
3876:  MOVWF  FE9
3878:  MOVLW  00
387A:  ADDWFC x61,W
387C:  MOVWF  FEA
387E:  MOVFF  FEC,365
3882:  MOVF   FED,F
3884:  MOVFF  FEF,364
3888:  MOVFF  365,3B1
388C:  MOVFF  364,3B0
3890:  MOVLB  0
3892:  CALL   1146
3896:  MOVFF  363,FEA
389A:  MOVFF  362,FE9
389E:  MOVFF  02,FEC
38A2:  MOVF   FED,F
38A4:  MOVFF  01,FEF
.................... } 
38A8:  RETLW  00
....................  
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
....................    #include "tcpip/udp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    #include "tcpip/dhcp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    #include "tcpip/telnet2.c" 
.................... #endif 
....................  
.................... #if STACK_USE_ARP 
....................    #include "tcpip/arptsk.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Server Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARPTsk.c 
....................  * Dependencies:    compiler.h 
....................  *                  string.h 
....................  *                  ARP.h 
....................  *                  ARPTsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/20/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/11/04 A macdiscardrx() added to arpprocess() to handle times when an eth packet with arp has padding bytes at the end 
....................  * Darren Rook (CCS)    06/28/04 ArpInit clears cache like in 2.20 
....................  * Darren Rook (CCS)    06/29/04 smArp, Cache no longer static 
....................  * Darren Rook (CCS)    07/12/06 MACDiscardRx spelled wrong (case) 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]. 
....................  *                               I am assuming STACK_CLIENT_MODE is TRUE for ARP. 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8 *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8 *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/arp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.h 
....................  * Dependencies:    Stacktsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
.................... #ifndef ARP_H 
.................... #define ARP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... /* 
....................  * Following codes are must be used with ARPGet/Put functions. 
....................  */ 
.................... #define ARP_REPLY       (0x00) 
.................... #define ARP_REQUEST     (0x01) 
.................... #define ARP_UNKNOWN     (0x02) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL    ARPGet(NODE_INFO *remote, BYTE *opCode); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           ARPIsRxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if ARP receive buffer is full. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #define ARPIsTxReady()      MACIsTxReady(TRUE) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    MACIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode); 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/arptsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Server Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARPTsk.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/20/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]. 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef ARP_TSK_H 
.................... #define ARP_TSK_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP Cache is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ARPInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPProcess(void) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPProcess(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPResolve(IP_ADDR* IPAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr  - IP Address to be resolved. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        An ARP request is sent. 
....................  * 
....................  * Note: 
....................  ********************************************************************/ 
.................... void ARPResolve(IP_ADDR *IPAddr); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPIsResolved(IP_ADDR* IPAddr, 
....................  *                                      MAC_ADDR *MACAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr      - IPAddress to be resolved. 
....................  *                  MACAddr     - Buffer to hold corresponding 
....................  *                                MAC Address. 
....................  * 
....................  * Output:          TRUE if given IP Address has been resolved. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... BOOL ARPIsResolved(IP_ADDR *IPAddr, MAC_ADDR *MACAddr); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define debug_arptask 
.................... //#define debug_arptask   debug_printf 
....................  
.................... /* 
....................  * ARP Task FSM States 
....................  */ 
.................... typedef enum _ARP_STATE 
.................... { 
....................     SM_ARP_IDLE, 
....................     SM_ARP_REPLY 
.................... } ARP_STATE; 
....................  
....................  
.................... /* 
....................  * This ARP task caches one ARP response. 
....................  */ 
.................... static ARP_STATE smARP; 
....................  
.................... static NODE_INFO Cache; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP Cache is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ARPInit(void) 
.................... { 
....................     smARP = SM_ARP_IDLE; 
*
0C66:  BCF    58.1
....................  
....................     Cache.MACAddr.v[0] = 0xff; 
0C68:  MOVLW  FF
0C6A:  MOVLB  1
0C6C:  MOVWF  x15
....................     Cache.MACAddr.v[1] = 0xff; 
0C6E:  MOVWF  x16
....................     Cache.MACAddr.v[2] = 0xff; 
0C70:  MOVWF  x17
....................     Cache.MACAddr.v[3] = 0xff; 
0C72:  MOVWF  x18
....................     Cache.MACAddr.v[4] = 0xff; 
0C74:  MOVWF  x19
....................     Cache.MACAddr.v[5] = 0xff; 
0C76:  MOVWF  x1A
....................  
....................     Cache.IPAddr.Val = 0x0; 
0C78:  CLRF   x1E
0C7A:  CLRF   x1D
0C7C:  CLRF   x1C
0C7E:  CLRF   x1B
.................... } 
0C80:  MOVLB  0
0C82:  GOTO   106E (RETURN)
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPProcess(void) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPProcess(void) 
.................... { 
....................     NODE_INFO remoteNode; 
....................     BYTE opCode; 
....................  
....................     switch(smARP) 
....................     { 
*
1A0C:  MOVLW  00
1A0E:  BTFSC  58.1
1A10:  MOVLW  01
1A12:  XORLW  00
1A14:  BZ    1A18
1A16:  BRA    1A76
....................     case SM_ARP_IDLE: 
....................         if ( !ARPGet(&remoteNode, &opCode) ) 
1A18:  MOVLW  03
1A1A:  MOVLB  3
1A1C:  MOVWF  x14
1A1E:  MOVLW  08
1A20:  MOVWF  x13
1A22:  MOVLW  03
1A24:  MOVWF  x16
1A26:  MOVLW  12
1A28:  MOVWF  x15
1A2A:  MOVLB  0
1A2C:  BRA    1366
1A2E:  MOVF   01,F
1A30:  BNZ   1A34
....................             break; 
1A32:  BRA    1A96
....................  
....................          //dsr add 071204 
....................          //dsr fix 071206 
....................          MACDiscardRx(); 
1A34:  CALL   1076
....................  
....................         if ( opCode == ARP_REPLY ) 
1A38:  MOVLB  3
1A3A:  MOVF   x12,F
1A3C:  BNZ   1A72
....................         { 
.................... 			Cache.MACAddr = remoteNode.MACAddr; 
1A3E:  MOVLW  01
1A40:  MOVWF  FEA
1A42:  MOVLW  15
1A44:  MOVWF  FE9
1A46:  MOVLW  03
1A48:  MOVWF  FE2
1A4A:  MOVLW  08
1A4C:  MOVWF  FE1
1A4E:  MOVLW  06
1A50:  MOVWF  01
1A52:  MOVFF  FE6,FEE
1A56:  DECFSZ 01,F
1A58:  BRA    1A52
....................             Cache.IPAddr.Val = remoteNode.IPAddr.Val; 
1A5A:  MOVFF  311,11E
1A5E:  MOVFF  310,11D
1A62:  MOVFF  30F,11C
1A66:  MOVFF  30E,11B
....................             break; 
1A6A:  MOVLB  0
1A6C:  BRA    1A96
....................         } 
....................         else 
1A6E:  BRA    1A76
1A70:  MOVLB  3
....................             smARP = SM_ARP_REPLY; 
1A72:  BSF    58.1
1A74:  MOVLB  0
....................  
....................     default: 
.................... 		if(ARPPut(&remoteNode, ARP_REPLY)) 
1A76:  MOVLW  03
1A78:  MOVLB  3
1A7A:  MOVWF  x14
1A7C:  MOVLW  08
1A7E:  MOVWF  x13
1A80:  CLRF   x15
1A82:  MOVLB  0
1A84:  BRA    187E
1A86:  MOVF   01,F
1A88:  BZ    1A8E
.................... 		{ 
.................... 			smARP = SM_ARP_IDLE; 
1A8A:  BCF    58.1
.................... 		} 
....................         else 
1A8C:  BRA    1A94
....................             return FALSE; 
1A8E:  MOVLW  00
1A90:  MOVWF  01
1A92:  BRA    1A9A
....................         break; 
1A94:  BRA    1A96
....................  
....................     } 
....................     return TRUE; 
1A96:  MOVLW  01
1A98:  MOVWF  01
.................... } 
1A9A:  GOTO   6BAE (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPResolve(IP_ADDR* IPAddr) 
....................  * 
....................  * PreCondition:    MACIsTxReady(TRUE) returns TRUE 
....................  * 
....................  * Input:           IPAddr  - IP Address to be resolved. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        An ARP request is sent. 
....................  ********************************************************************/ 
.................... void ARPResolve(IP_ADDR *IPAddr) 
.................... { 
....................     NODE_INFO remoteNode; 
....................  
....................     remoteNode.IPAddr = *IPAddr; 
....................  
....................     ARPPut(&remoteNode, ARP_REQUEST); 
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPIsResolved(IP_ADDR* IPAddr, 
....................  *                                      MAC_ADDR *MACAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr      - IPAddress to be resolved. 
....................  *                  MACAddr     - Buffer to hold corresponding 
....................  *                                MAC Address. 
....................  * 
....................  * Output:          TRUE if given IP Address has been resolved. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... BOOL ARPIsResolved(IP_ADDR *IPAddr, MAC_ADDR *MACAddr) 
.................... { 
....................     if(Cache.IPAddr.Val == IPAddr->Val || Cache.IPAddr.Val == AppConfig.MyGateway.Val) 
....................     { 
....................         *MACAddr = Cache.MACAddr; 
....................         return TRUE; 
....................     } 
....................     return FALSE; 
.................... } 
....................  
....................  
....................  
....................    #include "tcpip/arp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.c 
....................  * Dependencies:    string.h 
....................  *                  stacktsk.h 
....................  *                  helpers.h 
....................  *                  arp.h 
....................  *                  mac.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8 *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8 *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/arp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.h 
....................  * Dependencies:    Stacktsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
.................... #ifndef ARP_H 
.................... #define ARP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... #include "tcpip/mac.h" 
....................  
.................... /* 
....................  * Following codes are must be used with ARPGet/Put functions. 
....................  */ 
.................... #define ARP_REPLY       (0x00) 
.................... #define ARP_REQUEST     (0x01) 
.................... #define ARP_UNKNOWN     (0x02) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL    ARPGet(NODE_INFO *remote, BYTE *opCode); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           ARPIsRxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if ARP receive buffer is full. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #define ARPIsTxReady()      MACIsTxReady(TRUE) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    MACIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode); 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #define debug_arp 
.................... //#define debug_arp debug_printf 
....................  
.................... // ARP Operation codes. 
.................... #define ARP_OPERATION_REQ       0x01u 
.................... #define ARP_OPERATION_RESP      0x02u 
....................  
.................... // ETHERNET packet type as defined by IEEE 802.3 
.................... #define HW_ETHERNET             (0x0001u) 
.................... #define ARP_IP                  (0x0800u) 
....................  
....................  
....................  
.................... // ARP packet 
.................... typedef struct _ARP_PACKET 
.................... { 
....................     WORD        HardwareType; 
....................     WORD        Protocol; 
....................     BYTE        MACAddrLen; 
....................     BYTE        ProtocolLen; 
....................     WORD        Operation; 
....................     MAC_ADDR    SenderMACAddr; 
....................     IP_ADDR     SenderIPAddr; 
....................     MAC_ADDR    TargetMACAddr; 
....................     IP_ADDR     TargetIPAddr; 
.................... } ARP_PACKET; 
....................  
.................... // Helper function 
.................... static void SwapARPPacket(ARP_PACKET *p); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... int1 ARPGet(NODE_INFO *remote, int8 *opCode) 
.................... { 
....................     ARP_PACKET packet; 
....................  
....................     //MACGetArray((int8*)&packet, sizeof(packet)); 
....................     MACGetArray(&packet, sizeof(ARP_PACKET)); 
*
1366:  MOVLW  03
1368:  MOVLB  3
136A:  MOVWF  xA0
136C:  MOVLW  17
136E:  MOVWF  x9F
1370:  CLRF   xA2
1372:  MOVLW  1C
1374:  MOVWF  xA1
1376:  MOVLB  0
1378:  RCALL  10E2
....................  
....................     MACDiscardRx(); 
137A:  RCALL  1076
....................  
....................     SwapARPPacket(&packet); 
137C:  MOVLW  03
137E:  MOVLB  3
1380:  MOVWF  x34
1382:  MOVLW  17
1384:  MOVWF  x33
1386:  MOVLB  0
1388:  RCALL  1292
....................  
....................    //debug_arp("\r\nARP: HW:%LX PR:%LX ML:%U PL:%U O:%LX TI:%U.%U.%U.%U FI:%U.%U.%U.%U", 
....................      // packet.HardwareType, packet.Protocol, packet.MACAddrLen, packet.ProtocolLen, 
....................      // packet.Operation, packet.TargetIPAddr.v[0],packet.TargetIPAddr.v[1], 
....................      // packet.TargetIPAddr.v[2],packet.TargetIPAddr.v[3], 
....................      // packet.SenderIPAddr.v[0],packet.SenderIPAddr.v[1],packet.SenderIPAddr.v[2],packet.SenderIPAddr.v[3]); 
....................  
....................     if ( packet.HardwareType != HW_ETHERNET     || 
....................          packet.MACAddrLen != sizeof(MAC_ADDR)  || 
....................          packet.ProtocolLen != sizeof(IP_ADDR) ) 
138A:  MOVLB  3
138C:  DECFSZ x17,W
138E:  BRA    13A0
1390:  MOVF   x18,F
1392:  BNZ   13A0
1394:  MOVF   x1B,W
1396:  SUBLW  06
1398:  BNZ   13A0
139A:  MOVF   x1C,W
139C:  SUBLW  04
139E:  BZ    13A6
....................          return FALSE; 
13A0:  MOVLW  00
13A2:  MOVWF  01
13A4:  BRA    1442
....................  
....................     if ( packet.Operation == ARP_OPERATION_RESP ) 
13A6:  MOVF   x1D,W
13A8:  SUBLW  02
13AA:  BNZ   13BC
13AC:  MOVF   x1E,F
13AE:  BNZ   13BC
....................         *opCode = ARP_REPLY; 
13B0:  MOVFF  315,FE9
13B4:  MOVFF  316,FEA
13B8:  CLRF   FEF
....................     else if ( packet.Operation == ARP_OPERATION_REQ ) 
13BA:  BRA    13E4
13BC:  DECFSZ x1D,W
13BE:  BRA    13D2
13C0:  MOVF   x1E,F
13C2:  BNZ   13D2
....................         *opCode = ARP_REQUEST; 
13C4:  MOVFF  315,FE9
13C8:  MOVFF  316,FEA
13CC:  MOVLW  01
13CE:  MOVWF  FEF
....................     else 
13D0:  BRA    13E4
....................     { 
....................         *opCode = ARP_UNKNOWN; 
13D2:  MOVFF  315,FE9
13D6:  MOVFF  316,FEA
13DA:  MOVLW  02
13DC:  MOVWF  FEF
....................         return FALSE; 
13DE:  MOVLW  00
13E0:  MOVWF  01
13E2:  BRA    1442
....................     } 
....................  
....................     if(packet.TargetIPAddr.Val == AppConfig.MyIPAddr.Val) 
13E4:  MOVF   18,W
13E6:  SUBWF  x2F,W
13E8:  BNZ   143C
13EA:  MOVF   19,W
13EC:  SUBWF  x30,W
13EE:  BNZ   143C
13F0:  MOVF   1A,W
13F2:  SUBWF  x31,W
13F4:  BNZ   143C
13F6:  MOVF   1B,W
13F8:  SUBWF  x32,W
13FA:  BNZ   143C
....................     { 
....................         remote->MACAddr     = packet.SenderMACAddr; 
13FC:  MOVFF  313,FE9
1400:  MOVFF  314,FEA
1404:  MOVLW  03
1406:  MOVWF  FE2
1408:  MOVLW  1F
140A:  MOVWF  FE1
140C:  MOVLW  06
140E:  MOVWF  01
1410:  MOVFF  FE6,FEE
1414:  DECFSZ 01,F
1416:  BRA    1410
....................         remote->IPAddr      = packet.SenderIPAddr; 
1418:  MOVLW  06
141A:  ADDWF  x13,W
141C:  MOVWF  FE9
141E:  MOVLW  00
1420:  ADDWFC x14,W
1422:  MOVWF  FEA
1424:  MOVFF  325,FEF
1428:  MOVFF  326,FEC
142C:  MOVFF  327,FEC
1430:  MOVFF  328,FEC
....................         return TRUE; 
1434:  MOVLW  01
1436:  MOVWF  01
1438:  BRA    1442
....................     } 
....................     else 
143A:  BRA    1442
....................         return FALSE; 
143C:  MOVLW  00
143E:  MOVWF  01
1440:  BRA    1442
.................... } 
1442:  MOVLB  0
1444:  GOTO   1A2E (RETURN)
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          TRUE - The ARP packet was generated properly 
....................  *               FALSE - Unable to allocate a TX buffer 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode) 
.................... { 
....................     ARP_PACKET packet; 
....................  
....................    BUFFER MyTxBuffer; 
....................    MyTxBuffer = MACGetTxBuffer(TRUE); 
*
187E:  MOVLW  01
1880:  MOVLB  3
1882:  MOVWF  x91
1884:  MOVLB  0
1886:  RCALL  1448
1888:  MOVFF  01,332
....................     
....................    // Do not respond if there is no room to generate the ARP reply 
....................    if(MyTxBuffer == INVALID_BUFFER) 
188C:  MOVLB  3
188E:  INCFSZ x32,W
1890:  BRA    1898
....................       return FALSE; 
1892:  MOVLW  00
1894:  MOVWF  01
1896:  BRA    1A06
....................  
....................    MACSetTxBuffer(MyTxBuffer, 0); 
1898:  MOVFF  332,3AA
189C:  CLRF   xAC
189E:  CLRF   xAB
18A0:  MOVLB  0
18A2:  RCALL  1472
....................     
....................     
....................     packet.HardwareType             = HW_ETHERNET; 
18A4:  MOVLB  3
18A6:  CLRF   x17
18A8:  MOVLW  01
18AA:  MOVWF  x16
....................     packet.Protocol                 = ARP_IP; 
18AC:  MOVLW  08
18AE:  MOVWF  x19
18B0:  CLRF   x18
....................     packet.MACAddrLen               = sizeof(MAC_ADDR); 
18B2:  MOVLW  06
18B4:  MOVWF  x1A
....................     packet.ProtocolLen              = sizeof(IP_ADDR); 
18B6:  MOVLW  04
18B8:  MOVWF  x1B
....................  
....................     if ( opCode == ARP_REQUEST ) 
18BA:  DECFSZ x15,W
18BC:  BRA    18D4
....................     { 
....................         packet.Operation            = ARP_OPERATION_REQ; 
18BE:  CLRF   x1D
18C0:  MOVLW  01
18C2:  MOVWF  x1C
....................         packet.TargetMACAddr.v[0]   = 0xff; 
18C4:  MOVLW  FF
18C6:  MOVWF  x28
....................         packet.TargetMACAddr.v[1]   = 0xff; 
18C8:  MOVWF  x29
....................         packet.TargetMACAddr.v[2]   = 0xff; 
18CA:  MOVWF  x2A
....................         packet.TargetMACAddr.v[3]   = 0xff; 
18CC:  MOVWF  x2B
....................         packet.TargetMACAddr.v[4]   = 0xff; 
18CE:  MOVWF  x2C
....................         packet.TargetMACAddr.v[5]   = 0xff; 
18D0:  MOVWF  x2D
....................     } 
....................     else 
18D2:  BRA    1902
....................     { 
....................         packet.Operation            = ARP_OPERATION_RESP; 
18D4:  CLRF   x1D
18D6:  MOVLW  02
18D8:  MOVWF  x1C
....................         packet.TargetMACAddr        = remote->MACAddr; 
18DA:  MOVFF  314,03
18DE:  MOVFF  313,333
18E2:  MOVFF  314,334
18E6:  MOVLW  03
18E8:  MOVWF  FEA
18EA:  MOVLW  28
18EC:  MOVWF  FE9
18EE:  MOVFF  314,FE2
18F2:  MOVFF  313,FE1
18F6:  MOVLW  06
18F8:  MOVWF  01
18FA:  MOVFF  FE6,FEE
18FE:  DECFSZ 01,F
1900:  BRA    18FA
....................     } 
....................  
....................     packet.SenderMACAddr = AppConfig.MyMACAddr; 
1902:  MOVLW  03
1904:  MOVWF  FEA
1906:  MOVLW  1E
1908:  MOVWF  FE9
190A:  CLRF   FE2
190C:  MOVLW  1C
190E:  MOVWF  FE1
1910:  MOVLW  06
1912:  MOVWF  01
1914:  MOVFF  FE6,FEE
1918:  DECFSZ 01,F
191A:  BRA    1914
....................     packet.SenderIPAddr  = AppConfig.MyIPAddr; 
191C:  MOVFF  1B,327
1920:  MOVFF  1A,326
1924:  MOVFF  19,325
1928:  MOVFF  18,324
....................  
....................  
....................     // Check to see if target is on same subnet, if not, find Gateway MAC. 
....................     // Once we get Gateway MAC, all access to remote host will go through Gateway. 
....................     if((packet.SenderIPAddr.Val ^ remote->IPAddr.Val) & AppConfig.MyMask.Val) 
192C:  MOVLW  06
192E:  ADDWF  x13,W
1930:  MOVWF  FE9
1932:  MOVLW  00
1934:  ADDWFC x14,W
1936:  MOVWF  FEA
1938:  MOVFF  FEF,00
193C:  MOVFF  FEC,01
1940:  MOVFF  FEC,02
1944:  MOVFF  FEC,03
1948:  MOVF   00,W
194A:  XORWF  x24,W
194C:  MOVWF  x33
194E:  MOVF   01,W
1950:  XORWF  x25,W
1952:  MOVWF  x34
1954:  MOVF   02,W
1956:  XORWF  x26,W
1958:  MOVWF  x35
195A:  MOVF   03,W
195C:  XORWF  x27,W
195E:  MOVWF  x36
1960:  MOVF   x33,W
1962:  ANDWF  22,W
1964:  MOVWF  00
1966:  MOVF   x34,W
1968:  ANDWF  23,W
196A:  MOVWF  01
196C:  MOVF   x35,W
196E:  ANDWF  24,W
1970:  MOVWF  02
1972:  MOVF   x36,W
1974:  ANDWF  25,W
1976:  MOVWF  03
1978:  MOVF   00,F
197A:  BNZ   1988
197C:  MOVF   01,F
197E:  BNZ   1988
1980:  MOVF   02,F
1982:  BNZ   1988
1984:  MOVF   03,F
1986:  BZ    199A
....................     { 
....................       packet.TargetIPAddr = AppConfig.MyGateway; 
1988:  MOVFF  29,331
198C:  MOVFF  28,330
1990:  MOVFF  27,32F
1994:  MOVFF  26,32E
....................     } 
....................     else 
1998:  BRA    19C6
....................         packet.TargetIPAddr             = remote->IPAddr; 
199A:  MOVLW  06
199C:  ADDWF  x13,W
199E:  MOVWF  FE9
19A0:  MOVLW  00
19A2:  ADDWFC x14,W
19A4:  MOVWF  FEA
19A6:  MOVFF  FEF,00
19AA:  MOVFF  FEC,01
19AE:  MOVFF  FEC,02
19B2:  MOVFF  FEC,03
19B6:  MOVFF  03,331
19BA:  MOVFF  02,330
19BE:  MOVFF  01,32F
19C2:  MOVFF  00,32E
....................  
....................     SwapARPPacket(&packet); 
19C6:  MOVLW  03
19C8:  MOVWF  x34
19CA:  MOVLW  16
19CC:  MOVWF  x33
19CE:  MOVLB  0
19D0:  RCALL  1292
....................  
....................     MACPutHeader(&packet.TargetMACAddr, MAC_ARP, sizeof(packet)); 
19D2:  MOVLW  03
19D4:  MOVLB  3
19D6:  MOVWF  xAF
19D8:  MOVLW  28
19DA:  MOVWF  xAE
19DC:  MOVLW  06
19DE:  MOVWF  xB0
19E0:  CLRF   xB2
19E2:  MOVLW  1C
19E4:  MOVWF  xB1
19E6:  MOVLB  0
19E8:  RCALL  1588
....................  
....................     //MACPutArray((int8*)&packet, sizeof(packet)); 
....................     MACPutArray(&packet, sizeof(ARP_PACKET)); 
19EA:  MOVLW  03
19EC:  MOVLB  3
19EE:  MOVWF  xB6
19F0:  MOVLW  16
19F2:  MOVWF  xB5
19F4:  CLRF   xB8
19F6:  MOVLW  1C
19F8:  MOVWF  xB7
19FA:  MOVLB  0
19FC:  RCALL  153A
....................  
....................     MACFlush(); 
19FE:  RCALL  1656
....................     
....................    return TRUE; 
1A00:  MOVLW  01
1A02:  MOVWF  01
1A04:  MOVLB  3
.................... } 
1A06:  MOVLB  0
1A08:  GOTO   1A86 (RETURN)
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static void SwapARPPacket(ARP_PACKET* p) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           p   - ARP packet to be swapped. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void SwapARPPacket(ARP_PACKET *p) 
.................... { 
....................     p->HardwareType     = swaps(p->HardwareType); 
*
1292:  MOVLB  3
1294:  MOVFF  333,01
1298:  MOVFF  334,03
129C:  MOVFF  333,335
12A0:  MOVFF  334,336
12A4:  MOVFF  333,FE9
12A8:  MOVFF  334,FEA
12AC:  MOVFF  FEC,338
12B0:  MOVF   FED,F
12B2:  MOVFF  FEF,337
12B6:  MOVFF  338,3B1
12BA:  MOVFF  337,3B0
12BE:  MOVLB  0
12C0:  RCALL  1146
12C2:  MOVFF  336,FEA
12C6:  MOVFF  335,FE9
12CA:  MOVFF  02,FEC
12CE:  MOVF   FED,F
12D0:  MOVFF  01,FEF
....................     p->Protocol         = swaps(p->Protocol); 
12D4:  MOVLW  02
12D6:  MOVLB  3
12D8:  ADDWF  x33,W
12DA:  MOVWF  01
12DC:  MOVLW  00
12DE:  ADDWFC x34,W
12E0:  MOVWF  03
12E2:  MOVFF  01,335
12E6:  MOVWF  x36
12E8:  MOVLW  02
12EA:  ADDWF  x33,W
12EC:  MOVWF  FE9
12EE:  MOVLW  00
12F0:  ADDWFC x34,W
12F2:  MOVWF  FEA
12F4:  MOVFF  FEC,338
12F8:  MOVF   FED,F
12FA:  MOVFF  FEF,337
12FE:  MOVFF  338,3B1
1302:  MOVFF  337,3B0
1306:  MOVLB  0
1308:  RCALL  1146
130A:  MOVFF  336,FEA
130E:  MOVFF  335,FE9
1312:  MOVFF  02,FEC
1316:  MOVF   FED,F
1318:  MOVFF  01,FEF
....................     p->Operation        = swaps(p->Operation); 
131C:  MOVLW  06
131E:  MOVLB  3
1320:  ADDWF  x33,W
1322:  MOVWF  01
1324:  MOVLW  00
1326:  ADDWFC x34,W
1328:  MOVWF  03
132A:  MOVFF  01,335
132E:  MOVWF  x36
1330:  MOVLW  06
1332:  ADDWF  x33,W
1334:  MOVWF  FE9
1336:  MOVLW  00
1338:  ADDWFC x34,W
133A:  MOVWF  FEA
133C:  MOVFF  FEC,338
1340:  MOVF   FED,F
1342:  MOVFF  FEF,337
1346:  MOVFF  338,3B1
134A:  MOVFF  337,3B0
134E:  MOVLB  0
1350:  RCALL  1146
1352:  MOVFF  336,FEA
1356:  MOVFF  335,FE9
135A:  MOVFF  02,FEC
135E:  MOVF   FED,F
1360:  MOVFF  01,FEF
.................... } 
1364:  RETLW  00
....................  
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    #include "tcpip/http.c" 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///                              HTTP.C 
.................... /// 
.................... /// Simple webserver for the Microchip TCP/IP stack. 
.................... /// NOTE: THIS IS A DIFFERENT HTTP.C THAN WHAT MICROCHIP PROVIDES 
.................... /// 
.................... /// **** CONFIGURATION **** 
.................... /// 
.................... /// STACK_USE_HTTP - Define this to be true before you include stacktsk.c 
.................... ///        in your application.  Defining this to be true will cause 
.................... ///        the stack to include the HTTP portion and execute the init 
.................... ///        and process any HTTP tasks. 
.................... /// 
.................... /// HTTP_PORT - The TCP/IP port the HTTP server will listen to for HTTP 
.................... ///        connections. 
.................... /// 
.................... /// HTTP_NUM_SOCKETS - Number of sockets the stack will open for the 
.................... ///        HTTP server.  You probably will be fine with just 1.  The 
.................... ///        more sockets you use the more RAM is used to hold buffers 
.................... ///        and state configuration. 
.................... /// 
.................... /// HTTP_GET_PARAM_MAX_SIZE - This defines the maximum size of several 
.................... ///        buffers.  This limits the size of your GET or POST requests 
.................... ///        and all CGI POST data: 
.................... ///            If using GET, then max amount of cgi data is this value 
.................... ///            minus everything else on the initial GET command (which 
.................... ///            also includes the filename).  I believe the max specified 
.................... ///            by W3C is 255. 
.................... ///            If using POST, then this is the maximum size for one 
.................... ///            key=value pair (including the '=' sign). 
.................... ///        These values do not inlude any escape characters. 
.................... /// 
.................... /// HTTP_USE_CHUNKS - Set to TRUE to make the HTTP server 1.1 compliant 
.................... ///      and will use Transfer-Encoding: chunked.  Default is FALSE. 
.................... /// 
.................... /// HTTP_USE_DOUBLE_ESCAPE - If your HTTP pages need more escape 
.................... ///      chars, set this to TRUE.  When set to TRUE your HTTP pages have 
.................... ///      two escape characters after the %.  An example of each: 
.................... ///         If FALSE: %A 
.................... ///         If TRUE: %0A 
.................... /// 
.................... /// HTTP_USE_CONTENT_TYPE - Set to TRUE if your http_get_page() has a third 
.................... ///      parameter which is the content-type of the requested page. 
.................... /// 
.................... /// **** HOW IT WORKS **** 
.................... /// 
.................... /// The TCP/IP stack will open sockets to the desired ports.  It will 
.................... /// then listen for GET or POST requests.  When it gets a GET or POST 
.................... /// request it passes the page request to the callback function 
.................... /// http_get_page() which then returns 0 if the page doesn't exist, or 
.................... /// a pointer to the constant memory area that holds the page in program 
.................... /// memory.  If it was a POST request it waits until the HTTP header is 
.................... /// done and then saves the POST data into a buffer, and passes the 
.................... /// buffer to the callback function http_exec_cgi().  http_exec_cgi() will 
.................... /// parse the CGI post data and act upon it.  When done, the HTTP 
.................... /// server then responds by sending the page.  If the page is to have 
.................... /// variable data, it can be represented by an escape code - %0 or %1 
.................... /// for example.  When the HTTP stack sees such an escape code it calls 
.................... /// the callback function http_format_char() to format the escape code 
.................... /// into the needed variable data (such as ADC readings).  After the 
.................... /// HTTP stack is done sending the request it will close the port. 
.................... /// If the page didn't exist in program memory it will send a 404 File 
.................... /// not found error.  If there was a problem/timeout parsing the request 
.................... /// the HTTP stack will send a 500 Internal Server Error response. 
.................... /// 
.................... /// **** CALL BACK FUNCTIONS **** 
.................... /// 
.................... /// Your main application must provide the following callback functions to 
.................... /// fill application dependent needs: 
.................... /// 
.................... /// http_get_page(char *file); 
.................... ///    If HTTP_USE_CONTENT_TYPE is FALSE, this is the proper prototype.  Else, 
.................... ///    if HTTP_USE_CONTENT_TYPE is TRUE then see the next paragraph. 
.................... ///    A call-back function provided by your application that finds the 
.................... ///    required file.  If the file exists, returns address to page in 
.................... ///    program memory.  If it doesn't exist, returns 0. 
.................... /// 
.................... /// http_get_page(char *file_str, int32 *retAddress, char *retStr); 
.................... ///    If HTTP_USE_CONTENT_TYPE is TRUE, this is the proper prototype.  Else, 
.................... ///    if HTTP_USE_CONTENT_TYPE is FALSE then see the previous paragraph. 
.................... ///    A call-back function provided by your application that finds the 
.................... ///    required file.  If the file exists, saves value to retAddress.  If 
.................... ///    the file doesn't exist, will save 0 to retAddress.  retStr is the 
.................... ///    content-type (text/html, text/xml, etc). 
.................... /// 
.................... /// http_exec_cgi(int32 file, char *key, char *val); 
.................... ///    A call-back function provided by your application that processes incoming 
.................... ///    CGI commands.  key and val are the incoming key=val CGI pairs.  file is 
.................... ///    the file address as returned by http_get_page(). 
.................... /// 
.................... /// int http_format_char(int32 file, char id, char *str, int8 max_ret); 
.................... ///    Given an escaped character in the program memory HTTP file, convert to 
.................... ///    variable data.  id is the escaped character, *str is where to save the 
.................... ///    result.  max_ret is the maximum amount of bytes you can save to *str. 
.................... ///    Returns the number of bytes written to *str.  file is 
.................... ///    the file address as returned by http_get_page(). 
.................... /// 
.................... /// **** LIMITATIONS **** 
.................... /// 
.................... /// When creating web pages with forms, keep your form names (keys) simple 
.................... /// because the HTTP stack does not format the escape characters.  For example, 
.................... /// when sending "Pass+Word" the HTTP client will parse it out as "Pass%2bWord". 
.................... /// The HTTP stack will correctly parse out the escape chars when retrieving 
.................... /// the value, but not the key.  Therefore keep your keys simple. 
.................... /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... /// 
.................... /// * Author         Date           Comment 
.................... /// *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
.................... /// 
.................... /// * Darren Rook    Oct 05 2006    Bug fix involving POST 
.................... /// 
.................... /// * Darren Rook    Summer 2006    Large parts of this rewritten to fix 
.................... ///                                 many bugs.  The biggest bug is that 
.................... ///                                 it can send pages and receive CGI that 
.................... ///                                 is larger than 1 TCP packet.  Also 
.................... ///                                 added the HTTP_USE_CHUNKS, 
.................... ///                                 HTTP_USE_DOUBLE_ESCAPE and 
.................... ///                                 HTTP_USE_CONTENT_TYPE paremeters. 
.................... /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2006 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #include "tcpip/http.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ///                                                                     /// 
.................... ///                              HTTP.H                                 /// 
.................... ///                                                                     /// 
.................... /// Simple webserver for the Microchip TCP/IP stack.                    /// 
.................... /// NOTE: THIS IS A DIFFERENT HTTP.H THAN WHAT MICROCHIP PROVIDES       /// 
.................... ///                                                                     /// 
.................... /// See HTTP.C for documenation                                         /// 
.................... ///                                                                     /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2006 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef HTTP_USE_CHUNKS 
.................... #define HTTP_USE_CHUNKS   FALSE 
.................... #endif 
....................  
.................... #ifndef HTTP_USE_DOUBLE_ESCAPE 
.................... #define HTTP_USE_DOUBLE_ESCAPE   FALSE 
.................... #endif 
....................  
.................... #ifndef HTTP_USE_CONTENT_TYPE 
.................... #define HTTP_USE_CONTENT_TYPE   FALSE 
.................... #endif 
....................  
.................... #ifndef HTTP_PORT 
.................... #define HTTP_PORT             80 
.................... #endif 
....................  
.................... #ifndef HTTP_NUM_SOCKETS 
.................... #define HTTP_NUM_SOCKETS      1 
.................... #endif 
....................  
.................... #ifndef HTTP_GET_PARAM_MAX_SIZE 
.................... #define HTTP_GET_PARAM_MAX_SIZE  254 
.................... #endif 
....................  
.................... void HTTP_Init(void); 
.................... void HTTP_Task(void); 
....................  
.................... //**** CALLBACKS START ******/// 
....................  
.................... /// the following three functions are callbacks and 
.................... /// must be written in your main application!!!  see the documentation above 
.................... /// for more help. 
....................  
.................... #if HTTP_USE_CONTENT_TYPE 
....................  void http_get_page(char *file_str, int32 *retAddress, char *retStr); 
.................... #else 
....................  int32 http_get_page(char *file_str); 
.................... #endif 
....................  
.................... int8 http_format_char(int32 file, char id, char *str, int8 max_ret); 
.................... void http_exec_cgi(int32 file, char *key, char *val); 
....................  
.................... //**** CALLBACKS END ******/// 
....................  
....................  
.................... //#define debug_http   debug_printf 
.................... #define debug_http(a,b,c,d,e,f,g,h,i,k,l,m,n,o,p,q,r,s,t,u) 
....................  
.................... const char http_404_error[]="<HTML><BODY><H1>404 Error</H1><HR><P>File Not found.</BODY></HTML>"; 
.................... const char http_500_error[]="<HTML><BODY><H1>500 Error</H1><HR><P>Internal Server Error</BODY></HTML>"; 
....................  
.................... //key=val pair string, & delimited 
.................... void http_parse_cgi_str(int32 file, char *cgistr); 
....................  
.................... int8 http_socket[HTTP_NUM_SOCKETS]={INVALID_SOCKET}; 
....................  
.................... enum { 
....................    HTTP_DISABLED = 0xFF, 
....................    HTTP_IGNORE, 
....................    HTTP_LISTEN_WAIT, 
....................    HTTP_CONNECTED, 
....................    HTTP_GET_HEADERS, 
....................    HTTP_GET_POST, 
....................    HTTP_GET_POST_CONTINUE, 
....................    HTTP_SEND_RESPONSE, 
....................    HTTP_SEND_RESPONSE_CONTINUE, 
....................    HTTP_CLOSE, 
....................    HTTP_CLOSE_WAITING, 
....................    HTTP_CLOSED 
.................... } http_state[HTTP_NUM_SOCKETS]={HTTP_IGNORE}; 
....................  
.................... //strips out any escape characters that the HTTP client may have inserted. 
.................... // (+ is replaced with space) 
.................... // (%xx is replaced with character representation of xx) 
.................... char * http_escape_chars(char *str) 
.................... { 
....................    char *ostr; 
....................    char new[3]; 
....................    char c; 
....................    char val; 
....................  
....................    new[2]=0; 
*
47A6:  MOVLB  3
47A8:  CLRF   x29
....................  
....................    ostr = str; 
47AA:  MOVFF  324,326
47AE:  MOVFF  323,325
....................  
....................    while((c=*str) != 0) 
....................    { 
47B2:  MOVFF  324,03
47B6:  MOVFF  323,FE9
47BA:  MOVFF  324,FEA
47BE:  MOVFF  FEF,32A
47C2:  MOVF   x2A,F
47C4:  BZ    4896
....................       if (c=='+') 
47C6:  MOVF   x2A,W
47C8:  SUBLW  2B
47CA:  BNZ   47E4
....................          *str++=' '; 
47CC:  MOVFF  324,03
47D0:  MOVF   x23,W
47D2:  INCF   x23,F
47D4:  BTFSC  FD8.2
47D6:  INCF   x24,F
47D8:  MOVWF  FE9
47DA:  MOVFF  03,FEA
47DE:  MOVLW  20
47E0:  MOVWF  FEF
....................       else if (c=='%') 
47E2:  BRA    4892
47E4:  MOVF   x2A,W
47E6:  SUBLW  25
47E8:  BNZ   488C
....................       { 
....................          memcpy(new, str + 1, 2); 
47EA:  MOVLW  01
47EC:  ADDWF  x23,W
47EE:  MOVWF  x2C
47F0:  MOVLW  00
47F2:  ADDWFC x24,W
47F4:  MOVWF  x2D
47F6:  MOVLW  03
47F8:  MOVWF  FEA
47FA:  MOVLW  27
47FC:  MOVWF  FE9
47FE:  MOVFF  32D,FE2
4802:  MOVFF  32C,FE1
4806:  MOVLW  02
4808:  MOVWF  01
480A:  MOVFF  FE6,FEE
480E:  DECFSZ 01,F
4810:  BRA    480A
....................          val = strtoul(new, 0, 16); 
4812:  MOVLW  03
4814:  MOVWF  x2D
4816:  MOVLW  27
4818:  MOVWF  x2C
481A:  CLRF   x2F
481C:  CLRF   x2E
481E:  MOVLW  10
4820:  MOVWF  x30
4822:  MOVLB  0
4824:  BRA    4334
4826:  MOVFF  01,32B
....................          *str++ = val; 
482A:  MOVLB  3
482C:  MOVFF  324,03
4830:  MOVF   x23,W
4832:  INCF   x23,F
4834:  BTFSC  FD8.2
4836:  INCF   x24,F
4838:  MOVWF  FE9
483A:  MOVFF  03,FEA
483E:  MOVFF  32B,FEF
....................          memmove(str, str + 2, strlen(str) - 1); 
4842:  MOVLW  02
4844:  ADDWF  x23,W
4846:  MOVWF  x2C
4848:  MOVLW  00
484A:  ADDWFC x24,W
484C:  MOVWF  x2D
484E:  MOVFF  324,33F
4852:  MOVFF  323,33E
4856:  MOVLB  0
4858:  RCALL  46A0
485A:  MOVFF  02,32F
485E:  MOVFF  01,32E
4862:  MOVLW  01
4864:  MOVLB  3
4866:  SUBWF  01,W
4868:  MOVWF  x30
486A:  MOVLW  00
486C:  SUBWFB 02,W
486E:  MOVWF  x31
4870:  MOVFF  324,333
4874:  MOVFF  323,332
4878:  MOVFF  32D,335
487C:  MOVFF  32C,334
4880:  MOVFF  330,336
4884:  MOVLB  0
4886:  BRA    46DC
....................       } 
....................       else 
4888:  BRA    4892
488A:  MOVLB  3
....................          str++; 
488C:  INCF   x23,F
488E:  BTFSC  FD8.2
4890:  INCF   x24,F
....................    } 
4892:  MOVLB  3
4894:  BRA    47B2
....................  
....................    return(ostr); 
4896:  MOVFF  325,01
489A:  MOVFF  326,02
.................... } 
489E:  MOVLB  0
48A0:  RETLW  00
....................  
.................... void http_parse_cgi_string(int32 file, char *ptr) 
.................... { 
....................    char *pKey, *pValue, c; 
....................  
....................    pKey=ptr; 
*
4CCC:  MOVFF  31D,31F
4CD0:  MOVFF  31C,31E
....................    pValue=0; 
4CD4:  MOVLB  3
4CD6:  CLRF   x21
4CD8:  CLRF   x20
....................  
....................    while(TRUE) 
....................    { 
....................       c = *ptr; 
4CDA:  MOVFF  31C,FE9
4CDE:  MOVFF  31D,FEA
4CE2:  MOVFF  FEF,322
....................       if ((c=='&') || (c==0)) 
4CE6:  MOVF   x22,W
4CE8:  SUBLW  26
4CEA:  BZ    4CF0
4CEC:  MOVF   x22,F
4CEE:  BNZ   4D4C
....................       { 
....................          *ptr=0; 
4CF0:  MOVFF  31C,FE9
4CF4:  MOVFF  31D,FEA
4CF8:  CLRF   FEF
....................          http_escape_chars(pKey); 
4CFA:  MOVFF  31F,324
4CFE:  MOVFF  31E,323
4D02:  MOVLB  0
4D04:  RCALL  47A6
....................          http_escape_chars(pValue); 
4D06:  MOVFF  321,324
4D0A:  MOVFF  320,323
4D0E:  RCALL  47A6
....................          http_exec_cgi(file, pKey, pValue); 
4D10:  MOVFF  31B,326
4D14:  MOVFF  31A,325
4D18:  MOVFF  319,324
4D1C:  MOVFF  318,323
4D20:  MOVFF  31F,328
4D24:  MOVFF  31E,327
4D28:  MOVFF  321,32A
4D2C:  MOVFF  320,329
4D30:  BRA    4C14
....................          pKey=ptr+1; 
4D32:  MOVLW  01
4D34:  MOVLB  3
4D36:  ADDWF  x1C,W
4D38:  MOVWF  x1E
4D3A:  MOVLW  00
4D3C:  ADDWFC x1D,W
4D3E:  MOVWF  x1F
....................          pValue=0; 
4D40:  CLRF   x21
4D42:  CLRF   x20
....................          if (c==0) 
4D44:  MOVF   x22,F
4D46:  BNZ   4D4A
....................             break; 
4D48:  BRA    4D70
....................       } 
....................       else if (c=='=') 
4D4A:  BRA    4D68
4D4C:  MOVF   x22,W
4D4E:  SUBLW  3D
4D50:  BNZ   4D68
....................       { 
....................          *ptr=0; 
4D52:  MOVFF  31C,FE9
4D56:  MOVFF  31D,FEA
4D5A:  CLRF   FEF
....................          pValue=ptr+1; 
4D5C:  MOVLW  01
4D5E:  ADDWF  x1C,W
4D60:  MOVWF  x20
4D62:  MOVLW  00
4D64:  ADDWFC x1D,W
4D66:  MOVWF  x21
....................       } 
....................       ptr++; 
4D68:  INCF   x1C,F
4D6A:  BTFSC  FD8.2
4D6C:  INCF   x1D,F
....................    } 
4D6E:  BRA    4CDA
.................... } 
4D70:  MOVLB  0
4D72:  RETLW  00
....................  
.................... int8 _httpPutcSocket; 
....................  
.................... #define tcp_http_tx_left()  TCPPutAvailable(_httpPutcSocket) 
....................  
.................... void set_tcp_http_putc(int8 newSocket) 
.................... { 
....................    _httpPutcSocket=newSocket; 
*
5058:  MOVFF  320,122
.................... } 
505C:  GOTO   59FE (RETURN)
....................  
.................... int tcp_http_putc(char c) 
.................... { 
....................    return(TCPPut(_httpPutcSocket,c)); 
*
5374:  MOVFF  122,33F
5378:  MOVFF  33E,340
537C:  BRA    522A
537E:  MOVF   01,W
.................... } 
5380:  RETLW  00
....................  
.................... int32 lastHTTPPutConstPos[HTTP_NUM_SOCKETS]; 
.................... char * lastHTTPPutVarPos[HTTP_NUM_SOCKETS]; 
....................  
.................... #if HTTP_USE_CHUNKS 
.................... void TCPPutFileChunkStart(int16 count) 
.................... { 
....................    printf(tcp_http_putc, "%04LX\r\n", count); 
.................... } 
....................  
.................... void TCPPutFileChunkStop(void) 
.................... { 
....................    tcp_http_putc('\r'); 
....................    tcp_http_putc('\n'); 
.................... } 
.................... #else 
....................  #define TCPPutFileChunkStart(x) 
....................  #define TCPPutFileChunkStop() 
.................... #endif 
....................  
.................... typedef enum 
.................... { 
....................    TCP_PUT_CONST_EC_FINISH = 0, 
....................    TCP_PUT_CONST_EC_CONTINUE, 
....................    TCP_PUT_CONST_EC_ESCAPE 
.................... } TCP_PUT_CONST_EC; 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // TCPPutFileVarChunk(ptr) 
.................... // 
.................... // send a chunked response from ram 
.................... // 
.................... // ptr - data to send (well be sent as an http/1.1 chunk).  It will be updated 
.................... //          with the continue position before exit. 
.................... // 
.................... // Returns a status code: 
.................... //    TCP_PUT_CONST_EC_FINISH - The whole chunk was completed 
.................... //    TCP_PUT_CONST_EC_CONTINUE - The chunk needs to be continued 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //TCP_PUT_CONST_EC TCPPutFileVarChunk(char **retPtr) 
.................... //because of a compiler error i had to make this double pointer an int16, when 
.................... //it should be a char. 
.................... TCP_PUT_CONST_EC TCPPutFileVarChunk(int16 **retPtr) 
.................... { 
....................    int16 txLeft, n; 
....................    char *ptr, ec; 
....................  
....................    ptr=*retPtr; 
*
553C:  MOVLB  3
553E:  MOVFF  322,FE9
5542:  MOVFF  323,FEA
5546:  MOVFF  FEC,03
554A:  MOVF   FED,F
554C:  MOVFF  FEF,328
5550:  MOVFF  03,329
....................  
....................    n=strlen(ptr); 
5554:  MOVFF  329,33F
5558:  MOVFF  328,33E
555C:  MOVLB  0
555E:  CALL   46A0
5562:  MOVFF  02,327
5566:  MOVFF  01,326
....................  
....................    if (!n) 
556A:  MOVLB  3
556C:  MOVF   x26,W
556E:  IORWF  x27,W
5570:  BNZ   5578
....................       return(TCP_PUT_CONST_EC_FINISH); 
5572:  MOVLW  00
5574:  MOVWF  01
5576:  BRA    55FC
....................  
....................    txLeft = tcp_http_tx_left(); 
5578:  MOVFF  122,32E
557C:  MOVLB  0
557E:  RCALL  5440
5580:  MOVFF  02,325
5584:  MOVFF  01,324
....................  
....................   #if HTTP_USE_CHUNKS 
....................    if (txLeft > 8) 
....................       txLeft -= 8;   //save space for 2x CRLF and 4 chars 
....................    else 
....................       return(TCP_PUT_CONST_EC_CONTINUE); 
....................   #else 
....................    if (!txLeft) 
5588:  MOVLB  3
558A:  MOVF   x24,W
558C:  IORWF  x25,W
558E:  BNZ   5596
....................       return(TCP_PUT_CONST_EC_CONTINUE); 
5590:  MOVLW  01
5592:  MOVWF  01
5594:  BRA    55FC
....................   #endif 
....................  
....................    if (n > txLeft) 
5596:  MOVF   x25,W
5598:  SUBWF  x27,W
559A:  BNC   55AA
559C:  BNZ   55A4
559E:  MOVF   x26,W
55A0:  SUBWF  x24,W
55A2:  BC    55AA
....................    { 
....................       ec = TCP_PUT_CONST_EC_CONTINUE; 
55A4:  MOVLW  01
55A6:  MOVWF  x2A
....................    } 
....................    else 
55A8:  BRA    55B4
....................    { 
....................       txLeft = n; 
55AA:  MOVFF  327,325
55AE:  MOVFF  326,324
....................       ec = TCP_PUT_CONST_EC_FINISH; 
55B2:  CLRF   x2A
....................    } 
....................  
....................    TCPPutFileChunkStart(txLeft); 
....................  
....................    while (txLeft--) 
....................    { 
55B4:  MOVFF  325,03
55B8:  MOVF   x24,W
55BA:  BTFSC  FD8.2
55BC:  DECF   x25,F
55BE:  DECF   x24,F
55C0:  IORWF  03,W
55C2:  BZ    55E6
....................       tcp_http_putc(*ptr++); 
55C4:  MOVFF  329,03
55C8:  MOVF   x28,W
55CA:  INCF   x28,F
55CC:  BTFSC  FD8.2
55CE:  INCF   x29,F
55D0:  MOVWF  FE9
55D2:  MOVFF  03,FEA
55D6:  MOVFF  FEF,32B
55DA:  MOVFF  32B,33E
55DE:  MOVLB  0
55E0:  RCALL  5374
....................    } 
55E2:  MOVLB  3
55E4:  BRA    55B4
....................  
....................    TCPPutFileChunkStop(); 
....................  
....................    *retPtr=ptr; 
55E6:  MOVFF  322,FE9
55EA:  MOVFF  323,FEA
55EE:  MOVFF  329,FEC
55F2:  MOVF   FED,F
55F4:  MOVFF  328,FEF
....................  
....................    return(ec); 
55F8:  MOVFF  32A,01
.................... } 
55FC:  MOVLB  0
55FE:  RETLW  00
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // TCPPutFileParseConst(addy, n, doSend) 
.................... // 
.................... // Reads file from Const memory.  Stops when it reaches an escape sequence, 
.................... // n chars or an end of file 
.................... // 
.................... // addy - data to read (well be sent as an http/1.1 chunk).  This address 
.................... //        will be updated for the next call. 
.................... // 
.................... // n - max number of chars to read from file.  will save the total number 
.................... //    of chars passed to this pointer. 
.................... // 
.................... // doSend - if TRUE, then send data to TCP socket 
.................... // 
.................... // returns the last char read 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... char TCPPutFileParseConst(int32 *retAddy, int16 *n, int8 doSend) 
.................... { 
....................    char stopC, checkC; 
....................    int16 fileSize = 0, max; 
*
561E:  MOVLB  3
5620:  CLRF   x35
5622:  CLRF   x36
....................    int32 addy; 
....................    int1 premature = TRUE; 
5624:  BSF    x3D.0
....................  
....................    max = *n; 
5626:  MOVFF  330,FE9
562A:  MOVFF  331,FEA
562E:  MOVFF  FEC,03
5632:  MOVF   FED,F
5634:  MOVFF  FEF,337
5638:  MOVFF  03,338
....................    addy = *retAddy; 
563C:  MOVFF  32E,FE9
5640:  MOVFF  32F,FEA
5644:  MOVFF  FEF,00
5648:  MOVFF  FEC,01
564C:  MOVFF  FEC,02
5650:  MOVFF  FEC,03
5654:  MOVFF  03,33C
5658:  MOVFF  02,33B
565C:  MOVFF  01,33A
5660:  MOVFF  00,339
....................  
....................    while (TRUE) 
....................    { 
....................       read_program_memory(addy++, &stopC, 1); 
5664:  MOVFF  33C,03
5668:  MOVFF  33B,02
566C:  MOVFF  33A,01
5670:  MOVFF  339,00
5674:  MOVLW  01
5676:  ADDWF  x39,F
5678:  BTFSC  FD8.0
567A:  INCF   x3A,F
567C:  BTFSC  FD8.2
567E:  INCF   x3B,F
5680:  BTFSC  FD8.2
5682:  INCF   x3C,F
5684:  MOVFF  03,341
5688:  MOVFF  02,340
568C:  MOVFF  01,33F
5690:  MOVFF  00,33E
5694:  MOVFF  02,FF8
5698:  MOVFF  01,FF7
569C:  MOVFF  00,FF6
56A0:  MOVLW  03
56A2:  MOVWF  FEA
56A4:  MOVLW  33
56A6:  MOVWF  FE9
56A8:  CLRF   x43
56AA:  MOVLW  01
56AC:  MOVWF  x42
56AE:  MOVLB  0
56B0:  RCALL  5600
....................       if (stopC == '%') 
56B2:  MOVLB  3
56B4:  MOVF   x33,W
56B6:  SUBLW  25
56B8:  BNZ   573C
....................       { 
....................          read_program_memory(addy++, &checkC, 1); 
56BA:  MOVFF  33C,03
56BE:  MOVFF  33B,02
56C2:  MOVFF  33A,01
56C6:  MOVFF  339,00
56CA:  MOVLW  01
56CC:  ADDWF  x39,F
56CE:  BTFSC  FD8.0
56D0:  INCF   x3A,F
56D2:  BTFSC  FD8.2
56D4:  INCF   x3B,F
56D6:  BTFSC  FD8.2
56D8:  INCF   x3C,F
56DA:  MOVFF  03,341
56DE:  MOVFF  02,340
56E2:  MOVFF  01,33F
56E6:  MOVFF  00,33E
56EA:  MOVFF  02,FF8
56EE:  MOVFF  01,FF7
56F2:  MOVFF  00,FF6
56F6:  MOVLW  03
56F8:  MOVWF  FEA
56FA:  MOVLW  34
56FC:  MOVWF  FE9
56FE:  CLRF   x43
5700:  MOVLW  01
5702:  MOVWF  x42
5704:  MOVLB  0
5706:  RCALL  5600
....................          if (checkC == '%') 
5708:  MOVLB  3
570A:  MOVF   x34,W
570C:  SUBLW  25
570E:  BNZ   5738
....................          { 
....................             if (fileSize < max) 
5710:  MOVF   x36,W
5712:  SUBWF  x38,W
5714:  BNC   5734
5716:  BNZ   571E
5718:  MOVF   x37,W
571A:  SUBWF  x35,W
571C:  BC    5734
....................             { 
....................                if (doSend) 
571E:  MOVF   x32,F
5720:  BZ    572C
....................                   tcp_http_putc('%'); 
5722:  MOVLW  25
5724:  MOVWF  x3E
5726:  MOVLB  0
5728:  RCALL  5374
572A:  MOVLB  3
....................                fileSize++; 
572C:  INCF   x35,F
572E:  BTFSC  FD8.2
5730:  INCF   x36,F
....................             } 
....................             else 
5732:  BRA    5736
....................                break; 
5734:  BRA    576E
....................          } 
....................          else 
5736:  BRA    573A
....................             break;   //ESCAPE 
5738:  BRA    576E
....................       } 
....................       else if (stopC) 
573A:  BRA    576C
573C:  MOVF   x33,F
573E:  BZ    5768
....................       { 
....................          if (fileSize < max) 
5740:  MOVF   x36,W
5742:  SUBWF  x38,W
5744:  BNC   5764
5746:  BNZ   574E
5748:  MOVF   x37,W
574A:  SUBWF  x35,W
574C:  BC    5764
....................          { 
....................             if (doSend) 
574E:  MOVF   x32,F
5750:  BZ    575C
....................                tcp_http_putc(stopC); 
5752:  MOVFF  333,33E
5756:  MOVLB  0
5758:  RCALL  5374
575A:  MOVLB  3
....................             fileSize++; 
575C:  INCF   x35,F
575E:  BTFSC  FD8.2
5760:  INCF   x36,F
....................          } 
....................          else 
5762:  BRA    5766
....................             break; 
5764:  BRA    576E
....................       } 
....................       else 
5766:  BRA    576C
....................       { 
....................          premature = FALSE; 
5768:  BCF    x3D.0
....................          break;   //EOF (stopC == 0) 
576A:  BRA    576E
....................       } 
....................    } 
576C:  BRA    5664
....................  
....................    if (premature) 
576E:  BTFSS  x3D.0
5770:  BRA    5782
....................       addy--; 
5772:  MOVLW  FF
5774:  ADDWF  x39,F
5776:  BTFSS  FD8.0
5778:  ADDWF  x3A,F
577A:  BTFSS  FD8.0
577C:  ADDWF  x3B,F
577E:  BTFSS  FD8.0
5780:  ADDWF  x3C,F
....................  
....................    *n = fileSize; 
5782:  MOVFF  330,FE9
5786:  MOVFF  331,FEA
578A:  MOVFF  336,FEC
578E:  MOVF   FED,F
5790:  MOVFF  335,FEF
....................    *retAddy = addy; 
5794:  MOVFF  32E,FE9
5798:  MOVFF  32F,FEA
579C:  MOVFF  339,FEF
57A0:  MOVFF  33A,FEC
57A4:  MOVFF  33B,FEC
57A8:  MOVFF  33C,FEC
....................  
....................    return(stopC); 
57AC:  MOVFF  333,01
.................... } 
57B0:  MOVLB  0
57B2:  RETLW  00
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // TCPPutFileConstChunk(*addy) 
.................... // 
.................... // send a chunked response from constant memory 
.................... // 
.................... // addy - data to send (well be sent as an http/1.1 chunk).  This address 
.................... //        will be updated for the next call. 
.................... // 
.................... // returns a response: 
.................... //    TCP_PUT_CONST_EC_CONTINUE: we ran out of space to put more data, continue 
.................... //                            from this position on next call. 
.................... //    TCP_PUT_CONST_EC_ESCAPE:   an escape character 
.................... //    TCP_PUT_CONST_EC_FINISH:   we finished reading the chunk, end of file. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... TCP_PUT_CONST_EC TCPPutFileConstChunk(int32 *retAddy) 
.................... { 
....................    char stopC; 
....................    int32 addy; 
....................    int16 fileSize = 0, txLeft; 
57B4:  MOVLB  3
57B6:  CLRF   x29
57B8:  CLRF   x2A
....................    TCP_PUT_CONST_EC ec; 
....................  
....................    txLeft = tcp_http_tx_left(); 
57BA:  MOVFF  122,32E
57BE:  MOVLB  0
57C0:  RCALL  5440
57C2:  MOVFF  02,32C
57C6:  MOVFF  01,32B
....................  
....................  #if HTTP_USE_CHUNKS 
....................    if (txLeft > 8) 
....................       txLeft -= 8;   //save space for 2x CRLF and 4 chars 
....................    else 
....................       return(TCP_PUT_CONST_EC_CONTINUE); 
....................  #else 
....................    if (!txLeft) 
57CA:  MOVLB  3
57CC:  MOVF   x2B,W
57CE:  IORWF  x2C,W
57D0:  BNZ   57D8
....................       return(TCP_PUT_CONST_EC_CONTINUE); 
57D2:  MOVLW  01
57D4:  MOVWF  01
57D6:  BRA    5886
....................  #endif 
....................  
....................    addy = *retAddy; 
57D8:  MOVFF  322,FE9
57DC:  MOVFF  323,FEA
57E0:  MOVFF  FEF,00
57E4:  MOVFF  FEC,01
57E8:  MOVFF  FEC,02
57EC:  MOVFF  FEC,03
57F0:  MOVFF  03,328
57F4:  MOVFF  02,327
57F8:  MOVFF  01,326
57FC:  MOVFF  00,325
....................  
....................    fileSize = 0xFFFF; 
5800:  MOVLW  FF
5802:  MOVWF  x2A
5804:  MOVWF  x29
....................    stopC = TCPPutFileParseConst(&addy, &fileSize, FALSE); 
5806:  MOVLW  03
5808:  MOVWF  x2F
580A:  MOVLW  25
580C:  MOVWF  x2E
580E:  MOVLW  03
5810:  MOVWF  x31
5812:  MOVLW  29
5814:  MOVWF  x30
5816:  CLRF   x32
5818:  MOVLB  0
581A:  RCALL  561E
581C:  MOVFF  01,324
....................  
....................    if (!fileSize && (stopC!='%')) 
5820:  MOVLB  3
5822:  MOVF   x29,W
5824:  IORWF  x2A,W
5826:  BNZ   5834
5828:  MOVF   x24,W
582A:  SUBLW  25
582C:  BZ    5834
....................       return(TCP_PUT_CONST_EC_FINISH); 
582E:  MOVLW  00
5830:  MOVWF  01
5832:  BRA    5886
....................  
....................    //TODO: optimize 
....................    if (fileSize > txLeft) 
5834:  MOVF   x2C,W
5836:  SUBWF  x2A,W
5838:  BNC   5850
583A:  BNZ   5842
583C:  MOVF   x29,W
583E:  SUBWF  x2B,W
5840:  BC    5850
....................    { 
....................       fileSize = txLeft; 
5842:  MOVFF  32C,32A
5846:  MOVFF  32B,329
.................... //      if (stopC == '%') 
.................... //         ec = TCP_PUT_CONST_EC_ESCAPE; 
.................... //      else 
....................          ec = TCP_PUT_CONST_EC_CONTINUE; 
584A:  MOVLW  01
584C:  MOVWF  x2D
....................    } 
....................    else 
584E:  BRA    5868
....................    { 
....................       if (stopC == '%') 
5850:  MOVF   x24,W
5852:  SUBLW  25
5854:  BNZ   585C
....................          ec = TCP_PUT_CONST_EC_ESCAPE; 
5856:  MOVLW  02
5858:  MOVWF  x2D
....................       else if (stopC) 
585A:  BRA    5868
585C:  MOVF   x24,F
585E:  BZ    5866
....................          ec = TCP_PUT_CONST_EC_CONTINUE; 
5860:  MOVLW  01
5862:  MOVWF  x2D
....................       else 
5864:  BRA    5868
....................          ec = TCP_PUT_CONST_EC_FINISH; 
5866:  CLRF   x2D
....................    } 
....................  
....................    TCPPutFileChunkStart(fileSize); 
....................  
....................    TCPPutFileParseConst(retAddy, &fileSize, TRUE); 
5868:  MOVFF  323,32F
586C:  MOVFF  322,32E
5870:  MOVLW  03
5872:  MOVWF  x31
5874:  MOVLW  29
5876:  MOVWF  x30
5878:  MOVLW  01
587A:  MOVWF  x32
587C:  MOVLB  0
587E:  RCALL  561E
....................  
....................    TCPPutFileChunkStop(); 
....................  
....................    return(ec); 
5880:  MOVLB  3
5882:  MOVFF  32D,01
.................... } 
5886:  MOVLB  0
5888:  GOTO   5C58 (RETURN)
....................  
.................... int TCPPutFileConstGetEscape(int32 addy) 
.................... { 
.................... #if HTTP_USE_DOUBLE_ESCAPE 
....................    char str[3]; 
....................    int ret; 
....................  
....................    read_program_memory(addy, &str[0], 2); 
....................    str[2] = 0; 
....................    ret = strtol(str, 0, 16); 
.................... #else 
....................    char ret; 
....................    read_program_memory(addy, &ret, 1); 
588C:  MOVFF  326,FF8
5890:  MOVFF  325,FF7
5894:  MOVFF  324,FF6
5898:  MOVLW  03
589A:  MOVWF  FEA
589C:  MOVLW  28
589E:  MOVWF  FE9
58A0:  MOVLB  3
58A2:  CLRF   x43
58A4:  MOVLW  01
58A6:  MOVWF  x42
58A8:  MOVLB  0
58AA:  RCALL  5600
.................... #endif 
....................  
....................    return(ret); 
58AC:  MOVLB  3
58AE:  MOVFF  328,01
.................... } 
58B2:  MOVLB  0
58B4:  GOTO   5C9C (RETURN)
....................  
.................... int1 tcp_http_put_file(int8 which, int16 errorCode, int32 file, char *contentType) 
.................... { 
....................    static char str[40]; 
....................    int8 socket; 
....................    char ec; 
....................    int escaped; 
....................  
....................    static enum 
....................    { 
....................       HTTP_PUT_FILE_INIT = 0, 
....................       HTTP_PUT_FILE_CONTINUE, 
....................       HTTP_PUT_FILE_CHUNK_END, 
....................       HTTP_PUT_FILE_DONE 
....................    } status; 
....................  
....................    socket=http_socket[which]; 
*
59E0:  CLRF   03
59E2:  MOVLB  3
59E4:  MOVF   x14,W
59E6:  ADDLW  1F
59E8:  MOVWF  FE9
59EA:  MOVLW  01
59EC:  ADDWFC 03,W
59EE:  MOVWF  FEA
59F0:  MOVFF  FEF,31D
....................  
....................    set_tcp_http_putc(socket); 
59F4:  MOVFF  31D,320
59F8:  MOVLB  0
59FA:  GOTO   5058
....................  
....................    if (lastHTTPPutConstPos[which] == 0) 
59FE:  MOVLB  3
5A00:  MOVF   x14,W
5A02:  MULLW  04
5A04:  MOVF   FF3,W
5A06:  CLRF   03
5A08:  ADDLW  23
5A0A:  MOVWF  FE9
5A0C:  MOVLW  01
5A0E:  ADDWFC 03,W
5A10:  MOVWF  FEA
5A12:  MOVFF  FEF,320
5A16:  MOVFF  FEC,321
5A1A:  MOVFF  FEC,322
5A1E:  MOVFF  FEC,323
5A22:  MOVF   x20,F
5A24:  BTFSS  FD8.2
5A26:  BRA    5BE6
5A28:  MOVF   x21,F
5A2A:  BTFSS  FD8.2
5A2C:  BRA    5BE6
5A2E:  MOVF   x22,F
5A30:  BTFSS  FD8.2
5A32:  BRA    5BE6
5A34:  MOVF   x23,F
5A36:  BTFSS  FD8.2
5A38:  BRA    5BE6
....................    { 
....................       lastHTTPPutVarPos[which] = 0; 
5A3A:  BCF    FD8.0
5A3C:  RLCF   x14,W
5A3E:  CLRF   03
5A40:  ADDLW  27
5A42:  MOVWF  FE9
5A44:  MOVLW  01
5A46:  ADDWFC 03,W
5A48:  MOVWF  FEA
5A4A:  CLRF   FEC
5A4C:  MOVF   FED,F
5A4E:  CLRF   FEF
....................       lastHTTPPutConstPos[which] = file; 
5A50:  MOVF   x14,W
5A52:  MULLW  04
5A54:  MOVF   FF3,W
5A56:  CLRF   03
5A58:  ADDLW  23
5A5A:  MOVWF  FE9
5A5C:  MOVLW  01
5A5E:  ADDWFC 03,W
5A60:  MOVWF  FEA
5A62:  MOVFF  317,FEF
5A66:  MOVFF  318,FEC
5A6A:  MOVFF  319,FEC
5A6E:  MOVFF  31A,FEC
....................       status = HTTP_PUT_FILE_CONTINUE; 
5A72:  MOVLW  01
5A74:  MOVLB  1
5A76:  MOVWF  x51
....................  
....................     #if HTTP_USE_CHUNKS 
....................       printf(tcp_http_putc,"HTTP/1.1 %LU ", errorCode); 
....................     #else 
....................       printf(tcp_http_putc,"HTTP/1.0 %LU ", errorCode); 
5A78:  MOVLB  3
5A7A:  CLRF   x20
5A7C:  MOVF   x20,W
5A7E:  MOVLB  0
5A80:  CALL   009E
5A84:  MOVLB  3
5A86:  INCF   x20,F
5A88:  MOVWF  00
5A8A:  MOVWF  x3E
5A8C:  MOVLB  0
5A8E:  RCALL  5374
5A90:  MOVLW  09
5A92:  MOVLB  3
5A94:  SUBWF  x20,W
5A96:  BNZ   5A7C
5A98:  MOVLW  10
5A9A:  MOVWF  FE9
5A9C:  MOVFF  316,322
5AA0:  MOVFF  315,321
5AA4:  MOVLB  0
5AA6:  BRA    5382
5AA8:  MOVLW  20
5AAA:  MOVLB  3
5AAC:  MOVWF  x3E
5AAE:  MOVLB  0
5AB0:  RCALL  5374
....................     #endif 
....................  
....................       switch(errorCode) 
....................       { 
5AB2:  MOVLB  3
5AB4:  MOVFF  315,00
5AB8:  MOVF   x16,W
5ABA:  MOVWF  03
5ABC:  BNZ   5AC8
5ABE:  MOVLW  C8
5AC0:  SUBWF  00,W
5AC2:  MOVLB  0
5AC4:  BZ    5AEA
5AC6:  MOVLB  3
5AC8:  MOVLW  01
5ACA:  SUBWF  03,W
5ACC:  BNZ   5AD8
5ACE:  MOVLW  94
5AD0:  SUBWF  00,W
5AD2:  MOVLB  0
5AD4:  BZ    5B00
5AD6:  MOVLB  3
5AD8:  MOVLW  01
5ADA:  SUBWF  03,W
5ADC:  BNZ   5AE8
5ADE:  MOVLW  F4
5AE0:  SUBWF  00,W
5AE2:  MOVLB  0
5AE4:  BZ    5B24
5AE6:  MOVLB  3
5AE8:  BRA    5B48
....................          case 200: 
....................             printf(tcp_http_putc,"OK"); 
5AEA:  MOVLW  4F
5AEC:  MOVLB  3
5AEE:  MOVWF  x3E
5AF0:  MOVLB  0
5AF2:  RCALL  5374
5AF4:  MOVLW  4B
5AF6:  MOVLB  3
5AF8:  MOVWF  x3E
5AFA:  MOVLB  0
5AFC:  RCALL  5374
....................             break; 
5AFE:  BRA    5B4C
....................          case 404: 
....................             printf(tcp_http_putc,"Not found"); 
5B00:  MOVLB  3
5B02:  CLRF   x20
5B04:  MOVF   x20,W
5B06:  MOVLB  0
5B08:  CALL   00C6
5B0C:  MOVLB  3
5B0E:  INCF   x20,F
5B10:  MOVWF  00
5B12:  MOVWF  x3E
5B14:  MOVLB  0
5B16:  RCALL  5374
5B18:  MOVLW  09
5B1A:  MOVLB  3
5B1C:  SUBWF  x20,W
5B1E:  BNZ   5B04
....................             break; 
5B20:  MOVLB  0
5B22:  BRA    5B4C
....................          case 500: 
....................             printf(tcp_http_putc,"Server Error"); 
5B24:  MOVLB  3
5B26:  CLRF   x20
5B28:  MOVF   x20,W
5B2A:  MOVLB  0
5B2C:  CALL   00EA
5B30:  MOVLB  3
5B32:  INCF   x20,F
5B34:  MOVWF  00
5B36:  MOVWF  x3E
5B38:  MOVLB  0
5B3A:  RCALL  5374
5B3C:  MOVLW  0C
5B3E:  MOVLB  3
5B40:  SUBWF  x20,W
5B42:  BNZ   5B28
....................             break; 
5B44:  MOVLB  0
5B46:  BRA    5B4C
....................          default: 
....................             break; 
5B48:  MOVLB  0
5B4A:  BRA    5B4C
....................       } 
....................  
....................       printf(tcp_http_putc, "\r\nContent-Type: "); 
5B4C:  MOVLB  3
5B4E:  CLRF   x20
5B50:  MOVF   x20,W
5B52:  MOVLB  0
5B54:  CALL   0112
5B58:  MOVLB  3
5B5A:  INCF   x20,F
5B5C:  MOVWF  00
5B5E:  MOVWF  x3E
5B60:  MOVLB  0
5B62:  RCALL  5374
5B64:  MOVLW  10
5B66:  MOVLB  3
5B68:  SUBWF  x20,W
5B6A:  BNZ   5B50
....................       if (contentType) 
5B6C:  MOVF   x1B,W
5B6E:  IORWF  x1C,W
5B70:  BZ    5BA6
....................          printf(tcp_http_putc, "%s", contentType); 
5B72:  MOVFF  31C,FEA
5B76:  MOVFF  31B,FE9
5B7A:  MOVLW  00
5B7C:  IORWF  FEF,W
5B7E:  BZ    5BA4
5B80:  MOVFF  FEA,321
5B84:  MOVFF  FE9,320
5B88:  MOVFF  FEF,33E
5B8C:  MOVLB  0
5B8E:  CALL   5374
5B92:  MOVFF  321,FEA
5B96:  MOVFF  320,FE9
5B9A:  INCF   FE9,F
5B9C:  BTFSC  FD8.2
5B9E:  INCF   FEA,F
5BA0:  MOVLB  3
5BA2:  BRA    5B7A
....................       else 
5BA4:  BRA    5BC6
....................          printf(tcp_http_putc,"text/html"); 
5BA6:  CLRF   x20
5BA8:  MOVF   x20,W
5BAA:  MOVLB  0
5BAC:  CALL   013E
5BB0:  MOVLB  3
5BB2:  INCF   x20,F
5BB4:  MOVWF  00
5BB6:  MOVWF  x3E
5BB8:  MOVLB  0
5BBA:  CALL   5374
5BBE:  MOVLW  09
5BC0:  MOVLB  3
5BC2:  SUBWF  x20,W
5BC4:  BNZ   5BA8
....................  
....................     #if HTTP_USE_CHUNKS 
....................       printf(tcp_http_putc, "\r\nConnection: close"); 
....................       printf(tcp_http_putc, "\r\nTransfer-Encoding: chunked"); 
....................     #endif 
....................  
....................       printf(tcp_http_putc, "\r\n\r\n"); 
5BC6:  CLRF   x20
5BC8:  MOVF   x20,W
5BCA:  MOVLB  0
5BCC:  CALL   0162
5BD0:  MOVLB  3
5BD2:  INCF   x20,F
5BD4:  MOVWF  00
5BD6:  MOVWF  x3E
5BD8:  MOVLB  0
5BDA:  CALL   5374
5BDE:  MOVLW  04
5BE0:  MOVLB  3
5BE2:  SUBWF  x20,W
5BE4:  BNZ   5BC8
....................    } 
....................  
....................    if (lastHTTPPutVarPos[which]) 
5BE6:  BCF    FD8.0
5BE8:  RLCF   x14,W
5BEA:  CLRF   03
5BEC:  ADDLW  27
5BEE:  MOVWF  FE9
5BF0:  MOVLW  01
5BF2:  ADDWFC 03,W
5BF4:  MOVWF  FEA
5BF6:  MOVF   FEF,F
5BF8:  BZ    5C2C
....................    { 
....................       TCPPutFileVarChunk(&lastHTTPPutVarPos[which]); 
5BFA:  BCF    FD8.0
5BFC:  RLCF   x14,W
5BFE:  CLRF   03
5C00:  ADDLW  27
5C02:  MOVWF  x20
5C04:  MOVLW  01
5C06:  ADDWFC 03,W
5C08:  MOVWF  x21
5C0A:  MOVWF  x23
5C0C:  MOVFF  320,322
5C10:  MOVLB  0
5C12:  RCALL  553C
....................       lastHTTPPutVarPos[which] = 0; 
5C14:  BCF    FD8.0
5C16:  MOVLB  3
5C18:  RLCF   x14,W
5C1A:  CLRF   03
5C1C:  ADDLW  27
5C1E:  MOVWF  FE9
5C20:  MOVLW  01
5C22:  ADDWFC 03,W
5C24:  MOVWF  FEA
5C26:  CLRF   FEC
5C28:  MOVF   FED,F
5C2A:  CLRF   FEF
....................    } 
....................  
....................    if (status == HTTP_PUT_FILE_CONTINUE) 
5C2C:  MOVLB  1
5C2E:  DECFSZ x51,W
5C30:  BRA    5D70
....................    { 
....................       do { 
....................          ec = TCPPutFileConstChunk(&lastHTTPPutConstPos[which]); 
5C32:  MOVLB  3
5C34:  MOVF   x14,W
5C36:  MULLW  04
5C38:  MOVF   FF3,W
5C3A:  CLRF   03
5C3C:  ADDLW  23
5C3E:  MOVWF  01
5C40:  MOVLW  01
5C42:  ADDWFC 03,F
5C44:  MOVFF  01,320
5C48:  MOVFF  03,321
5C4C:  MOVFF  03,323
5C50:  MOVFF  01,322
5C54:  MOVLB  0
5C56:  BRA    57B4
5C58:  MOVFF  01,31E
....................  
....................          if (ec == TCP_PUT_CONST_EC_ESCAPE) 
5C5C:  MOVLB  3
5C5E:  MOVF   x1E,W
5C60:  SUBLW  02
5C62:  BTFSS  FD8.2
5C64:  BRA    5D5E
....................          { 
....................             escaped = TCPPutFileConstGetEscape(lastHTTPPutConstPos[which]); 
5C66:  MOVF   x14,W
5C68:  MULLW  04
5C6A:  MOVF   FF3,W
5C6C:  CLRF   03
5C6E:  ADDLW  23
5C70:  MOVWF  FE9
5C72:  MOVLW  01
5C74:  ADDWFC 03,W
5C76:  MOVWF  FEA
5C78:  MOVFF  FEF,320
5C7C:  MOVFF  FEC,321
5C80:  MOVFF  FEC,322
5C84:  MOVFF  FEC,323
5C88:  MOVFF  323,327
5C8C:  MOVFF  322,326
5C90:  MOVFF  321,325
5C94:  MOVFF  320,324
5C98:  MOVLB  0
5C9A:  BRA    588C
5C9C:  MOVFF  01,31F
....................            #if HTTP_USE_DOUBLE_ESCAPE 
....................             lastHTTPPutConstPos[which] += 2; 
....................            #else 
....................             lastHTTPPutConstPos[which] += 1; 
5CA0:  MOVLB  3
5CA2:  MOVF   x14,W
5CA4:  MULLW  04
5CA6:  MOVF   FF3,W
5CA8:  CLRF   03
5CAA:  ADDLW  23
5CAC:  MOVWF  FE9
5CAE:  MOVLW  01
5CB0:  ADDWFC 03,W
5CB2:  MOVWF  FEA
5CB4:  MOVLW  01
5CB6:  ADDWF  FEF,W
5CB8:  MOVWF  00
5CBA:  MOVLW  00
5CBC:  ADDWFC FEC,W
5CBE:  MOVWF  01
5CC0:  MOVLW  00
5CC2:  ADDWFC FEC,W
5CC4:  MOVWF  02
5CC6:  MOVLW  00
5CC8:  ADDWFC FEC,W
5CCA:  MOVF   FED,F
5CCC:  MOVF   FED,F
5CCE:  MOVF   FED,F
5CD0:  MOVFF  00,FEF
5CD4:  MOVFF  01,FEC
5CD8:  MOVFF  02,FEC
5CDC:  MOVWF  FEC
....................            #endif 
....................             http_format_char(file, escaped, &str[0], sizeof(str)-1); 
5CDE:  MOVFF  31A,323
5CE2:  MOVFF  319,322
5CE6:  MOVFF  318,321
5CEA:  MOVFF  317,320
5CEE:  MOVFF  31F,324
5CF2:  MOVLW  01
5CF4:  MOVWF  x26
5CF6:  MOVLW  29
5CF8:  MOVWF  x25
5CFA:  MOVLW  27
5CFC:  MOVWF  x27
5CFE:  MOVLB  0
5D00:  BRA    5922
....................             lastHTTPPutVarPos[which] = &str[0]; 
5D02:  BCF    FD8.0
5D04:  MOVLB  3
5D06:  RLCF   x14,W
5D08:  CLRF   03
5D0A:  ADDLW  27
5D0C:  MOVWF  FE9
5D0E:  MOVLW  01
5D10:  ADDWFC 03,W
5D12:  MOVWF  FEA
5D14:  MOVLW  01
5D16:  MOVWF  FEC
5D18:  MOVF   FED,F
5D1A:  MOVLW  29
5D1C:  MOVWF  FEF
....................             ec = TCPPutFileVarChunk(&lastHTTPPutVarPos[which]); 
5D1E:  BCF    FD8.0
5D20:  RLCF   x14,W
5D22:  CLRF   03
5D24:  ADDLW  27
5D26:  MOVWF  x20
5D28:  MOVLW  01
5D2A:  ADDWFC 03,W
5D2C:  MOVWF  x21
5D2E:  MOVWF  x23
5D30:  MOVFF  320,322
5D34:  MOVLB  0
5D36:  RCALL  553C
5D38:  MOVFF  01,31E
....................             if (ec == TCP_PUT_CONST_EC_FINISH) 
5D3C:  MOVLB  3
5D3E:  MOVF   x1E,F
5D40:  BNZ   5D5A
....................                lastHTTPPutVarPos[which] = 0; 
5D42:  BCF    FD8.0
5D44:  RLCF   x14,W
5D46:  CLRF   03
5D48:  ADDLW  27
5D4A:  MOVWF  FE9
5D4C:  MOVLW  01
5D4E:  ADDWFC 03,W
5D50:  MOVWF  FEA
5D52:  CLRF   FEC
5D54:  MOVF   FED,F
5D56:  CLRF   FEF
....................             else 
5D58:  BRA    5D5C
....................                break; 
5D5A:  BRA    5D6E
....................          } 
....................          else 
5D5C:  BRA    5D6C
....................          { 
....................             if (ec == TCP_PUT_CONST_EC_FINISH) 
5D5E:  MOVF   x1E,F
5D60:  BNZ   5D6A
....................                status = HTTP_PUT_FILE_CHUNK_END; 
5D62:  MOVLW  02
5D64:  MOVLB  1
5D66:  MOVWF  x51
5D68:  MOVLB  3
....................             break; 
5D6A:  BRA    5D6E
....................          } 
....................       } while (TRUE); 
....................    } 
5D6C:  BRA    5C34
5D6E:  MOVLB  1
....................  
....................    if (status == HTTP_PUT_FILE_CHUNK_END) 
5D70:  MOVF   x51,W
5D72:  SUBLW  02
5D74:  BNZ   5D7A
....................    { 
....................      #if HTTP_USE_CHUNKS 
....................       if (tcp_http_tx_left() > 8) 
....................       { 
....................          TCPPutFileChunkStart(0); 
....................          TCPPutFileChunkStop(); 
....................          status = HTTP_PUT_FILE_DONE; 
....................       } 
....................      #else 
....................       status = HTTP_PUT_FILE_DONE; 
5D76:  MOVLW  03
5D78:  MOVWF  x51
....................      #endif 
....................    } 
....................  
....................  
....................    TCPFlush(socket); 
5D7A:  MOVFF  31D,345
5D7E:  MOVLB  0
5D80:  CALL   5060
....................  
....................    return(status == HTTP_PUT_FILE_DONE); 
5D84:  MOVLB  1
5D86:  MOVF   x51,W
5D88:  SUBLW  03
5D8A:  BZ    5D90
5D8C:  MOVLW  00
5D8E:  BRA    5D92
5D90:  MOVLW  01
5D92:  MOVWF  01
.................... } 
5D94:  MOVLB  0
5D96:  RETLW  00
....................  
.................... //initializes the HTTP state machine.  called automatically by the TCP/IP stack 
.................... void HTTP_Init(void) { 
....................    int8 i; 
....................    debug_http("\r\nHTTP OPENING"); 
....................    if (HTTP_PORT != 0) 
....................    { 
....................       for (i=0;i<HTTP_NUM_SOCKETS;i++) 
*
0FF6:  MOVLB  3
0FF8:  CLRF   x02
0FFA:  MOVF   x02,F
0FFC:  BNZ   105A
....................       { 
....................          http_socket[i]=TCPListen(HTTP_PORT); 
0FFE:  CLRF   03
1000:  MOVF   x02,W
1002:  ADDLW  1F
1004:  MOVWF  01
1006:  MOVLW  01
1008:  ADDWFC 03,F
100A:  MOVFF  01,303
100E:  MOVFF  03,304
1012:  CLRF   x06
1014:  MOVLW  50
1016:  MOVWF  x05
1018:  MOVLB  0
101A:  BRA    0EFA
101C:  MOVFF  304,FEA
1020:  MOVFF  303,FE9
1024:  MOVFF  01,FEF
....................          debug_http("\r\nHTTP SOCKET=%X", http_socket[i]); 
....................          if (http_socket[i]!=INVALID_SOCKET) 
1028:  CLRF   03
102A:  MOVLB  3
102C:  MOVF   x02,W
102E:  ADDLW  1F
1030:  MOVWF  FE9
1032:  MOVLW  01
1034:  ADDWFC 03,W
1036:  MOVWF  FEA
1038:  MOVF   FEF,W
103A:  SUBLW  FE
103C:  BZ    1056
....................          { 
....................             http_state[i]=HTTP_LISTEN_WAIT; 
103E:  BCF    FD8.0
1040:  RLCF   x02,W
1042:  CLRF   03
1044:  ADDLW  20
1046:  MOVWF  FE9
1048:  MOVLW  01
104A:  ADDWFC 03,W
104C:  MOVWF  FEA
104E:  MOVLW  01
1050:  MOVWF  FEC
1052:  MOVF   FED,F
1054:  MOVWF  FEF
....................          } 
....................       } 
1056:  INCF   x02,F
1058:  BRA    0FFA
....................    } 
....................    else 
....................    { 
....................       debug_http("\r\nHTTP DISABLED"); 
....................       for (i=0;i<HTTP_NUM_SOCKETS;i++) 
....................       { 
....................             http_state[i]=HTTP_DISABLED; 
....................       } 
....................    } 
.................... } 
105A:  MOVLB  0
105C:  GOTO   1072 (RETURN)
....................  
.................... void HTTP_Task(void) { 
....................    static char tokens_header[]=" "; 
....................    static char tokens_get[]="?"; 
....................    static char http_get_str[]="GET"; 
....................    static char http_post_str[]="POST"; 
....................    static char http_len_str[]="Content-Length:"; 
....................    //static char http_keepalive_str[]="keep-alive"; 
....................    //static char http_connection_str[]="Connection"; 
....................  
....................    static char buffer[HTTP_NUM_SOCKETS][HTTP_GET_PARAM_MAX_SIZE]; 
....................  
....................    static int8 i[HTTP_NUM_SOCKETS]; 
....................    static enum {HTTP_REQ_GET=1, HTTP_REQ_POST=2, HTTP_REQ_UNKOWN=0} http_cmd[HTTP_NUM_SOCKETS]={0}; 
....................    static int32 http_page_req[HTTP_NUM_SOCKETS]; 
....................    static int16 http_post_len[HTTP_NUM_SOCKETS]={0}; 
....................    static int16 http_timer[HTTP_NUM_SOCKETS]; 
....................  #if HTTP_USE_CONTENT_TYPE 
....................    static char contentType[HTTP_NUM_SOCKETS][12]; 
....................  #endif 
....................  
....................    int1 doneSend, postContinue; 
....................  
....................    char c, *pKey, *pValue; 
....................    int8 hs, currSocket; 
....................  
....................    for (hs=0; hs<HTTP_NUM_SOCKETS; hs++) 
*
5EDA:  MOVLB  3
5EDC:  CLRF   x0E
5EDE:  MOVF   x0E,F
5EE0:  BTFSS  FD8.2
5EE2:  GOTO   6B40
....................    { 
....................       if (http_state[hs]==HTTP_DISABLED) 
5EE6:  BCF    FD8.0
5EE8:  RLCF   x0E,W
5EEA:  CLRF   03
5EEC:  ADDLW  20
5EEE:  MOVWF  FE9
5EF0:  MOVLW  01
5EF2:  ADDWFC 03,W
5EF4:  MOVWF  FEA
5EF6:  MOVFF  FEC,311
5EFA:  MOVF   FED,F
5EFC:  MOVFF  FEF,310
5F00:  INCFSZ x10,W
5F02:  BRA    5F0C
5F04:  MOVF   x11,F
5F06:  BNZ   5F0C
....................          return; 
5F08:  GOTO   6B40
....................  
....................       currSocket=http_socket[hs]; 
5F0C:  CLRF   03
5F0E:  MOVF   x0E,W
5F10:  ADDLW  1F
5F12:  MOVWF  FE9
5F14:  MOVLW  01
5F16:  ADDWFC 03,W
5F18:  MOVWF  FEA
5F1A:  MOVFF  FEF,30F
....................  
....................       if (!TCPIsConnected(currSocket)) 
5F1E:  MOVFF  30F,310
5F22:  MOVLB  0
5F24:  CALL   3F6A
5F28:  MOVF   01,F
5F2A:  BNZ   5F48
....................          http_state[hs]=HTTP_LISTEN_WAIT; 
5F2C:  BCF    FD8.0
5F2E:  MOVLB  3
5F30:  RLCF   x0E,W
5F32:  CLRF   03
5F34:  ADDLW  20
5F36:  MOVWF  FE9
5F38:  MOVLW  01
5F3A:  ADDWFC 03,W
5F3C:  MOVWF  FEA
5F3E:  MOVLW  01
5F40:  MOVWF  FEC
5F42:  MOVF   FED,F
5F44:  MOVWF  FEF
5F46:  MOVLB  0
....................  
....................       switch(http_state[hs]) 
....................       { 
5F48:  BCF    FD8.0
5F4A:  MOVLB  3
5F4C:  RLCF   x0E,W
5F4E:  CLRF   03
5F50:  ADDLW  20
5F52:  MOVWF  FE9
5F54:  MOVLW  01
5F56:  ADDWFC 03,W
5F58:  MOVWF  FEA
5F5A:  MOVFF  FEF,00
5F5E:  INCF   FE9,F
5F60:  MOVF   FEF,W
5F62:  DECF   FE9,F
5F64:  MOVWF  03
5F66:  MOVLW  01
5F68:  SUBWF  03,W
5F6A:  BNZ   5F76
5F6C:  MOVLW  01
5F6E:  SUBWF  00,W
5F70:  MOVLB  0
5F72:  BZ    6024
5F74:  MOVLB  3
5F76:  MOVLW  01
5F78:  SUBWF  03,W
5F7A:  BNZ   5F86
5F7C:  MOVLW  02
5F7E:  SUBWF  00,W
5F80:  MOVLB  0
5F82:  BZ    6034
5F84:  MOVLB  3
5F86:  MOVLW  01
5F88:  SUBWF  03,W
5F8A:  BNZ   5F98
5F8C:  MOVLW  03
5F8E:  SUBWF  00,W
5F90:  MOVLB  0
5F92:  BTFSC  FD8.2
5F94:  BRA    60E4
5F96:  MOVLB  3
5F98:  MOVLW  01
5F9A:  SUBWF  03,W
5F9C:  BNZ   5FAA
5F9E:  MOVLW  04
5FA0:  SUBWF  00,W
5FA2:  MOVLB  0
5FA4:  BTFSC  FD8.2
5FA6:  BRA    6542
5FA8:  MOVLB  3
5FAA:  MOVLW  01
5FAC:  SUBWF  03,W
5FAE:  BNZ   5FBC
5FB0:  MOVLW  05
5FB2:  SUBWF  00,W
5FB4:  MOVLB  0
5FB6:  BTFSC  FD8.2
5FB8:  BRA    65A0
5FBA:  MOVLB  3
5FBC:  MOVLW  01
5FBE:  SUBWF  03,W
5FC0:  BNZ   5FD0
5FC2:  MOVLW  06
5FC4:  SUBWF  00,W
5FC6:  MOVLB  0
5FC8:  BTFSC  FD8.2
5FCA:  GOTO   685E
5FCE:  MOVLB  3
5FD0:  MOVLW  01
5FD2:  SUBWF  03,W
5FD4:  BNZ   5FE4
5FD6:  MOVLW  07
5FD8:  SUBWF  00,W
5FDA:  MOVLB  0
5FDC:  BTFSC  FD8.2
5FDE:  GOTO   68A0
5FE2:  MOVLB  3
5FE4:  MOVLW  01
5FE6:  SUBWF  03,W
5FE8:  BNZ   5FF8
5FEA:  MOVLW  08
5FEC:  SUBWF  00,W
5FEE:  MOVLB  0
5FF0:  BTFSC  FD8.2
5FF2:  GOTO   69EC
5FF6:  MOVLB  3
5FF8:  MOVLW  01
5FFA:  SUBWF  03,W
5FFC:  BNZ   600C
5FFE:  MOVLW  09
6000:  SUBWF  00,W
6002:  MOVLB  0
6004:  BTFSC  FD8.2
6006:  GOTO   6A36
600A:  MOVLB  3
600C:  MOVLW  01
600E:  SUBWF  03,W
6010:  BNZ   6020
6012:  MOVLW  0A
6014:  SUBWF  00,W
6016:  MOVLB  0
6018:  BTFSC  FD8.2
601A:  GOTO   6B34
601E:  MOVLB  3
6020:  GOTO   6B34
....................          case HTTP_LISTEN_WAIT: 
....................             if (!TCPIsConnected(currSocket)) 
6024:  MOVFF  30F,310
6028:  CALL   3F6A
602C:  MOVF   01,F
602E:  BNZ   6034
....................                break; 
6030:  GOTO   6B38
....................             debug_http("HTTP %U CONNECTED\r\n", hs); 
....................  
....................          //wait until we get '\r\n\r\n', which marks the end of the HTTP request header 
....................          case HTTP_CONNECTED: 
....................             debug_http("HTTP %U LISTENING\r\n", hs); 
....................             buffer[hs][0]=0; 
6034:  MOVLB  3
6036:  MOVF   x0E,W
6038:  MULLW  FE
603A:  MOVF   FF3,W
603C:  CLRF   x11
603E:  MOVWF  x10
6040:  MOVLW  6F
6042:  ADDWF  x10,W
6044:  MOVWF  FE9
6046:  MOVLW  01
6048:  ADDWFC x11,W
604A:  MOVWF  FEA
604C:  CLRF   FEF
....................             i[hs]=0; 
604E:  CLRF   03
6050:  MOVF   x0E,W
6052:  ADDLW  6D
6054:  MOVWF  FE9
6056:  MOVLW  02
6058:  ADDWFC 03,W
605A:  MOVWF  FEA
605C:  CLRF   FEF
....................             http_state[hs]=HTTP_GET_HEADERS; 
605E:  BCF    FD8.0
6060:  RLCF   x0E,W
6062:  CLRF   03
6064:  ADDLW  20
6066:  MOVWF  FE9
6068:  MOVLW  01
606A:  ADDWFC 03,W
606C:  MOVWF  FEA
606E:  MOVLW  01
6070:  MOVWF  FEC
6072:  MOVF   FED,F
6074:  MOVLW  03
6076:  MOVWF  FEF
....................             http_timer[hs]=TickGet(); 
6078:  BCF    FD8.0
607A:  RLCF   x0E,W
607C:  CLRF   03
607E:  ADDLW  75
6080:  MOVWF  01
6082:  MOVLW  02
6084:  ADDWFC 03,F
6086:  MOVFF  01,310
608A:  MOVFF  03,311
608E:  MOVLB  0
6090:  CALL   2494
6094:  MOVFF  311,FEA
6098:  MOVFF  310,FE9
609C:  MOVFF  02,FEC
60A0:  MOVF   FED,F
60A2:  MOVFF  01,FEF
....................             http_page_req[hs]=0; 
60A6:  MOVLB  3
60A8:  MOVF   x0E,W
60AA:  MULLW  04
60AC:  MOVF   FF3,W
60AE:  CLRF   03
60B0:  ADDLW  6F
60B2:  MOVWF  FE9
60B4:  MOVLW  02
60B6:  ADDWFC 03,W
60B8:  MOVWF  FEA
60BA:  MOVF   FEE,F
60BC:  MOVF   FEE,F
60BE:  CLRF   FEC
60C0:  MOVF   FED,F
60C2:  CLRF   FEF
60C4:  MOVF   FED,F
60C6:  CLRF   FEF
60C8:  MOVF   FED,F
60CA:  CLRF   FEF
....................             http_post_len[hs]=0; 
60CC:  BCF    FD8.0
60CE:  RLCF   x0E,W
60D0:  CLRF   03
60D2:  ADDLW  73
60D4:  MOVWF  FE9
60D6:  MOVLW  02
60D8:  ADDWFC 03,W
60DA:  MOVWF  FEA
60DC:  CLRF   FEC
60DE:  MOVF   FED,F
60E0:  CLRF   FEF
60E2:  MOVLB  0
....................             //http_got_headers[hs]=FALSE; 
....................             //http_isKeepAlive[hs]=FALSE; 
....................  
....................          case HTTP_GET_HEADERS: 
....................             postContinue=FALSE; 
60E4:  MOVLB  3
60E6:  BCF    x08.1
....................             while (TCPIsGetReady(currSocket) && TCPGet(currSocket, &c)) 
....................             { 
60E8:  MOVFF  30F,310
60EC:  MOVLB  0
60EE:  CALL   3F94
60F2:  MOVF   01,F
60F4:  BTFSC  FD8.2
60F6:  BRA    6442
60F8:  MOVFF  30F,310
60FC:  MOVLW  03
60FE:  MOVLB  3
6100:  MOVWF  x12
6102:  MOVLW  09
6104:  MOVWF  x11
6106:  MOVLB  0
6108:  CALL   3FC4
610C:  MOVF   01,F
610E:  BTFSC  FD8.2
6110:  BRA    6442
....................                //http_got_headers[hs]=TRUE; 
....................                if ( (c >= 0x20) && (i[hs] < HTTP_GET_PARAM_MAX_SIZE - 2) ) 
6112:  MOVLB  3
6114:  MOVF   x09,W
6116:  SUBLW  1F
6118:  BC    6164
611A:  CLRF   03
611C:  MOVF   x0E,W
611E:  ADDLW  6D
6120:  MOVWF  FE9
6122:  MOVLW  02
6124:  ADDWFC 03,W
6126:  MOVWF  FEA
6128:  MOVF   FEF,W
612A:  SUBLW  FB
612C:  BNC   6164
....................                { 
....................                   buffer[hs][i[hs]++]=c; 
612E:  MOVF   x0E,W
6130:  MULLW  FE
6132:  MOVF   FF3,W
6134:  CLRF   x11
6136:  MOVWF  x10
6138:  CLRF   03
613A:  MOVF   x0E,W
613C:  ADDLW  6D
613E:  MOVWF  FE9
6140:  MOVLW  02
6142:  ADDWFC 03,W
6144:  MOVWF  FEA
6146:  MOVF   FEF,W
6148:  INCF   FEF,F
614A:  CLRF   03
614C:  ADDWF  x10,W
614E:  MOVWF  01
6150:  MOVF   x11,W
6152:  ADDWFC 03,F
6154:  MOVF   01,W
6156:  ADDLW  6F
6158:  MOVWF  FE9
615A:  MOVLW  01
615C:  ADDWFC 03,W
615E:  MOVWF  FEA
6160:  MOVFF  309,FEF
....................                } 
....................                if (c=='\n') 
6164:  MOVF   x09,W
6166:  SUBLW  0A
6168:  BTFSS  FD8.2
616A:  BRA    643E
....................                { 
....................                   buffer[hs][i[hs]]=0; 
616C:  MOVF   x0E,W
616E:  MULLW  FE
6170:  MOVF   FF3,W
6172:  CLRF   x11
6174:  MOVWF  x10
6176:  CLRF   03
6178:  MOVF   x0E,W
617A:  ADDLW  6D
617C:  MOVWF  FE9
617E:  MOVLW  02
6180:  ADDWFC 03,W
6182:  MOVWF  FEA
6184:  CLRF   03
6186:  MOVF   FEF,W
6188:  ADDWF  x10,W
618A:  MOVWF  01
618C:  MOVF   x11,W
618E:  ADDWFC 03,F
6190:  MOVF   01,W
6192:  ADDLW  6F
6194:  MOVWF  FE9
6196:  MOVLW  01
6198:  ADDWFC 03,W
619A:  MOVWF  FEA
619C:  CLRF   FEF
....................                   if ( 
....................                        ( ( pKey = strtok(&buffer[hs][0], tokens_header) ) !=0 ) && 
....................                        ( ( pValue = strtok(0, tokens_header) ) !=0 ) 
....................                      ) 
619E:  MOVF   x0E,W
61A0:  MULLW  FE
61A2:  MOVF   FF3,W
61A4:  CLRF   x11
61A6:  MOVWF  x10
61A8:  MOVLW  6F
61AA:  ADDWF  x10,W
61AC:  MOVWF  x12
61AE:  MOVLW  01
61B0:  ADDWFC x11,W
61B2:  MOVWF  x13
61B4:  MOVWF  x15
61B6:  MOVFF  312,314
61BA:  MOVLW  01
61BC:  MOVWF  x17
61BE:  MOVLW  52
61C0:  MOVWF  x16
61C2:  MOVLB  0
61C4:  CALL   41A6
61C8:  MOVFF  02,30B
61CC:  MOVFF  01,30A
61D0:  MOVLB  3
61D2:  MOVF   x0A,F
61D4:  BNZ   61DC
61D6:  MOVF   x0B,F
61D8:  BTFSC  FD8.2
61DA:  BRA    63C0
61DC:  CLRF   x15
61DE:  CLRF   x14
61E0:  MOVLW  01
61E2:  MOVWF  x17
61E4:  MOVLW  52
61E6:  MOVWF  x16
61E8:  MOVLB  0
61EA:  CALL   41A6
61EE:  MOVFF  02,30D
61F2:  MOVFF  01,30C
61F6:  MOVLB  3
61F8:  MOVF   x0C,F
61FA:  BNZ   6202
61FC:  MOVF   x0D,F
61FE:  BTFSC  FD8.2
6200:  BRA    63C0
....................                   { 
....................                      debug_http("HTTP %U PAIR %s = %s\r\n", hs, pKey, pValue); 
....................                      if ( (strcmp(pKey, http_get_str)==0) || (strcmp(pKey, http_post_str)==0) ) 
6202:  MOVFF  30B,312
6206:  MOVFF  30A,311
620A:  MOVLW  01
620C:  MOVWF  x14
620E:  MOVLW  56
6210:  MOVWF  x13
6212:  MOVLB  0
6214:  CALL   4256
6218:  MOVF   01,F
621A:  BZ    623A
621C:  MOVFF  30B,312
6220:  MOVFF  30A,311
6224:  MOVLW  01
6226:  MOVLB  3
6228:  MOVWF  x14
622A:  MOVLW  5A
622C:  MOVWF  x13
622E:  MOVLB  0
6230:  CALL   4256
6234:  MOVF   01,F
6236:  BTFSS  FD8.2
6238:  BRA    6356
....................                      { 
....................                         pValue=strtok(pValue, tokens_get);  //chop the file after a ? 
623A:  MOVFF  30D,315
623E:  MOVFF  30C,314
6242:  MOVLW  01
6244:  MOVLB  3
6246:  MOVWF  x17
6248:  MOVLW  54
624A:  MOVWF  x16
624C:  MOVLB  0
624E:  CALL   41A6
6252:  MOVFF  02,30D
6256:  MOVFF  01,30C
....................                         http_escape_chars(pValue); 
625A:  MOVFF  30D,324
625E:  MOVFF  30C,323
6262:  CALL   47A6
....................                        #if HTTP_USE_CONTENT_TYPE 
....................                         http_get_page(pValue, &http_page_req[hs], &contentType[hs][0]); 
....................                        #else 
....................                         http_page_req[hs] = http_get_page(pValue); 
6266:  MOVLB  3
6268:  MOVF   x0E,W
626A:  MULLW  04
626C:  MOVF   FF3,W
626E:  CLRF   03
6270:  ADDLW  6F
6272:  MOVWF  01
6274:  MOVLW  02
6276:  ADDWFC 03,F
6278:  MOVFF  01,310
627C:  MOVFF  03,311
6280:  MOVFF  30D,313
6284:  MOVFF  30C,312
6288:  MOVLB  0
628A:  GOTO   49AA
628E:  MOVFF  311,FEA
6292:  MOVFF  310,FE9
6296:  MOVFF  00,FEF
629A:  MOVFF  01,FEC
629E:  MOVFF  02,FEC
62A2:  MOVFF  03,FEC
....................                        #endif 
....................                         debug_http("HTTP %U FILE %s = %lx\r\n", hs, pValue, http_page_req[hs]); 
....................                         pValue=strtok(0, tokens_get); 
62A6:  MOVLB  3
62A8:  CLRF   x15
62AA:  CLRF   x14
62AC:  MOVLW  01
62AE:  MOVWF  x17
62B0:  MOVLW  54
62B2:  MOVWF  x16
62B4:  MOVLB  0
62B6:  CALL   41A6
62BA:  MOVFF  02,30D
62BE:  MOVFF  01,30C
....................                         if (pValue) 
62C2:  MOVLB  3
62C4:  MOVF   x0C,W
62C6:  IORWF  x0D,W
62C8:  BZ    630C
....................                            http_parse_cgi_string(http_page_req[hs], pValue); 
62CA:  MOVF   x0E,W
62CC:  MULLW  04
62CE:  MOVF   FF3,W
62D0:  CLRF   03
62D2:  ADDLW  6F
62D4:  MOVWF  FE9
62D6:  MOVLW  02
62D8:  ADDWFC 03,W
62DA:  MOVWF  FEA
62DC:  MOVFF  FEF,310
62E0:  MOVFF  FEC,311
62E4:  MOVFF  FEC,312
62E8:  MOVFF  FEC,313
62EC:  MOVFF  313,31B
62F0:  MOVFF  312,31A
62F4:  MOVFF  311,319
62F8:  MOVFF  310,318
62FC:  MOVFF  30D,31D
6300:  MOVFF  30C,31C
6304:  MOVLB  0
6306:  CALL   4CCC
630A:  MOVLB  3
....................  
....................                         if (strcmp(pKey, http_get_str)==0) 
630C:  MOVFF  30B,312
6310:  MOVFF  30A,311
6314:  MOVLW  01
6316:  MOVWF  x14
6318:  MOVLW  56
631A:  MOVWF  x13
631C:  MOVLB  0
631E:  CALL   4256
6322:  MOVF   01,F
6324:  BNZ   633E
....................                            http_cmd[hs]=HTTP_REQ_GET; 
6326:  CLRF   03
6328:  MOVLB  3
632A:  MOVF   x0E,W
632C:  ADDLW  6E
632E:  MOVWF  FE9
6330:  MOVLW  02
6332:  ADDWFC 03,W
6334:  MOVWF  FEA
6336:  MOVLW  01
6338:  MOVWF  FEF
....................                         else 
633A:  BRA    6352
633C:  MOVLB  0
....................                            http_cmd[hs]=HTTP_REQ_POST; 
633E:  CLRF   03
6340:  MOVLB  3
6342:  MOVF   x0E,W
6344:  ADDLW  6E
6346:  MOVWF  FE9
6348:  MOVLW  02
634A:  ADDWFC 03,W
634C:  MOVWF  FEA
634E:  MOVLW  02
6350:  MOVWF  FEF
....................                      } 
....................                      else if (http_cmd[hs] != HTTP_REQ_UNKOWN)   //we processed a GET or POST 
6352:  BRA    63BE
6354:  MOVLB  0
6356:  CLRF   03
6358:  MOVLB  3
635A:  MOVF   x0E,W
635C:  ADDLW  6E
635E:  MOVWF  FE9
6360:  MOVLW  02
6362:  ADDWFC 03,W
6364:  MOVWF  FEA
6366:  MOVF   FEF,F
6368:  BZ    63BE
....................                      { 
....................                         //if you want to parse HTTP headers, do it here. 
....................                         //pKey and pVal hold the individual headers. 
....................  
....................                         //this driver only parses the Content-Length header. 
....................                         if (strcmp(pKey, http_len_str)==0) 
636A:  MOVFF  30B,312
636E:  MOVFF  30A,311
6372:  MOVLW  01
6374:  MOVWF  x14
6376:  MOVLW  5F
6378:  MOVWF  x13
637A:  MOVLB  0
637C:  CALL   4256
6380:  MOVF   01,F
6382:  BNZ   63BC
....................                         { 
....................                            http_post_len[hs]=atol(pValue); 
6384:  BCF    FD8.0
6386:  MOVLB  3
6388:  RLCF   x0E,W
638A:  CLRF   03
638C:  ADDLW  73
638E:  MOVWF  01
6390:  MOVLW  02
6392:  ADDWFC 03,F
6394:  MOVFF  01,310
6398:  MOVFF  03,311
639C:  MOVFF  30D,313
63A0:  MOVFF  30C,312
63A4:  MOVLB  0
63A6:  GOTO   4D74
63AA:  MOVFF  311,FEA
63AE:  MOVFF  310,FE9
63B2:  MOVFF  02,FEC
63B6:  MOVF   FED,F
63B8:  MOVFF  01,FEF
63BC:  MOVLB  3
....................                         } 
....................                      } 
....................                   } 
....................                   else if (i[hs] == 0) 
63BE:  BRA    642E
63C0:  CLRF   03
63C2:  MOVF   x0E,W
63C4:  ADDLW  6D
63C6:  MOVWF  FE9
63C8:  MOVLW  02
63CA:  ADDWFC 03,W
63CC:  MOVWF  FEA
63CE:  MOVF   FEF,F
63D0:  BNZ   642E
....................                   { 
....................                      //got a double \r\n 
....................                      debug_http("HTTP %U GET HEADER DONE\r\n", hs); 
....................                      if (http_cmd[hs] == HTTP_REQ_POST) 
63D2:  CLRF   03
63D4:  MOVF   x0E,W
63D6:  ADDLW  6E
63D8:  MOVWF  FE9
63DA:  MOVLW  02
63DC:  ADDWFC 03,W
63DE:  MOVWF  FEA
63E0:  MOVF   FEF,W
63E2:  SUBLW  02
63E4:  BNZ   6404
....................                      { 
....................                         http_state[hs]=HTTP_GET_POST; 
63E6:  BCF    FD8.0
63E8:  RLCF   x0E,W
63EA:  CLRF   03
63EC:  ADDLW  20
63EE:  MOVWF  FE9
63F0:  MOVLW  01
63F2:  ADDWFC 03,W
63F4:  MOVWF  FEA
63F6:  MOVLW  01
63F8:  MOVWF  FEC
63FA:  MOVF   FED,F
63FC:  MOVLW  04
63FE:  MOVWF  FEF
....................                         postContinue=TRUE; 
6400:  BSF    x08.1
....................                      } 
....................                      else 
6402:  BRA    6428
....................                      { 
....................                         http_state[hs]=HTTP_SEND_RESPONSE; 
6404:  BCF    FD8.0
6406:  RLCF   x0E,W
6408:  CLRF   03
640A:  ADDLW  20
640C:  MOVWF  FE9
640E:  MOVLW  01
6410:  ADDWFC 03,W
6412:  MOVWF  FEA
6414:  MOVLW  01
6416:  MOVWF  FEC
6418:  MOVF   FED,F
641A:  MOVLW  06
641C:  MOVWF  FEF
....................                         TCPDiscard(currSocket); 
641E:  MOVFF  30F,313
6422:  MOVLB  0
6424:  CALL   4F68
....................                      } 
....................                      break;   //break out of read from ethernet loop 
6428:  MOVLB  0
642A:  BRA    6442
642C:  MOVLB  3
....................                   } 
....................                   i[hs]=0; 
642E:  CLRF   03
6430:  MOVF   x0E,W
6432:  ADDLW  6D
6434:  MOVWF  FE9
6436:  MOVLW  02
6438:  ADDWFC 03,W
643A:  MOVWF  FEA
643C:  CLRF   FEF
....................                } 
....................             } 
643E:  BRA    60E8
6440:  MOVLB  0
....................             if (TickGetDiff(TickGet(),http_timer[hs]) > TICKS_PER_SECOND*20) 
6442:  CALL   2494
6446:  MOVFF  02,311
644A:  MOVFF  01,310
644E:  BCF    FD8.0
6450:  MOVLB  3
6452:  RLCF   x0E,W
6454:  CLRF   03
6456:  ADDLW  75
6458:  MOVWF  FE9
645A:  MOVLW  02
645C:  ADDWFC 03,W
645E:  MOVWF  FEA
6460:  MOVFF  FEC,03
6464:  MOVF   FED,F
6466:  MOVFF  FEF,01
646A:  MOVF   02,W
646C:  SUBWF  03,W
646E:  BNC   6478
6470:  BNZ   647C
6472:  MOVF   01,W
6474:  SUBWF  x10,W
6476:  BNC   647C
6478:  MOVLW  00
647A:  BRA    647E
647C:  MOVLW  01
647E:  CLRF   03
6480:  IORWF  03,W
6482:  BZ    64CA
6484:  BCF    FD8.0
6486:  RLCF   x0E,W
6488:  CLRF   03
648A:  ADDLW  75
648C:  MOVWF  FE9
648E:  MOVLW  02
6490:  ADDWFC 03,W
6492:  MOVWF  FEA
6494:  MOVFF  FEC,03
6498:  MOVF   FED,F
649A:  MOVF   FEF,W
649C:  SUBLW  FF
649E:  MOVWF  x12
64A0:  MOVLW  FF
64A2:  SUBFWB 03,W
64A4:  MOVWF  x13
64A6:  MOVLB  0
64A8:  CALL   2494
64AC:  MOVF   01,W
64AE:  MOVLB  3
64B0:  ADDWF  x12,W
64B2:  MOVWF  x14
64B4:  MOVF   02,W
64B6:  ADDWFC x13,W
64B8:  MOVWF  x15
64BA:  MOVLW  01
64BC:  ADDWF  x14,W
64BE:  MOVWF  01
64C0:  MOVLW  00
64C2:  ADDWFC x15,W
64C4:  MOVWF  03
64C6:  MOVF   01,W
64C8:  BRA    64FE
64CA:  MOVLB  0
64CC:  CALL   2494
64D0:  MOVFF  02,317
64D4:  MOVFF  01,316
64D8:  BCF    FD8.0
64DA:  MOVLB  3
64DC:  RLCF   x0E,W
64DE:  CLRF   03
64E0:  ADDLW  75
64E2:  MOVWF  FE9
64E4:  MOVLW  02
64E6:  ADDWFC 03,W
64E8:  MOVWF  FEA
64EA:  MOVFF  FEC,03
64EE:  MOVF   FED,F
64F0:  MOVF   FEF,W
64F2:  SUBWF  01,W
64F4:  MOVWF  00
64F6:  MOVF   03,W
64F8:  SUBWFB 02,W
64FA:  MOVWF  03
64FC:  MOVF   00,W
64FE:  SUBLW  C8
6500:  BC    6538
....................             { 
....................                //if (http_got_headers[hs]) 
....................                //{ 
....................                   debug_http("HTTP %U GET HEADER TIMEOUT\r\n", hs); 
....................                   http_page_req[hs]=0xFFFFFFFF; 
6502:  MOVF   x0E,W
6504:  MULLW  04
6506:  MOVF   FF3,W
6508:  CLRF   03
650A:  ADDLW  6F
650C:  MOVWF  FE9
650E:  MOVLW  02
6510:  ADDWFC 03,W
6512:  MOVWF  FEA
6514:  MOVLW  FF
6516:  MOVWF  FEF
6518:  MOVWF  FEC
651A:  MOVWF  FEC
651C:  MOVWF  FEC
....................                   http_state[hs]=HTTP_SEND_RESPONSE; 
651E:  BCF    FD8.0
6520:  RLCF   x0E,W
6522:  CLRF   03
6524:  ADDLW  20
6526:  MOVWF  FE9
6528:  MOVLW  01
652A:  ADDWFC 03,W
652C:  MOVWF  FEA
652E:  MOVLW  01
6530:  MOVWF  FEC
6532:  MOVF   FED,F
6534:  MOVLW  06
6536:  MOVWF  FEF
....................                //} 
....................                //else 
....................                //{ 
....................                //   http_state[hs]=HTTP_CLOSE; 
....................                //} 
....................             } 
....................             if (!postContinue) 
6538:  BTFSC  x08.1
653A:  BRA    6540
....................                break; 
653C:  MOVLB  0
653E:  BRA    6B38
6540:  MOVLB  0
....................  
....................          case HTTP_GET_POST: 
....................             debug_http("HTTP %U GET POST %LU\r\n", hs, http_post_len[hs]); 
....................             http_state[hs]=HTTP_GET_POST_CONTINUE; 
6542:  BCF    FD8.0
6544:  MOVLB  3
6546:  RLCF   x0E,W
6548:  CLRF   03
654A:  ADDLW  20
654C:  MOVWF  FE9
654E:  MOVLW  01
6550:  ADDWFC 03,W
6552:  MOVWF  FEA
6554:  MOVLW  01
6556:  MOVWF  FEC
6558:  MOVF   FED,F
655A:  MOVLW  05
655C:  MOVWF  FEF
....................             http_timer[hs]=TickGet(); 
655E:  BCF    FD8.0
6560:  RLCF   x0E,W
6562:  CLRF   03
6564:  ADDLW  75
6566:  MOVWF  01
6568:  MOVLW  02
656A:  ADDWFC 03,F
656C:  MOVFF  01,310
6570:  MOVFF  03,311
6574:  MOVLB  0
6576:  CALL   2494
657A:  MOVFF  311,FEA
657E:  MOVFF  310,FE9
6582:  MOVFF  02,FEC
6586:  MOVF   FED,F
6588:  MOVFF  01,FEF
....................             i[hs]=0; 
658C:  CLRF   03
658E:  MOVLB  3
6590:  MOVF   x0E,W
6592:  ADDLW  6D
6594:  MOVWF  FE9
6596:  MOVLW  02
6598:  ADDWFC 03,W
659A:  MOVWF  FEA
659C:  CLRF   FEF
659E:  MOVLB  0
....................  
....................          case HTTP_GET_POST_CONTINUE: 
....................             while ( 
....................                      TCPIsGetReady(currSocket) && 
....................                      TCPGet(currSocket, &c) && 
....................                      (http_post_len[hs] != 0) 
....................                   ) 
....................             { 
65A0:  MOVFF  30F,310
65A4:  CALL   3F94
65A8:  MOVF   01,F
65AA:  BTFSC  FD8.2
65AC:  BRA    6764
65AE:  MOVFF  30F,310
65B2:  MOVLW  03
65B4:  MOVLB  3
65B6:  MOVWF  x12
65B8:  MOVLW  09
65BA:  MOVWF  x11
65BC:  MOVLB  0
65BE:  CALL   3FC4
65C2:  MOVF   01,F
65C4:  BTFSC  FD8.2
65C6:  BRA    6764
65C8:  BCF    FD8.0
65CA:  MOVLB  3
65CC:  RLCF   x0E,W
65CE:  CLRF   03
65D0:  ADDLW  73
65D2:  MOVWF  FE9
65D4:  MOVLW  02
65D6:  ADDWFC 03,W
65D8:  MOVWF  FEA
65DA:  MOVFF  FEC,311
65DE:  MOVF   FED,F
65E0:  MOVFF  FEF,310
65E4:  MOVF   x10,F
65E6:  BNZ   65F2
65E8:  MOVF   x11,F
65EA:  BTFSS  FD8.2
65EC:  BRA    65F2
65EE:  MOVLB  0
65F0:  BRA    6764
....................                http_post_len[hs] -= 1; 
65F2:  BCF    FD8.0
65F4:  RLCF   x0E,W
65F6:  CLRF   03
65F8:  ADDLW  73
65FA:  MOVWF  FE9
65FC:  MOVLW  02
65FE:  ADDWFC 03,W
6600:  MOVWF  FEA
6602:  MOVLW  01
6604:  SUBWF  FEF,W
6606:  MOVWF  00
6608:  MOVLW  00
660A:  SUBWFB FEC,W
660C:  MOVWF  03
660E:  MOVF   00,W
6610:  MOVF   FED,F
6612:  MOVWF  FEF
6614:  MOVFF  03,FEC
....................  
....................                if (c!='&') 
6618:  MOVF   x09,W
661A:  SUBLW  26
661C:  BZ    6654
....................                { 
....................                   buffer[hs][i[hs]++]=c; 
661E:  MOVF   x0E,W
6620:  MULLW  FE
6622:  MOVF   FF3,W
6624:  CLRF   x11
6626:  MOVWF  x10
6628:  CLRF   03
662A:  MOVF   x0E,W
662C:  ADDLW  6D
662E:  MOVWF  FE9
6630:  MOVLW  02
6632:  ADDWFC 03,W
6634:  MOVWF  FEA
6636:  MOVF   FEF,W
6638:  INCF   FEF,F
663A:  CLRF   03
663C:  ADDWF  x10,W
663E:  MOVWF  01
6640:  MOVF   x11,W
6642:  ADDWFC 03,F
6644:  MOVF   01,W
6646:  ADDLW  6F
6648:  MOVWF  FE9
664A:  MOVLW  01
664C:  ADDWFC 03,W
664E:  MOVWF  FEA
6650:  MOVFF  309,FEF
....................                } 
....................  
....................                if ( (c=='&') || (http_post_len[hs] == 0) ) 
6654:  MOVF   x09,W
6656:  SUBLW  26
6658:  BZ    667C
665A:  BCF    FD8.0
665C:  RLCF   x0E,W
665E:  CLRF   03
6660:  ADDLW  73
6662:  MOVWF  FE9
6664:  MOVLW  02
6666:  ADDWFC 03,W
6668:  MOVWF  FEA
666A:  MOVFF  FEC,311
666E:  MOVF   FED,F
6670:  MOVFF  FEF,310
6674:  MOVF   x10,F
6676:  BNZ   6760
6678:  MOVF   x11,F
667A:  BNZ   6760
....................                { 
....................                   buffer[hs][i[hs]]=0; 
667C:  MOVF   x0E,W
667E:  MULLW  FE
6680:  MOVF   FF3,W
6682:  CLRF   x11
6684:  MOVWF  x10
6686:  CLRF   03
6688:  MOVF   x0E,W
668A:  ADDLW  6D
668C:  MOVWF  FE9
668E:  MOVLW  02
6690:  ADDWFC 03,W
6692:  MOVWF  FEA
6694:  CLRF   03
6696:  MOVF   FEF,W
6698:  ADDWF  x10,W
669A:  MOVWF  01
669C:  MOVF   x11,W
669E:  ADDWFC 03,F
66A0:  MOVF   01,W
66A2:  ADDLW  6F
66A4:  MOVWF  FE9
66A6:  MOVLW  01
66A8:  ADDWFC 03,W
66AA:  MOVWF  FEA
66AC:  CLRF   FEF
....................  
....................                   debug_http("%lu - %s\r\n", http_post_len[hs], &buffer[hs][0]); 
....................  
....................                   http_parse_cgi_string(http_page_req[hs], &buffer[hs][0]); 
66AE:  MOVF   x0E,W
66B0:  MULLW  04
66B2:  MOVF   FF3,W
66B4:  CLRF   03
66B6:  ADDLW  6F
66B8:  MOVWF  FE9
66BA:  MOVLW  02
66BC:  ADDWFC 03,W
66BE:  MOVWF  FEA
66C0:  MOVFF  FEF,310
66C4:  MOVFF  FEC,311
66C8:  MOVFF  FEC,312
66CC:  MOVFF  FEC,313
66D0:  MOVF   x0E,W
66D2:  MULLW  FE
66D4:  MOVF   FF3,W
66D6:  CLRF   x15
66D8:  MOVWF  x14
66DA:  MOVLW  6F
66DC:  ADDWF  x14,W
66DE:  MOVWF  x16
66E0:  MOVLW  01
66E2:  ADDWFC x15,W
66E4:  MOVWF  x17
66E6:  MOVFF  313,31B
66EA:  MOVFF  312,31A
66EE:  MOVFF  311,319
66F2:  MOVFF  310,318
66F6:  MOVWF  x1D
66F8:  MOVFF  316,31C
66FC:  MOVLB  0
66FE:  CALL   4CCC
....................                   if (http_post_len[hs] == 0) 
6702:  BCF    FD8.0
6704:  MOVLB  3
6706:  RLCF   x0E,W
6708:  CLRF   03
670A:  ADDLW  73
670C:  MOVWF  FE9
670E:  MOVLW  02
6710:  ADDWFC 03,W
6712:  MOVWF  FEA
6714:  MOVFF  FEC,311
6718:  MOVF   FED,F
671A:  MOVFF  FEF,310
671E:  MOVF   x10,F
6720:  BNZ   6750
6722:  MOVF   x11,F
6724:  BNZ   6750
....................                   { 
....................                      http_state[hs]=HTTP_SEND_RESPONSE; 
6726:  BCF    FD8.0
6728:  RLCF   x0E,W
672A:  CLRF   03
672C:  ADDLW  20
672E:  MOVWF  FE9
6730:  MOVLW  01
6732:  ADDWFC 03,W
6734:  MOVWF  FEA
6736:  MOVLW  01
6738:  MOVWF  FEC
673A:  MOVF   FED,F
673C:  MOVLW  06
673E:  MOVWF  FEF
....................                      TCPDiscard(currSocket); 
6740:  MOVFF  30F,313
6744:  MOVLB  0
6746:  CALL   4F68
....................                      break; 
674A:  BRA    6764
....................                   } 
....................                   else 
674C:  BRA    6762
674E:  MOVLB  3
....................                      i[hs]=0; 
6750:  CLRF   03
6752:  MOVF   x0E,W
6754:  ADDLW  6D
6756:  MOVWF  FE9
6758:  MOVLW  02
675A:  ADDWFC 03,W
675C:  MOVWF  FEA
675E:  CLRF   FEF
6760:  MOVLB  0
....................                } 
....................             } 
6762:  BRA    65A0
....................             if (TickGetDiff(TickGet(),http_timer[hs]) > TICKS_PER_SECOND*20) 
6764:  CALL   2494
6768:  MOVFF  02,311
676C:  MOVFF  01,310
6770:  BCF    FD8.0
6772:  MOVLB  3
6774:  RLCF   x0E,W
6776:  CLRF   03
6778:  ADDLW  75
677A:  MOVWF  FE9
677C:  MOVLW  02
677E:  ADDWFC 03,W
6780:  MOVWF  FEA
6782:  MOVFF  FEC,03
6786:  MOVF   FED,F
6788:  MOVFF  FEF,01
678C:  MOVF   02,W
678E:  SUBWF  03,W
6790:  BNC   679A
6792:  BNZ   679E
6794:  MOVF   01,W
6796:  SUBWF  x10,W
6798:  BNC   679E
679A:  MOVLW  00
679C:  BRA    67A0
679E:  MOVLW  01
67A0:  CLRF   03
67A2:  IORWF  03,W
67A4:  BZ    67EC
67A6:  BCF    FD8.0
67A8:  RLCF   x0E,W
67AA:  CLRF   03
67AC:  ADDLW  75
67AE:  MOVWF  FE9
67B0:  MOVLW  02
67B2:  ADDWFC 03,W
67B4:  MOVWF  FEA
67B6:  MOVFF  FEC,03
67BA:  MOVF   FED,F
67BC:  MOVF   FEF,W
67BE:  SUBLW  FF
67C0:  MOVWF  x12
67C2:  MOVLW  FF
67C4:  SUBFWB 03,W
67C6:  MOVWF  x13
67C8:  MOVLB  0
67CA:  CALL   2494
67CE:  MOVF   01,W
67D0:  MOVLB  3
67D2:  ADDWF  x12,W
67D4:  MOVWF  x14
67D6:  MOVF   02,W
67D8:  ADDWFC x13,W
67DA:  MOVWF  x15
67DC:  MOVLW  01
67DE:  ADDWF  x14,W
67E0:  MOVWF  01
67E2:  MOVLW  00
67E4:  ADDWFC x15,W
67E6:  MOVWF  03
67E8:  MOVF   01,W
67EA:  BRA    6820
67EC:  MOVLB  0
67EE:  CALL   2494
67F2:  MOVFF  02,317
67F6:  MOVFF  01,316
67FA:  BCF    FD8.0
67FC:  MOVLB  3
67FE:  RLCF   x0E,W
6800:  CLRF   03
6802:  ADDLW  75
6804:  MOVWF  FE9
6806:  MOVLW  02
6808:  ADDWFC 03,W
680A:  MOVWF  FEA
680C:  MOVFF  FEC,03
6810:  MOVF   FED,F
6812:  MOVF   FEF,W
6814:  SUBWF  01,W
6816:  MOVWF  00
6818:  MOVF   03,W
681A:  SUBWFB 02,W
681C:  MOVWF  03
681E:  MOVF   00,W
6820:  SUBLW  C8
6822:  BC    685A
....................             { 
....................                debug_http("HTTP %U GET POST TIMEOUT\r\n", hs); 
....................                http_page_req[hs]=0xFFFFFFFF; 
6824:  MOVF   x0E,W
6826:  MULLW  04
6828:  MOVF   FF3,W
682A:  CLRF   03
682C:  ADDLW  6F
682E:  MOVWF  FE9
6830:  MOVLW  02
6832:  ADDWFC 03,W
6834:  MOVWF  FEA
6836:  MOVLW  FF
6838:  MOVWF  FEF
683A:  MOVWF  FEC
683C:  MOVWF  FEC
683E:  MOVWF  FEC
....................                http_state[hs]=HTTP_SEND_RESPONSE; 
6840:  BCF    FD8.0
6842:  RLCF   x0E,W
6844:  CLRF   03
6846:  ADDLW  20
6848:  MOVWF  FE9
684A:  MOVLW  01
684C:  ADDWFC 03,W
684E:  MOVWF  FEA
6850:  MOVLW  01
6852:  MOVWF  FEC
6854:  MOVF   FED,F
6856:  MOVLW  06
6858:  MOVWF  FEF
....................             } 
....................             break; 
685A:  MOVLB  0
685C:  BRA    6B38
....................  
....................          case HTTP_SEND_RESPONSE: 
....................             debug_http("HTTP %U SEND RESPONSE\r\n", hs); 
....................             lastHTTPPutConstPos[hs]=0; 
685E:  MOVLB  3
6860:  MOVF   x0E,W
6862:  MULLW  04
6864:  MOVF   FF3,W
6866:  CLRF   03
6868:  ADDLW  23
686A:  MOVWF  FE9
686C:  MOVLW  01
686E:  ADDWFC 03,W
6870:  MOVWF  FEA
6872:  MOVF   FEE,F
6874:  MOVF   FEE,F
6876:  CLRF   FEC
6878:  MOVF   FED,F
687A:  CLRF   FEF
687C:  MOVF   FED,F
687E:  CLRF   FEF
6880:  MOVF   FED,F
6882:  CLRF   FEF
....................             http_state[hs]=HTTP_SEND_RESPONSE_CONTINUE; 
6884:  BCF    FD8.0
6886:  RLCF   x0E,W
6888:  CLRF   03
688A:  ADDLW  20
688C:  MOVWF  FE9
688E:  MOVLW  01
6890:  ADDWFC 03,W
6892:  MOVWF  FEA
6894:  MOVLW  01
6896:  MOVWF  FEC
6898:  MOVF   FED,F
689A:  MOVLW  07
689C:  MOVWF  FEF
689E:  MOVLB  0
....................  
....................          case HTTP_SEND_RESPONSE_CONTINUE: 
....................             TCPDiscard(currSocket); 
68A0:  MOVFF  30F,313
68A4:  CALL   4F68
....................             if (TCPIsPutReady(currSocket)) 
68A8:  MOVFF  30F,333
68AC:  CALL   4FB6
68B0:  MOVF   01,F
68B2:  BTFSC  FD8.2
68B4:  BRA    69EA
....................             { 
....................                debug_http("\r\nPUTTING HTTP SEG\r\n"); 
....................                if (http_page_req[hs]==0xFFFFFFFF) 
68B6:  MOVLB  3
68B8:  MOVF   x0E,W
68BA:  MULLW  04
68BC:  MOVF   FF3,W
68BE:  CLRF   03
68C0:  ADDLW  6F
68C2:  MOVWF  FE9
68C4:  MOVLW  02
68C6:  ADDWFC 03,W
68C8:  MOVWF  FEA
68CA:  MOVFF  FEF,310
68CE:  MOVFF  FEC,311
68D2:  MOVFF  FEC,312
68D6:  MOVFF  FEC,313
68DA:  INCFSZ x10,W
68DC:  BRA    6922
68DE:  INCFSZ x11,W
68E0:  BRA    6922
68E2:  INCFSZ x12,W
68E4:  BRA    6922
68E6:  INCFSZ x13,W
68E8:  BRA    6922
....................                   doneSend=tcp_http_put_file(hs, 500, label_address(http_500_error), 0); 
68EA:  MOVLW  02
68EC:  MOVWF  03
68EE:  MOVLW  5C
68F0:  MOVWF  x10
68F2:  MOVFF  03,311
68F6:  MOVFF  30E,314
68FA:  MOVLW  01
68FC:  MOVWF  x16
68FE:  MOVLW  F4
6900:  MOVWF  x15
6902:  CLRF   x1A
6904:  CLRF   x19
6906:  MOVFF  03,318
690A:  MOVFF  310,317
690E:  CLRF   x1C
6910:  CLRF   x1B
6912:  MOVLB  0
6914:  CALL   59E0
6918:  MOVLB  3
691A:  BCF    x08.0
691C:  BTFSC  01.0
691E:  BSF    x08.0
....................                else if (http_page_req[hs]) 
6920:  BRA    69CA
....................                 #if HTTP_USE_CONTENT_TYPE 
6922:  MOVF   x0E,W
6924:  MULLW  04
6926:  MOVF   FF3,W
6928:  CLRF   03
692A:  ADDLW  6F
692C:  MOVWF  FE9
692E:  MOVLW  02
6930:  ADDWFC 03,W
6932:  MOVWF  FEA
6934:  MOVF   FEF,F
6936:  BNZ   6944
6938:  MOVF   FEC,F
693A:  BNZ   6944
693C:  MOVF   FEC,F
693E:  BNZ   6944
6940:  MOVF   FEC,F
6942:  BZ    6994
....................                   doneSend=tcp_http_put_file(hs, 200, http_page_req[hs], &contentType[hs][0]); 
....................                 #else 
....................                   doneSend=tcp_http_put_file(hs, 200, http_page_req[hs], 0); 
6944:  MOVF   x0E,W
6946:  MULLW  04
6948:  MOVF   FF3,W
694A:  CLRF   03
694C:  ADDLW  6F
694E:  MOVWF  FE9
6950:  MOVLW  02
6952:  ADDWFC 03,W
6954:  MOVWF  FEA
6956:  MOVFF  FEF,310
695A:  MOVFF  FEC,311
695E:  MOVFF  FEC,312
6962:  MOVFF  FEC,313
6966:  MOVFF  30E,314
696A:  CLRF   x16
696C:  MOVLW  C8
696E:  MOVWF  x15
6970:  MOVFF  313,31A
6974:  MOVFF  312,319
6978:  MOVFF  311,318
697C:  MOVFF  310,317
6980:  CLRF   x1C
6982:  CLRF   x1B
6984:  MOVLB  0
6986:  CALL   59E0
698A:  MOVLB  3
698C:  BCF    x08.0
698E:  BTFSC  01.0
6990:  BSF    x08.0
....................                 #endif 
....................                else 
6992:  BRA    69CA
....................                   doneSend=tcp_http_put_file(hs, 404, label_address(http_404_error), 0); 
6994:  MOVLW  02
6996:  MOVWF  03
6998:  MOVLW  18
699A:  MOVWF  x10
699C:  MOVFF  03,311
69A0:  MOVFF  30E,314
69A4:  MOVLW  01
69A6:  MOVWF  x16
69A8:  MOVLW  94
69AA:  MOVWF  x15
69AC:  CLRF   x1A
69AE:  CLRF   x19
69B0:  MOVFF  03,318
69B4:  MOVFF  310,317
69B8:  CLRF   x1C
69BA:  CLRF   x1B
69BC:  MOVLB  0
69BE:  CALL   59E0
69C2:  MOVLB  3
69C4:  BCF    x08.0
69C6:  BTFSC  01.0
69C8:  BSF    x08.0
....................  
....................                if (doneSend) 
69CA:  BTFSS  x08.0
69CC:  BRA    69E8
....................                { 
....................                   //if (http_isKeepAlive[hs]) 
....................                   //   http_state[hs]=HTTP_CONNECTED; 
....................                   //else 
....................                   //   http_state[hs]=HTTP_CLOSE; 
....................                   http_state[hs] = HTTP_CLOSE; 
69CE:  BCF    FD8.0
69D0:  RLCF   x0E,W
69D2:  CLRF   03
69D4:  ADDLW  20
69D6:  MOVWF  FE9
69D8:  MOVLW  01
69DA:  ADDWFC 03,W
69DC:  MOVWF  FEA
69DE:  MOVLW  01
69E0:  MOVWF  FEC
69E2:  MOVF   FED,F
69E4:  MOVLW  08
69E6:  MOVWF  FEF
69E8:  MOVLB  0
....................                   debug_http("HTTP %U RESPONSE SENT\r\n", hs); 
....................                } 
....................             } 
....................             /*else 
....................             { 
....................                debug_http("\r\nNR => RW=%LX B=%X IS=%U\r\n", 
....................                      TCB[currSocket].RemoteWindow, 
....................                      TCB[currSocket].TxBuffer, 
....................                      TCB[currSocket].Flags.bIsPutReady 
....................                   ); 
....................                delay_ms(100); 
....................             }*/ 
....................             break; 
69EA:  BRA    6B38
....................  
....................          case HTTP_CLOSE: 
....................             //since we set connection: close in the header, the client 
....................             //should automatically close.  but after so many seconds we 
....................             //shall kill the connection 
....................             http_state[hs]=HTTP_CLOSE_WAITING; 
69EC:  BCF    FD8.0
69EE:  MOVLB  3
69F0:  RLCF   x0E,W
69F2:  CLRF   03
69F4:  ADDLW  20
69F6:  MOVWF  FE9
69F8:  MOVLW  01
69FA:  ADDWFC 03,W
69FC:  MOVWF  FEA
69FE:  MOVLW  01
6A00:  MOVWF  FEC
6A02:  MOVF   FED,F
6A04:  MOVLW  09
6A06:  MOVWF  FEF
....................             http_timer[hs]=TickGet(); 
6A08:  BCF    FD8.0
6A0A:  RLCF   x0E,W
6A0C:  CLRF   03
6A0E:  ADDLW  75
6A10:  MOVWF  01
6A12:  MOVLW  02
6A14:  ADDWFC 03,F
6A16:  MOVFF  01,310
6A1A:  MOVFF  03,311
6A1E:  MOVLB  0
6A20:  CALL   2494
6A24:  MOVFF  311,FEA
6A28:  MOVFF  310,FE9
6A2C:  MOVFF  02,FEC
6A30:  MOVF   FED,F
6A32:  MOVFF  01,FEF
....................  
....................          case HTTP_CLOSE_WAITING: 
....................             TCPDiscard(currSocket); 
6A36:  MOVFF  30F,313
6A3A:  CALL   4F68
....................             if (  TCPIsPutReady(currSocket) || 
....................                   (TickGetDiff(TickGet(),http_timer[hs]) > (TICKS_PER_SECOND*5)) 
....................                ) 
6A3E:  MOVFF  30F,333
6A42:  CALL   4FB6
6A46:  MOVF   01,F
6A48:  BNZ   6B0C
6A4A:  CALL   2494
6A4E:  MOVFF  02,311
6A52:  MOVFF  01,310
6A56:  BCF    FD8.0
6A58:  MOVLB  3
6A5A:  RLCF   x0E,W
6A5C:  CLRF   03
6A5E:  ADDLW  75
6A60:  MOVWF  FE9
6A62:  MOVLW  02
6A64:  ADDWFC 03,W
6A66:  MOVWF  FEA
6A68:  MOVFF  FEC,03
6A6C:  MOVF   FED,F
6A6E:  MOVFF  FEF,01
6A72:  MOVF   02,W
6A74:  SUBWF  03,W
6A76:  BNC   6A80
6A78:  BNZ   6A84
6A7A:  MOVF   01,W
6A7C:  SUBWF  x10,W
6A7E:  BNC   6A84
6A80:  MOVLW  00
6A82:  BRA    6A86
6A84:  MOVLW  01
6A86:  CLRF   03
6A88:  IORWF  03,W
6A8A:  BZ    6AD2
6A8C:  BCF    FD8.0
6A8E:  RLCF   x0E,W
6A90:  CLRF   03
6A92:  ADDLW  75
6A94:  MOVWF  FE9
6A96:  MOVLW  02
6A98:  ADDWFC 03,W
6A9A:  MOVWF  FEA
6A9C:  MOVFF  FEC,03
6AA0:  MOVF   FED,F
6AA2:  MOVF   FEF,W
6AA4:  SUBLW  FF
6AA6:  MOVWF  x12
6AA8:  MOVLW  FF
6AAA:  SUBFWB 03,W
6AAC:  MOVWF  x13
6AAE:  MOVLB  0
6AB0:  CALL   2494
6AB4:  MOVF   01,W
6AB6:  MOVLB  3
6AB8:  ADDWF  x12,W
6ABA:  MOVWF  x14
6ABC:  MOVF   02,W
6ABE:  ADDWFC x13,W
6AC0:  MOVWF  x15
6AC2:  MOVLW  01
6AC4:  ADDWF  x14,W
6AC6:  MOVWF  01
6AC8:  MOVLW  00
6ACA:  ADDWFC x15,W
6ACC:  MOVWF  03
6ACE:  MOVF   01,W
6AD0:  BRA    6B06
6AD2:  MOVLB  0
6AD4:  CALL   2494
6AD8:  MOVFF  02,317
6ADC:  MOVFF  01,316
6AE0:  BCF    FD8.0
6AE2:  MOVLB  3
6AE4:  RLCF   x0E,W
6AE6:  CLRF   03
6AE8:  ADDLW  75
6AEA:  MOVWF  FE9
6AEC:  MOVLW  02
6AEE:  ADDWFC 03,W
6AF0:  MOVWF  FEA
6AF2:  MOVFF  FEC,03
6AF6:  MOVF   FED,F
6AF8:  MOVF   FEF,W
6AFA:  SUBWF  01,W
6AFC:  MOVWF  00
6AFE:  MOVF   03,W
6B00:  SUBWFB 02,W
6B02:  MOVWF  03
6B04:  MOVF   00,W
6B06:  SUBLW  32
6B08:  BC    6B30
6B0A:  MOVLB  0
....................             { 
....................                debug_http("HTTP %U FORCE CLOSED\r\n", hs); 
....................                TCPDisconnect(currSocket); 
6B0C:  MOVFF  30F,310
6B10:  GOTO   5D98
....................                http_state[hs]=HTTP_CLOSED; 
6B14:  BCF    FD8.0
6B16:  MOVLB  3
6B18:  RLCF   x0E,W
6B1A:  CLRF   03
6B1C:  ADDLW  20
6B1E:  MOVWF  FE9
6B20:  MOVLW  01
6B22:  ADDWFC 03,W
6B24:  MOVWF  FEA
6B26:  MOVLW  01
6B28:  MOVWF  FEC
6B2A:  MOVF   FED,F
6B2C:  MOVLW  0A
6B2E:  MOVWF  FEF
....................             } 
....................             break; 
6B30:  MOVLB  0
6B32:  BRA    6B38
....................  
....................          case HTTP_CLOSED: //do nothing until socket actually closes 
....................          default: 
....................             break; 
6B34:  MOVLB  0
6B36:  BRA    6B38
....................       } 
....................    } 
6B38:  MOVLB  3
6B3A:  INCF   x0E,F
6B3C:  GOTO   5EDE
.................... } 
6B40:  MOVLB  0
6B42:  GOTO   6D08 (RETURN)
....................  
.................... #endif 
....................  
.................... #if STACK_USE_HTTP2 
....................    #include "tcpip/http2.c" 
.................... #endif 
....................  
.................... #if STACK_USE_MPFS 
....................    #include "tcpip/mpfs.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
....................    #include "tcpip/smtp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_DNS 
....................    #include "tcpip/dns.c" 
.................... #endif 
....................  
.................... #if STACK_USE_ANNOUNCE 
....................    #include "tcpip/announce.h" 
....................    #include "tcpip/announce.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SNMP 
....................    #include "tcpip/snmp.c" 
.................... #endif 
....................  
.................... //#define MAX_ICMP_DATA_LEN   64 //moved to icmp.h 
....................  
.................... /* 
....................  * Stack FSM states. 
....................  */ 
.................... typedef enum _SM_STACK 
.................... { 
....................     SM_STACK_IDLE=0, 
....................     SM_STACK_MAC, 
....................     SM_STACK_IP, 
....................     SM_STACK_ICMP, 
....................     SM_STACK_ICMP_REPLY, 
....................     SM_STACK_ARP, 
....................     SM_STACK_TCP, 
....................     SM_STACK_UDP 
.................... } SM_STACK; 
....................  
.................... static SM_STACK smStack; 
....................  
.................... NODE_INFO remoteNode; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componets are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines are used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void) 
.................... { 
....................     smStack                     = SM_STACK_IDLE; 
*
1060:  MOVLB  2
1062:  CLRF   x77
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     /* 
....................      * If DHCP or IP Gleaning is enabled, 
....................      * startup in Config Mode. 
....................      */ 
....................     AppConfig.Flags.bInConfigMode = TRUE; 
.................... #endif 
....................  
....................    TickInit(); 
1064:  MOVLB  0
1066:  GOTO   0766
....................  
.................... #if STACK_USE_MAC 
....................     MACInit(); 
106A:  BRA    0A98
.................... #endif 
....................  
.................... #if STACK_USE_ARP 
....................     ARPInit(); 
106C:  BRA    0C66
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
....................     UDPInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_TCP 
....................     TCPInit(); 
106E:  BRA    0DB4
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    DHCPReset(); 
.................... #endif 
....................  
.................... #if STACK_USE_PPP 
....................    ppp_init(); 
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    TelnetInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
....................    SMTPInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    HTTP_Init(); 
1070:  BRA    0FF6
.................... #endif 
.................... } 
1072:  GOTO   7234 (RETURN)
....................  
.................... /* 
.................... #if STACK_USE_MCPENC 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................  #define DebugDisplayVals() debug_stack("\r\nTXB=%U TXB0.ADD=0x%LX TXB0.FR=%U NPL=0x%LX CPL=0x%LX",NICCurrentTxBuffer, TxBuffers[0].StartAddress, TxBuffers[0].bFree, NextPacketLocation.Val, CurrentPacketLocation.Val) 
.................... #else 
....................  #define DebugDisplayVals() debug_stack("\r\nTXB=%U NPL=0x%LX CPL=0x%LX", NICCurrentTxBuffer, NextPacketLocation.Val, CurrentPacketLocation.Val) 
.................... #endif 
.................... #else 
....................  #define DebugDisplayVals() 
.................... #endif 
.................... */ 
....................  
.................... #define DebugDisplayVals() 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically to 
....................  *                  ensure timely responses. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void) 
.................... { 
....................     static WORD dataCount; 
....................  
.................... #if STACK_USE_ICMP 
....................     static BYTE data[MAX_ICMP_DATA_LEN]; 
....................     static WORD ICMPId; 
....................     static WORD ICMPSeq; 
.................... #endif 
....................     IP_ADDR tempLocalIP; 
....................  
....................  
....................     union 
....................     { 
....................         BYTE MACFrameType; 
....................         BYTE IPFrameType; 
.................... #if STACK_USE_ICMP 
....................         ICMP_CODE ICMPCode; 
.................... #endif 
....................     } type; 
....................  
....................  
....................     BOOL lbContinue=FALSE; 
*
6B46:  MOVLB  3
6B48:  BCF    x07.0
....................  
....................     do 
....................     { 
....................         lbContinue = FALSE; 
6B4A:  BCF    x07.0
....................         switch(smStack) 
....................         { 
6B4C:  MOVLB  2
6B4E:  MOVF   x77,W
6B50:  ADDLW  F9
6B52:  BTFSC  FD8.0
6B54:  BRA    6CF8
6B56:  ADDLW  07
6B58:  MOVLB  0
6B5A:  GOTO   6D0C
....................         case SM_STACK_IDLE: 
....................         case SM_STACK_MAC: 
....................             if ( !MACGetHeader(&remoteNode.MACAddr, &type.MACFrameType) ) 
6B5E:  MOVLW  02
6B60:  MOVLB  3
6B62:  MOVWF  x09
6B64:  MOVLW  78
6B66:  MOVWF  x08
6B68:  MOVLW  03
6B6A:  MOVWF  x0B
6B6C:  MOVLW  06
6B6E:  MOVWF  x0A
6B70:  MOVLB  0
6B72:  GOTO   115C
6B76:  MOVF   01,F
6B78:  BNZ   6B7E
....................             { 
....................                 #if STACK_USE_DHCP 
....................                     // Normally, an application would not include  DHCP module 
....................                     // if it is not enabled. But in case some one wants to disable 
....................                     // DHCP module at run-time, remember to not clear our IP 
....................                     // address if link is removed. 
....................                     if ( !DHCPIsDisabled() ) 
....................                     { 
....................                         if ( !MACIsLinked() ) 
....................                         { 
....................                             AppConfig.MyIPAddr.Val = 0x00000000ul; 
....................                             AppConfig.Flags.bInConfigMode = TRUE; 
....................                             DHCPReset(); 
....................                         } 
....................                     } 
....................                 #endif 
....................                 break; 
6B7A:  MOVLB  2
6B7C:  BRA    6CF8
....................             } 
....................  
.................... //            debug_stack("\r\nMAC GET "); 
....................  
....................             lbContinue = TRUE; 
6B7E:  MOVLB  3
6B80:  BSF    x07.0
....................             if ( type.MACFrameType == MAC_IP ) { 
6B82:  MOVF   x06,F
6B84:  BNZ   6B90
....................                 smStack = SM_STACK_IP; 
6B86:  MOVLW  02
6B88:  MOVLB  2
6B8A:  MOVWF  x77
.................... //                debug_stack("IP "); 
....................             } 
....................             else if ( type.MACFrameType == MAC_ARP ) { 
6B8C:  BRA    6BA8
6B8E:  MOVLB  3
6B90:  MOVF   x06,W
6B92:  SUBLW  06
6B94:  BNZ   6BA0
....................                 smStack = SM_STACK_ARP; 
6B96:  MOVLW  05
6B98:  MOVLB  2
6B9A:  MOVWF  x77
.................... //                debug_stack("ARP "); 
....................             } 
....................             else { 
6B9C:  BRA    6BA8
6B9E:  MOVLB  3
....................                 MACDiscardRx(); 
6BA0:  MOVLB  0
6BA2:  CALL   1076
6BA6:  MOVLB  2
.................... //                debug_stack("DISCARD"); 
....................             } 
....................             break; 
6BA8:  BRA    6CF8
....................  
....................         case SM_STACK_ARP: 
.................... #if STACK_USE_ARP 
....................             if ( ARPProcess() ) { 
6BAA:  GOTO   1A0C
6BAE:  MOVF   01,F
6BB0:  BZ    6BB6
....................                 smStack = SM_STACK_IDLE; 
6BB2:  MOVLB  2
6BB4:  CLRF   x77
....................             } 
.................... #else 
....................             smStack = SM_STACK_IDLE; 
.................... #endif 
....................             break; 
6BB6:  MOVLB  2
6BB8:  BRA    6CF8
....................  
....................         case SM_STACK_IP: 
....................             if ( IPGetHeader(&tempLocalIP, 
....................                              &remoteNode, 
....................                              &type.IPFrameType, 
....................                              &dataCount) ) 
6BBA:  MOVLW  03
6BBC:  MOVLB  3
6BBE:  MOVWF  x09
6BC0:  MOVLW  02
6BC2:  MOVWF  x08
6BC4:  MOVWF  x0B
6BC6:  MOVLW  78
6BC8:  MOVWF  x0A
6BCA:  MOVLW  03
6BCC:  MOVWF  x0D
6BCE:  MOVLW  06
6BD0:  MOVWF  x0C
6BD2:  MOVLW  02
6BD4:  MOVWF  x0F
6BD6:  MOVLW  82
6BD8:  MOVWF  x0E
6BDA:  MOVLB  0
6BDC:  GOTO   1D02
6BE0:  MOVF   01,F
6BE2:  BZ    6C16
....................             { 
....................                 lbContinue = TRUE; 
6BE4:  MOVLB  3
6BE6:  BSF    x07.0
....................                 if ( type.IPFrameType == IP_PROT_ICMP ) 
6BE8:  DECFSZ x06,W
6BEA:  BRA    6BF6
....................                 { 
....................                     smStack = SM_STACK_ICMP; 
6BEC:  MOVLW  03
6BEE:  MOVLB  2
6BF0:  MOVWF  x77
.................... //                    debug_stack("ICMP "); 
.................... #if STACK_USE_IP_GLEANING 
....................                     if(AppConfig.Flags.bInConfigMode && !DHCPIsDisabled()) 
....................                     { 
....................                         /* 
....................                          * Accoriding to "IP Gleaning" procedure, 
....................                          * when we receive an ICMP packet with a valid 
....................                          * IP address while we are still in configuration 
....................                          * mode, accept that address as ours and conclude 
....................                          * configuration mode. 
....................                          */ 
....................                         if( tempLocalIP.Val != 0xffffffff ) 
....................                         { 
....................                             AppConfig.Flags.bInConfigMode = FALSE; 
....................                             AppConfig.MyIPAddr = tempLocalIP; 
....................                             myDHCPBindCount--; 
....................                         } 
....................                     } 
.................... #endif 
....................                 } 
....................  
.................... #if STACK_USE_TCP 
....................                 else if ( type.IPFrameType == IP_PROT_TCP ) { 
6BF2:  BRA    6C12
6BF4:  MOVLB  3
6BF6:  MOVF   x06,W
6BF8:  SUBLW  06
6BFA:  BNZ   6C06
....................                     smStack = SM_STACK_TCP; 
6BFC:  MOVLW  06
6BFE:  MOVLB  2
6C00:  MOVWF  x77
....................                     debug_stack("TCP "); 
....................                 } 
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
....................                 else if ( type.IPFrameType == IP_PROT_UDP ) { 
....................                     smStack = SM_STACK_UDP; 
.................... //                    debug_stack("UDP "); 
....................                 } 
.................... #endif 
....................  
....................                 else 
6C02:  BRA    6C12
6C04:  MOVLB  3
....................                 { 
....................                     lbContinue = FALSE; 
6C06:  BCF    x07.0
....................                     MACDiscardRx(); 
6C08:  MOVLB  0
6C0A:  CALL   1076
....................  
....................                     smStack = SM_STACK_IDLE; 
6C0E:  MOVLB  2
6C10:  CLRF   x77
.................... //                    debug_stack("UNKOWN-IP1 "); 
....................                 } 
....................             } 
....................             else 
6C12:  BRA    6C1E
6C14:  MOVLB  0
....................             { 
....................                 MACDiscardRx(); 
6C16:  CALL   1076
....................                 smStack = SM_STACK_IDLE; 
6C1A:  MOVLB  2
6C1C:  CLRF   x77
.................... //                debug_stack("UNKOWN-IP2 "); 
....................             } 
....................             break; 
6C1E:  BRA    6CF8
....................  
.................... #if STACK_USE_UDP 
....................         case SM_STACK_UDP: 
....................             if ( UDPProcess(&remoteNode, &tempLocalIP, dataCount) ) 
....................             { 
.................... //                debug_stack("\r\nUDP PROCESSED"); 
....................                 DebugDisplayVals(); 
....................                 smStack = SM_STACK_IDLE; 
....................             } 
....................             break; 
.................... #endif 
....................  
.................... #if STACK_USE_TCP 
....................         case SM_STACK_TCP: 
....................             if ( TCPProcess(&remoteNode, &tempLocalIP, dataCount) ) 
6C20:  MOVLW  02
6C22:  MOVLB  3
6C24:  MOVWF  x09
6C26:  MOVLW  78
6C28:  MOVWF  x08
6C2A:  MOVLW  03
6C2C:  MOVWF  x0B
6C2E:  MOVLW  02
6C30:  MOVWF  x0A
6C32:  MOVFF  283,30D
6C36:  MOVFF  282,30C
6C3A:  MOVLB  0
6C3C:  GOTO   361E
6C40:  MOVF   01,F
6C42:  BZ    6C48
....................             { 
....................                 debug_stack("\r\nTCP PROCESSED"); 
....................                 DebugDisplayVals(); 
....................                 smStack = SM_STACK_IDLE; 
6C44:  MOVLB  2
6C46:  CLRF   x77
....................             } 
....................             break; 
6C48:  MOVLB  2
6C4A:  BRA    6CF8
.................... #endif 
....................  
....................         case SM_STACK_ICMP: 
....................             smStack = SM_STACK_IDLE; 
6C4C:  MOVLB  2
6C4E:  CLRF   x77
....................  
.................... #if STACK_USE_ICMP 
....................             //if ( dataCount <= (MAX_ICMP_DATA_LEN+9) ) 
....................             if ( dataCount <= (MAX_ICMP_DATA_LEN+8) ) 
6C50:  MOVF   x83,F
6C52:  BNZ   6CA6
6C54:  MOVF   x82,W
6C56:  SUBLW  48
6C58:  BNC   6CA6
....................             { 
....................                 if ( ICMPGet(&type.ICMPCode, 
....................                              data, 
....................                              (BYTE*)&dataCount, 
....................                              &ICMPId, 
....................                              &ICMPSeq) ) 
6C5A:  MOVLW  02
6C5C:  MOVLB  3
6C5E:  MOVWF  x09
6C60:  MOVLW  82
6C62:  MOVWF  x08
6C64:  MOVLW  03
6C66:  MOVWF  x0B
6C68:  MOVLW  06
6C6A:  MOVWF  x0A
6C6C:  MOVLW  02
6C6E:  MOVWF  x0D
6C70:  MOVLW  84
6C72:  MOVWF  x0C
6C74:  MOVFF  309,30F
6C78:  MOVFF  308,30E
6C7C:  MOVLW  02
6C7E:  MOVWF  x11
6C80:  MOVLW  C4
6C82:  MOVWF  x10
6C84:  MOVLW  02
6C86:  MOVWF  x13
6C88:  MOVLW  C6
6C8A:  MOVWF  x12
6C8C:  MOVLB  0
6C8E:  GOTO   38AA
6C92:  MOVF   01,F
6C94:  BZ    6CAA
....................                 { 
....................                     if ( type.ICMPCode == ICMP_ECHO_REQUEST ) 
6C96:  MOVLB  3
6C98:  MOVF   x06,W
6C9A:  SUBLW  08
6C9C:  BNZ   6CA8
....................                     { 
.................... //                        debug_stack("\r\nICMP PROCESSED"); 
....................                         lbContinue = TRUE; 
6C9E:  BSF    x07.0
....................                         smStack = SM_STACK_ICMP_REPLY; 
6CA0:  MOVLW  04
6CA2:  MOVLB  2
6CA4:  MOVWF  x77
6CA6:  MOVLB  3
6CA8:  MOVLB  0
....................                     } 
....................                 } 
....................             } 
....................             DebugDisplayVals(); 
.................... #endif 
....................             MACDiscardRx(); 
6CAA:  CALL   1076
....................             break; 
6CAE:  MOVLB  2
6CB0:  BRA    6CF8
....................  
.................... #if STACK_USE_ICMP 
....................         case SM_STACK_ICMP_REPLY: 
....................             if ( ICMPIsTxReady() ) 
6CB2:  MOVLW  01
6CB4:  MOVLB  3
6CB6:  MOVWF  x91
6CB8:  MOVLB  0
6CBA:  CALL   25B2
6CBE:  MOVF   01,F
6CC0:  BZ    6CF4
....................             { 
....................                 ICMPPut(&remoteNode, 
....................                         ICMP_ECHO_REPLY, 
....................                         data, 
....................                         (BYTE)dataCount, 
....................                         ICMPId, 
....................                         ICMPSeq); 
6CC2:  MOVLW  02
6CC4:  MOVLB  3
6CC6:  MOVWF  x09
6CC8:  MOVLW  78
6CCA:  MOVWF  x08
6CCC:  CLRF   x0A
6CCE:  MOVLW  02
6CD0:  MOVWF  x0C
6CD2:  MOVLW  84
6CD4:  MOVWF  x0B
6CD6:  MOVFF  282,30D
6CDA:  MOVFF  2C5,30F
6CDE:  MOVFF  2C4,30E
6CE2:  MOVFF  2C7,311
6CE6:  MOVFF  2C6,310
6CEA:  MOVLB  0
6CEC:  GOTO   3982
....................  
.................... //                debug_stack("\r\nICMP REPLIED"); 
....................                 DebugDisplayVals(); 
....................                 smStack = SM_STACK_IDLE; 
6CF0:  MOVLB  2
6CF2:  CLRF   x77
....................             } 
....................             break; 
6CF4:  MOVLB  2
6CF6:  BRA    6CF8
.................... #endif 
....................  
....................         } 
....................  
....................     } while( lbContinue ); 
6CF8:  MOVLB  3
6CFA:  BTFSC  x07.0
6CFC:  BRA    6B4A
....................  
.................... #if STACK_USE_SMTP 
....................    SMTPTask(); 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_TCP 
....................     // Perform timed TCP FSM. 
....................     TCPTick(); 
6CFE:  MOVLB  0
6D00:  GOTO   3A94
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    TelnetTask(); 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    HTTP_Task(); 
6D04:  GOTO   5EDA
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     /* 
....................      * DHCP must be called all the time even after IP configuration is 
....................      * discovered. 
....................      * DHCP has to account lease expiration time and renew the configuration 
....................      * time. 
....................      */ 
....................     DHCPTask(); 
....................  
....................     if ( DHCPIsBound() ) 
....................         AppConfig.Flags.bInConfigMode = FALSE; 
....................  
.................... #endif 
.................... } 
6D08:  GOTO   7246 (RETURN)
....................  
....................  
....................  
.................... void MACAddrInit(void) { 
....................    MY_MAC_BYTE1=0; 
*
0720:  CLRF   1C
....................    MY_MAC_BYTE2=2; 
0722:  MOVLW  02
0724:  MOVWF  1D
....................    MY_MAC_BYTE3=3; 
0726:  MOVLW  03
0728:  MOVWF  1E
....................    MY_MAC_BYTE4=4; 
072A:  MOVLW  04
072C:  MOVWF  1F
....................    MY_MAC_BYTE5=5; 
072E:  MOVLW  05
0730:  MOVWF  20
....................    MY_MAC_BYTE6=6; 
0732:  MOVLW  06
0734:  MOVWF  21
.................... } 
0736:  GOTO   722C (RETURN)
....................  
.................... void IPAddrInit(void) { 
....................    //IP address of this unit 
....................    MY_IP_BYTE1=192; 
073A:  MOVLW  C0
073C:  MOVWF  18
....................    MY_IP_BYTE2=168; 
073E:  MOVLW  A8
0740:  MOVWF  19
....................    MY_IP_BYTE3=1; 
0742:  MOVLW  01
0744:  MOVWF  1A
....................    MY_IP_BYTE4=10; 
0746:  MOVLW  0A
0748:  MOVWF  1B
....................  
....................    //network gateway 
....................    MY_GATE_BYTE1=192; 
074A:  MOVLW  C0
074C:  MOVWF  26
....................    MY_GATE_BYTE2=168; 
074E:  MOVLW  A8
0750:  MOVWF  27
....................    MY_GATE_BYTE3=1; 
0752:  MOVLW  01
0754:  MOVWF  28
....................    MY_GATE_BYTE4=1; 
0756:  MOVWF  29
....................  
....................    //subnet mask 
....................    MY_MASK_BYTE1=255; 
0758:  MOVLW  FF
075A:  MOVWF  22
....................    MY_MASK_BYTE2=255; 
075C:  MOVWF  23
....................    MY_MASK_BYTE3=255; 
075E:  MOVWF  24
....................    MY_MASK_BYTE4=0; 
0760:  CLRF   25
.................... } 
0762:  GOTO   7230 (RETURN)
....................  
.................... char ExampleIPDatagram[] = { 
....................    0x45, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
....................    0x64, 0x11, 0x2A, 0x9D, 0x0A, 0x0B, 0x0C, 0x0D, 
....................    0x0A, 0x0B, 0x0C, 0x0E 
.................... }; 
....................  
.................... char ExampleUDPPacket[] = { 
....................    0x04, 0x00, 0x04, 0x01, 0x00, 0x08, 0x00, 0x00, 
....................    0x01, 0x02, 0x03, 0x04 
.................... }; 
....................  
....................  
.................... #include "tcpip/flex_lcd.c" 
.................... // flex_lcd.c 
....................  
.................... // These pins are for the Microchip PicDem2-Plus board, 
.................... // which is what I used to test the driver.  Change these 
.................... // pins to fit your own board. 
....................  
.................... #define LCD_DB4   PIN_A5 
.................... #define LCD_DB5   PIN_A4 
.................... #define LCD_DB6   PIN_A3 
.................... #define LCD_DB7   PIN_A2 
....................  
.................... #define LCD_RS    PIN_E2 
.................... #define LCD_RW    PIN_E1 
.................... #define LCD_E     PIN_E0 
....................  
.................... // If you only want a 6-pin interface to your LCD, then 
.................... // connect the R/W pin on the LCD to ground, and comment 
.................... // out the following line. 
....................  
.................... #define USE_LCD_RW   1      
....................  
.................... //======================================== 
....................  
.................... // Define o LCD com 16x4 linhas 
....................  
.................... //#define USE_LCD_16X4   1 
....................  
.................... //======================================== 
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #define lcd_line_one   0x00  // LCD RAM address for the 1 line 
.................... #define lcd_line_two   0x40  // LCD RAM address for the 2 line 
.................... #define lcd_line_three 0x14  // LCD RAM address for the 3 line 
.................... #define lcd_line_four  0x54  // LCD RAM address for the 4 line 
....................  
....................  
.................... int8 const LCD_INIT_STRING[4] = 
.................... { 
....................  0x20 | (lcd_type << 2), // Func set: 4-bit, 2 lines, 5x8 dots 
....................  0xc,                    // Display on 
....................  1,                      // Clear display 
....................  6                       // Increment cursor 
....................  }; 
....................                               
....................  
.................... //------------------------------------- 
.................... void lcd_send_nibble(int8 nibble) 
.................... { 
.................... // Note:  !! converts an integer expression 
.................... // to a boolean (1 or 0). 
....................  output_bit(LCD_DB4, !!(nibble & 1)); 
*
0536:  MOVLB  3
0538:  BTFSC  x36.0
053A:  BRA    0540
053C:  BCF    F89.5
053E:  BRA    0542
0540:  BSF    F89.5
0542:  BCF    F92.5
....................  output_bit(LCD_DB5, !!(nibble & 2));  
0544:  BTFSC  x36.1
0546:  BRA    054C
0548:  BCF    F89.4
054A:  BRA    054E
054C:  BSF    F89.4
054E:  BCF    F92.4
....................  output_bit(LCD_DB6, !!(nibble & 4));    
0550:  BTFSC  x36.2
0552:  BRA    0558
0554:  BCF    F89.3
0556:  BRA    055A
0558:  BSF    F89.3
055A:  BCF    F92.3
....................  output_bit(LCD_DB7, !!(nibble & 8));    
055C:  BTFSC  x36.3
055E:  BRA    0564
0560:  BCF    F89.2
0562:  BRA    0566
0564:  BSF    F89.2
0566:  BCF    F92.2
....................  
....................  delay_cycles(1); 
0568:  NOP   
....................  output_high(LCD_E); 
056A:  BCF    F96.0
056C:  BSF    F8D.0
....................  delay_us(2); 
056E:  MOVLW  03
0570:  MOVWF  00
0572:  DECFSZ 00,F
0574:  BRA    0572
....................  output_low(LCD_E); 
0576:  BCF    F96.0
0578:  BCF    F8D.0
.................... } 
057A:  MOVLB  0
057C:  RETLW  00
....................  
.................... //----------------------------------- 
.................... // This sub-routine is only called by lcd_read_byte(). 
.................... // It's not a stand-alone routine.  For example, the 
.................... // R/W signal is set high by lcd_read_byte() before 
.................... // this routine is called.      
....................  
.................... #ifdef USE_LCD_RW 
.................... int8 lcd_read_nibble(void) 
.................... { 
.................... int8 retval; 
.................... // Create bit variables so that we can easily set 
.................... // individual bits in the retval variable. 
.................... #bit retval_0 = retval.0 
.................... #bit retval_1 = retval.1 
.................... #bit retval_2 = retval.2 
.................... #bit retval_3 = retval.3 
....................  
.................... retval = 0; 
057E:  MOVLB  3
0580:  CLRF   x37
....................     
.................... output_high(LCD_E); 
0582:  BCF    F96.0
0584:  BSF    F8D.0
.................... delay_cycles(1); 
0586:  NOP   
....................  
.................... retval_0 = input(LCD_DB4); 
0588:  BSF    F92.5
058A:  BCF    x37.0
058C:  BTFSC  F80.5
058E:  BSF    x37.0
.................... retval_1 = input(LCD_DB5); 
0590:  BSF    F92.4
0592:  BCF    x37.1
0594:  BTFSC  F80.4
0596:  BSF    x37.1
.................... retval_2 = input(LCD_DB6); 
0598:  BSF    F92.3
059A:  BCF    x37.2
059C:  BTFSC  F80.3
059E:  BSF    x37.2
.................... retval_3 = input(LCD_DB7); 
05A0:  BSF    F92.2
05A2:  BCF    x37.3
05A4:  BTFSC  F80.2
05A6:  BSF    x37.3
....................   
.................... output_low(LCD_E); 
05A8:  BCF    F96.0
05AA:  BCF    F8D.0
....................     
.................... return(retval);    
05AC:  MOVFF  337,01
.................... }    
05B0:  MOVLB  0
05B2:  RETLW  00
.................... #endif 
....................  
.................... //--------------------------------------- 
.................... // Read a byte from the LCD and return it. 
....................  
.................... #ifdef USE_LCD_RW 
.................... int8 lcd_read_byte(void) 
.................... { 
.................... int8 low; 
.................... int8 high; 
....................  
.................... output_high(LCD_RW); 
05B4:  BCF    F96.1
05B6:  BSF    F8D.1
.................... delay_cycles(1); 
05B8:  NOP   
....................  
.................... high = lcd_read_nibble(); 
05BA:  RCALL  057E
05BC:  MOVFF  01,336
....................  
.................... low = lcd_read_nibble(); 
05C0:  RCALL  057E
05C2:  MOVFF  01,335
....................  
.................... return( (high<<4) | low); 
05C6:  MOVLB  3
05C8:  SWAPF  x36,W
05CA:  MOVWF  00
05CC:  MOVLW  F0
05CE:  ANDWF  00,F
05D0:  MOVF   00,W
05D2:  IORWF  x35,W
05D4:  MOVWF  01
.................... } 
05D6:  MOVLB  0
05D8:  GOTO   05E2 (RETURN)
.................... #endif 
....................  
.................... //---------------------------------------- 
.................... // Send a byte to the LCD. 
.................... void lcd_send_byte(int8 address, int8 n) 
.................... { 
.................... output_low(LCD_RS); 
05DC:  BCF    F96.2
05DE:  BCF    F8D.2
....................  
.................... #ifdef USE_LCD_RW 
.................... while(bit_test(lcd_read_byte(),7)) ; 
05E0:  BRA    05B4
05E2:  MOVFF  01,335
05E6:  MOVLB  3
05E8:  BTFSS  01.7
05EA:  BRA    05F0
05EC:  MOVLB  0
05EE:  BRA    05E0
.................... #else 
.................... delay_us(60);  
.................... #endif 
....................  
.................... if(address) 
05F0:  MOVF   x33,F
05F2:  BZ    05FA
....................    output_high(LCD_RS); 
05F4:  BCF    F96.2
05F6:  BSF    F8D.2
.................... else 
05F8:  BRA    05FE
....................    output_low(LCD_RS); 
05FA:  BCF    F96.2
05FC:  BCF    F8D.2
....................       
....................  delay_cycles(1); 
05FE:  NOP   
....................  
.................... #ifdef USE_LCD_RW 
.................... output_low(LCD_RW); 
0600:  BCF    F96.1
0602:  BCF    F8D.1
.................... delay_cycles(1); 
0604:  NOP   
.................... #endif 
....................  
.................... output_low(LCD_E); 
0606:  BCF    F96.0
0608:  BCF    F8D.0
....................  
.................... lcd_send_nibble(n >> 4); 
060A:  SWAPF  x34,W
060C:  MOVWF  x35
060E:  MOVLW  0F
0610:  ANDWF  x35,F
0612:  MOVFF  335,336
0616:  MOVLB  0
0618:  RCALL  0536
.................... lcd_send_nibble(n & 0xf); 
061A:  MOVLB  3
061C:  MOVF   x34,W
061E:  ANDLW  0F
0620:  MOVWF  x35
0622:  MOVWF  x36
0624:  MOVLB  0
0626:  RCALL  0536
.................... } 
0628:  RETLW  00
....................  
.................... //---------------------------- 
.................... void lcd_init(void) 
.................... { 
.................... int8 i; 
....................  
.................... output_low(LCD_RS); 
062A:  BCF    F96.2
062C:  BCF    F8D.2
....................  
.................... #ifdef USE_LCD_RW 
.................... output_low(LCD_RW); 
062E:  BCF    F96.1
0630:  BCF    F8D.1
.................... #endif 
....................  
.................... output_low(LCD_E); 
0632:  BCF    F96.0
0634:  BCF    F8D.0
....................  
.................... delay_ms(15); 
0636:  MOVLW  0F
0638:  MOVLB  3
063A:  MOVWF  x2F
063C:  MOVLB  0
063E:  RCALL  050E
....................  
.................... for(i=0 ;i < 3; i++) 
0640:  MOVLB  3
0642:  CLRF   x02
0644:  MOVF   x02,W
0646:  SUBLW  02
0648:  BNC   0662
....................    { 
....................     lcd_send_nibble(0x03); 
064A:  MOVLW  03
064C:  MOVWF  x36
064E:  MOVLB  0
0650:  RCALL  0536
....................     delay_ms(5); 
0652:  MOVLW  05
0654:  MOVLB  3
0656:  MOVWF  x2F
0658:  MOVLB  0
065A:  RCALL  050E
....................    } 
065C:  MOVLB  3
065E:  INCF   x02,F
0660:  BRA    0644
....................  
.................... lcd_send_nibble(0x02); 
0662:  MOVLW  02
0664:  MOVWF  x36
0666:  MOVLB  0
0668:  RCALL  0536
....................  
.................... for(i=0; i < sizeof(LCD_INIT_STRING); i++) 
066A:  MOVLB  3
066C:  CLRF   x02
066E:  MOVF   x02,W
0670:  SUBLW  03
0672:  BNC   0698
....................    { 
....................     lcd_send_byte(0, LCD_INIT_STRING[i]); 
0674:  CLRF   03
0676:  MOVF   x02,W
0678:  MOVFF  FF2,303
067C:  BCF    FF2.7
067E:  MOVLB  0
0680:  RCALL  0182
0682:  MOVLB  3
0684:  BTFSC  x03.7
0686:  BSF    FF2.7
0688:  MOVWF  x04
068A:  CLRF   x33
068C:  MOVWF  x34
068E:  MOVLB  0
0690:  RCALL  05DC
....................     
....................     // If the R/W signal is not used, then 
....................     // the busy bit can't be polled.  One of 
....................     // the init commands takes longer than 
....................     // the hard-coded delay of 60 us, so in 
....................     // that case, lets just do a 5 ms delay 
....................     // after all four of them. 
....................     #ifndef USE_LCD_RW 
....................     delay_ms(5); 
....................     #endif 
....................    } 
0692:  MOVLB  3
0694:  INCF   x02,F
0696:  BRA    066E
....................  
.................... } 
0698:  MOVLB  0
069A:  GOTO   71EC (RETURN)
....................  
.................... //---------------------------- 
....................  
.................... void lcd_gotoxy(int8 x, int8 y) 
.................... { 
.................... int8 address; 
....................  
.................... #ifdef USE_LCD_16X4 
....................  
.................... switch(y) 
.................... { 
....................    case 1: 
....................       address = lcd_line_one; 
....................       break; 
....................    case 2: 
....................       address = lcd_line_two; 
....................       break; 
....................    case 3: 
....................       address = lcd_line_three; 
....................       break; 
....................    case 4: 
....................       address = lcd_line_four; 
....................       break; 
.................... } 
....................  
.................... #else 
....................  
.................... if(y != 1) 
069E:  MOVLB  3
06A0:  DECFSZ x30,W
06A2:  BRA    06A6
06A4:  BRA    06AC
....................    address = lcd_line_two; 
06A6:  MOVLW  40
06A8:  MOVWF  x31
.................... else 
06AA:  BRA    06AE
....................    address=0; 
06AC:  CLRF   x31
....................  
.................... #endif 
....................  
.................... address += x-1; 
06AE:  MOVLW  01
06B0:  SUBWF  x2F,W
06B2:  ADDWF  x31,F
.................... lcd_send_byte(0, 0x80 | address); 
06B4:  MOVF   x31,W
06B6:  IORLW  80
06B8:  MOVWF  x32
06BA:  CLRF   x33
06BC:  MOVWF  x34
06BE:  MOVLB  0
06C0:  RCALL  05DC
.................... } 
06C2:  RETLW  00
....................  
.................... //----------------------------- 
.................... void lcd_putc(char c) 
.................... { 
....................  switch(c) 
....................    { 
06C4:  MOVLB  3
06C6:  MOVF   x2E,W
06C8:  XORLW  0C
06CA:  MOVLB  0
06CC:  BZ    06D8
06CE:  XORLW  06
06D0:  BZ    06F0
06D2:  XORLW  02
06D4:  BZ    0700
06D6:  BRA    070E
....................     case '\f': 
....................       lcd_send_byte(0,1); 
06D8:  MOVLB  3
06DA:  CLRF   x33
06DC:  MOVLW  01
06DE:  MOVWF  x34
06E0:  MOVLB  0
06E2:  RCALL  05DC
....................       delay_ms(2); 
06E4:  MOVLW  02
06E6:  MOVLB  3
06E8:  MOVWF  x2F
06EA:  MOVLB  0
06EC:  RCALL  050E
....................       break; 
06EE:  BRA    071E
....................     
....................     case '\n': 
....................        lcd_gotoxy(1,2); 
06F0:  MOVLW  01
06F2:  MOVLB  3
06F4:  MOVWF  x2F
06F6:  MOVLW  02
06F8:  MOVWF  x30
06FA:  MOVLB  0
06FC:  RCALL  069E
....................        break; 
06FE:  BRA    071E
....................     
....................     case '\b': 
....................        lcd_send_byte(0,0x10); 
0700:  MOVLB  3
0702:  CLRF   x33
0704:  MOVLW  10
0706:  MOVWF  x34
0708:  MOVLB  0
070A:  RCALL  05DC
....................        break; 
070C:  BRA    071E
....................     
....................     default: 
....................        lcd_send_byte(1,c); 
070E:  MOVLW  01
0710:  MOVLB  3
0712:  MOVWF  x33
0714:  MOVFF  32E,334
0718:  MOVLB  0
071A:  RCALL  05DC
....................        break; 
071C:  BRA    071E
....................    } 
.................... } 
071E:  RETLW  00
....................  
.................... //------------------------------ 
.................... #ifdef USE_LCD_RW 
.................... char lcd_getc(int8 x, int8 y) 
.................... { 
.................... char value; 
....................  
.................... lcd_gotoxy(x,y); 
....................  
.................... // Wait until busy flag is low. 
.................... while(bit_test(lcd_read_byte(),7));  
....................  
.................... output_high(LCD_RS); 
.................... value = lcd_read_byte(); 
.................... output_low(LCD_RS); 
....................  
.................... return(value); 
.................... } 
.................... #endif 
....................  
....................  
....................  
.................... //here is this examples / page 
.................... const char  HTML_INDEX_PAGE[]=" 
.................... <HTML><BODY BGCOLOR=#FFFFFF TEXT=#000000> 
.................... <IMG SRC=\"http://www.senaalves.com/chora.png\"><P> 
.................... <H1>PIC HTTP - CHORA FI !!!</H1> 
.................... <FORM METHOD=GET> 
.................... <P>LCD: <INPUT TYPE=\"text\" NAME=\"lcd\" size=20 maxlength=16> 
.................... <BR>LED1:<INPUT type=\"radio\" name=\"led1\" value=1>ON &nbsp; &nbsp; &nbsp; 
.................... <INPUT type=\"radio\" name=\"led1\" value=0 checked>OFF 
.................... <BR><INPUT TYPE=\"submit\"></FORM> 
.................... <P><A HREF=\"/analog\">Analog Readings</A> 
.................... </BODY></HTML> 
.................... "; 
....................  
.................... const char  HTML_ANALOG_PAGE[]=" 
.................... <HTML><BODY BGCOLOR=#FFFFFF TEXT=#000000> 
.................... <IMG SRC=\"http://www.senaalves.com/chora.png\"><P> 
.................... <H1>LEITURA ANALÓGICA</H1> 
.................... <P>%0 
.................... <BR>%1 
.................... <P><A HREF=\"/\">LCD/LEDs</A> 
.................... </BODY></HTML> 
.................... "; 
....................  
.................... //this is a callback function to the HTTP stack.  see http.c 
.................... //this demo provides to web "pages", an index (/) and an about page (/about) 
.................... int32 http_get_page(char *file_str) { 
....................    int32 file_loc=0; 
*
49AA:  MOVLB  3
49AC:  CLRF   x14
49AE:  CLRF   x15
49B0:  CLRF   x16
49B2:  CLRF   x17
....................    static char index[]="/"; 
....................    static char about[]="/analog"; 
....................     
....................    //printf(lcd_putc,"\nRequest %s ",file_str); 
....................  
....................    if (stricmp(file_str,index)==0) 
49B4:  MOVFF  313,32D
49B8:  MOVFF  312,32C
49BC:  MOVLW  02
49BE:  MOVWF  x2F
49C0:  MOVLW  E8
49C2:  MOVWF  x2E
49C4:  MOVLB  0
49C6:  RCALL  48A2
49C8:  MOVF   01,F
49CA:  BNZ   49E0
....................       file_loc=label_address(HTML_INDEX_PAGE); 
49CC:  MOVLW  02
49CE:  MOVWF  03
49D0:  MOVLW  A6
49D2:  MOVLB  3
49D4:  MOVWF  x14
49D6:  MOVFF  03,315
49DA:  CLRF   x16
49DC:  CLRF   x17
....................  
....................    else if (stricmp(file_str,about)==0) 
49DE:  BRA    4A0C
49E0:  MOVFF  313,32D
49E4:  MOVFF  312,32C
49E8:  MOVLW  02
49EA:  MOVLB  3
49EC:  MOVWF  x2F
49EE:  MOVLW  EA
49F0:  MOVWF  x2E
49F2:  MOVLB  0
49F4:  RCALL  48A2
49F6:  MOVF   01,F
49F8:  BNZ   4A0E
....................       file_loc=label_address(HTML_ANALOG_PAGE); 
49FA:  MOVLW  04
49FC:  MOVWF  03
49FE:  MOVLW  54
4A00:  MOVLB  3
4A02:  MOVWF  x14
4A04:  MOVFF  03,315
4A08:  CLRF   x16
4A0A:  CLRF   x17
4A0C:  MOVLB  0
....................  
....................    /*if (file_loc){ 
....................       printf(lcd_putc,"\n(FILE=%LU)",file_loc);} 
....................    else{ 
....................       printf(lcd_putc,"\n(File Not Found)");}*/ 
....................  
....................    return(file_loc); 
4A0E:  MOVFF  314,00
4A12:  MOVFF  315,01
4A16:  MOVFF  316,02
4A1A:  MOVFF  317,03
.................... } 
4A1E:  GOTO   628E (RETURN)
....................  
.................... //this is a callback function to the HTTP stack. see http.c 
.................... // this demo provides handling for two formatting chars, %0 and %1. 
.................... //  %0 is ADC for channel 0, %1 is ADC for channel 1. 
.................... int8 http_format_char(int32 file, char id, char *str, int8 max_ret) { 
....................    char new_str[20]; 
....................    int8 len=0; 
*
5922:  MOVLB  3
5924:  CLRF   x3C
....................    int8 i; 
....................  
....................    *str=0; 
5926:  MOVFF  325,FE9
592A:  MOVFF  326,FEA
592E:  CLRF   FEF
....................  
....................    switch(id) { 
5930:  MOVF   x24,W
5932:  XORLW  30
5934:  MOVLB  0
5936:  BZ    593A
5938:  BRA    59A8
....................       case '0': 
....................          set_adc_channel(0); 
593A:  MOVLW  00
593C:  MOVWF  01
593E:  MOVF   FC2,W
5940:  ANDLW  C3
5942:  IORWF  01,W
5944:  MOVWF  FC2
....................          delay_us(100); 
5946:  MOVLW  A6
5948:  MOVWF  00
594A:  DECFSZ 00,F
594C:  BRA    594A
594E:  NOP   
....................          i=read_adc(); 
5950:  BSF    FC2.1
5952:  BTFSC  FC2.1
5954:  BRA    5952
5956:  MOVFF  FC3,33D
595A:  MOVLB  3
....................          sprintf(new_str,"<B>AN0 = </B>0x%X",i); 
595C:  MOVLW  03
595E:  MOVLB  2
5960:  MOVWF  xF3
5962:  MOVLW  28
5964:  MOVWF  xF2
5966:  MOVLB  3
5968:  CLRF   x3E
596A:  MOVF   x3E,W
596C:  MOVLB  0
596E:  CALL   01A0
5972:  MOVLB  3
5974:  INCF   x3E,F
5976:  MOVWF  00
5978:  MOVWF  x41
597A:  MOVLB  0
597C:  RCALL  58B8
597E:  MOVLW  0F
5980:  MOVLB  3
5982:  SUBWF  x3E,W
5984:  BNZ   596A
5986:  MOVFF  33D,33F
598A:  MOVLW  37
598C:  MOVWF  x40
598E:  MOVLB  0
5990:  BRA    58DA
....................          len=strlen(new_str); 
5992:  MOVLW  03
5994:  MOVLB  3
5996:  MOVWF  x3F
5998:  MOVLW  28
599A:  MOVWF  x3E
599C:  MOVLB  0
599E:  CALL   46A0
59A2:  MOVFF  01,33C
....................          break; 
59A6:  BRA    59A8
....................  
....................    } 
....................  
....................    if (len) { 
59A8:  MOVLB  3
59AA:  MOVF   x3C,F
59AC:  BZ    59D6
....................       if (len>max_ret) {len=max_ret;} 
59AE:  MOVF   x3C,W
59B0:  SUBWF  x27,W
59B2:  BC    59B8
59B4:  MOVFF  327,33C
....................       memcpy(str,new_str,len); 
59B8:  MOVFF  326,FEA
59BC:  MOVFF  325,FE9
59C0:  MOVLW  03
59C2:  MOVWF  FE2
59C4:  MOVLW  28
59C6:  MOVWF  FE1
59C8:  MOVF   x3C,W
59CA:  MOVWF  01
59CC:  BZ    59D6
59CE:  MOVFF  FE6,FEE
59D2:  DECFSZ 01,F
59D4:  BRA    59CE
....................    } 
....................  
....................    return(len); 
59D6:  MOVFF  33C,01
.................... } 
59DA:  MOVLB  0
59DC:  GOTO   5D02 (RETURN)
....................  
.................... //this is a callback function to the HTTP stack. see http.c 
.................... //in this example it verifies that "pwd" is "master", if it is 
.................... //then it sets led1 and led2 ("led1" and "led2") based on their value 
.................... //and changes the lcd screen ("lcd"). 
.................... void http_exec_cgi(int32 file, char *key, char *val) { 
....................    static char led1_key[]="led1"; 
....................    static char led2_key[]="led2"; 
....................    static char lcd_key[]="lcd"; 
....................    int8 v; 
....................    //printf(lcd_putc,"\nCGI FILE=%LD KEY=%S VAL=%S", file, key, val); 
....................  
....................    if (stricmp(key,led1_key)==0) { 
*
4C14:  MOVFF  328,32D
4C18:  MOVFF  327,32C
4C1C:  MOVLW  02
4C1E:  MOVLB  3
4C20:  MOVWF  x2F
4C22:  MOVLW  F4
4C24:  MOVWF  x2E
4C26:  MOVLB  0
4C28:  RCALL  48A2
4C2A:  MOVF   01,F
4C2C:  BNZ   4C4C
....................       v=atoi(val); 
4C2E:  MOVFF  32A,32D
4C32:  MOVFF  329,32C
4C36:  RCALL  4A72
4C38:  MOVFF  01,32B
....................       if (v) {output_high(PIN_D0);} 
4C3C:  MOVLB  3
4C3E:  MOVF   x2B,F
4C40:  BZ    4C48
4C42:  BCF    F95.0
4C44:  BSF    F8C.0
....................       else {output_low(PIN_D0);} 
4C46:  BRA    4C4C
4C48:  BCF    F95.0
4C4A:  BCF    F8C.0
....................    } 
....................  
....................    if (stricmp(key,led2_key)==0) { 
4C4C:  MOVFF  328,32D
4C50:  MOVFF  327,32C
4C54:  MOVLW  02
4C56:  MOVLB  3
4C58:  MOVWF  x2F
4C5A:  MOVLW  F9
4C5C:  MOVWF  x2E
4C5E:  MOVLB  0
4C60:  RCALL  48A2
4C62:  MOVF   01,F
4C64:  BNZ   4C74
....................       v=atoi(val); 
4C66:  MOVFF  32A,32D
4C6A:  MOVFF  329,32C
4C6E:  RCALL  4A72
4C70:  MOVFF  01,32B
....................       //if (v) {output_low(PIN_D0);} 
....................       //else {output_high(PIN_D0);} 
....................    } 
....................  
....................    if (stricmp(key,lcd_key)==0) { 
4C74:  MOVFF  328,32D
4C78:  MOVFF  327,32C
4C7C:  MOVLW  02
4C7E:  MOVLB  3
4C80:  MOVWF  x2F
4C82:  MOVLW  FE
4C84:  MOVWF  x2E
4C86:  MOVLB  0
4C88:  RCALL  48A2
4C8A:  MOVF   01,F
4C8C:  BNZ   4CC8
....................       printf(lcd_putc,"\f%s",val); 
4C8E:  MOVLW  0C
4C90:  MOVLB  3
4C92:  MOVWF  x2E
4C94:  MOVLB  0
4C96:  CALL   06C4
4C9A:  MOVFF  32A,FEA
4C9E:  MOVFF  329,FE9
4CA2:  MOVLW  00
4CA4:  IORWF  FEF,W
4CA6:  BZ    4CC8
4CA8:  MOVFF  FEA,32D
4CAC:  MOVFF  FE9,32C
4CB0:  MOVFF  FEF,32E
4CB4:  CALL   06C4
4CB8:  MOVFF  32D,FEA
4CBC:  MOVFF  32C,FE9
4CC0:  INCF   FE9,F
4CC2:  BTFSC  FD8.2
4CC4:  INCF   FEA,F
4CC6:  BRA    4CA2
....................    } 
.................... } 
4CC8:  GOTO   4D32 (RETURN)
....................  
.................... void main(void) { 
*
6D3E:  CLRF   FF8
6D40:  BCF    FD0.7
6D42:  BSF    0D.7
6D44:  CLRF   FEA
6D46:  CLRF   FE9
6D48:  BSF    FB8.3
6D4A:  MOVLW  08
6D4C:  MOVWF  FAF
6D4E:  MOVLW  02
6D50:  MOVWF  FB0
6D52:  MOVLW  A6
6D54:  MOVWF  FAC
6D56:  MOVLW  90
6D58:  MOVWF  FAB
6D5A:  MOVF   FC1,W
6D5C:  ANDLW  C0
6D5E:  IORLW  0F
6D60:  MOVWF  FC1
6D62:  MOVLW  07
6D64:  MOVWF  FB4
6D66:  CLRF   49
6D68:  CLRF   4A
6D6A:  CLRF   50
6D6C:  CLRF   51
6D6E:  CLRF   52
6D70:  CLRF   53
6D72:  CLRF   5A
6D74:  CLRF   5B
6D76:  CLRF   5C
6D78:  CLRF   5D
6D7A:  MOVLW  04
6D7C:  MOVWF  5E
6D7E:  BCF    58.1
6D80:  MOVLB  1
6D82:  CLRF   x15
6D84:  CLRF   x16
6D86:  CLRF   x17
6D88:  CLRF   x18
6D8A:  CLRF   x19
6D8C:  CLRF   x1A
6D8E:  CLRF   x1B
6D90:  CLRF   x1C
6D92:  CLRF   x1D
6D94:  CLRF   x1E
6D96:  MOVLW  FE
6D98:  MOVWF  x1F
6D9A:  CLRF   x20
6D9C:  MOVLW  01
6D9E:  MOVWF  x21
6DA0:  CLRF   x29
6DA2:  CLRF   x2A
6DA4:  CLRF   x2B
6DA6:  CLRF   x2C
6DA8:  CLRF   x2D
6DAA:  CLRF   x2E
6DAC:  CLRF   x2F
6DAE:  CLRF   x30
6DB0:  CLRF   x31
6DB2:  CLRF   x32
6DB4:  CLRF   x33
6DB6:  CLRF   x34
6DB8:  CLRF   x35
6DBA:  CLRF   x36
6DBC:  CLRF   x37
6DBE:  CLRF   x38
6DC0:  CLRF   x39
6DC2:  CLRF   x3A
6DC4:  CLRF   x3B
6DC6:  CLRF   x3C
6DC8:  CLRF   x3D
6DCA:  CLRF   x3E
6DCC:  CLRF   x3F
6DCE:  CLRF   x40
6DD0:  CLRF   x41
6DD2:  CLRF   x42
6DD4:  CLRF   x43
6DD6:  CLRF   x44
6DD8:  CLRF   x45
6DDA:  CLRF   x46
6DDC:  CLRF   x47
6DDE:  CLRF   x48
6DE0:  CLRF   x49
6DE2:  CLRF   x4A
6DE4:  CLRF   x4B
6DE6:  CLRF   x4C
6DE8:  CLRF   x4D
6DEA:  CLRF   x4E
6DEC:  CLRF   x4F
6DEE:  CLRF   x50
6DF0:  CLRF   x51
6DF2:  MOVLW  20
6DF4:  MOVWF  x52
6DF6:  CLRF   x53
6DF8:  MOVLW  3F
6DFA:  MOVWF  x54
6DFC:  CLRF   x55
6DFE:  MOVLW  47
6E00:  MOVWF  x56
6E02:  MOVLW  45
6E04:  MOVWF  x57
6E06:  MOVLW  54
6E08:  MOVWF  x58
6E0A:  CLRF   x59
6E0C:  MOVLW  50
6E0E:  MOVWF  x5A
6E10:  MOVLW  4F
6E12:  MOVWF  x5B
6E14:  MOVLW  53
6E16:  MOVWF  x5C
6E18:  MOVLW  54
6E1A:  MOVWF  x5D
6E1C:  CLRF   x5E
6E1E:  MOVLW  43
6E20:  MOVWF  x5F
6E22:  MOVLW  6F
6E24:  MOVWF  x60
6E26:  MOVLW  6E
6E28:  MOVWF  x61
6E2A:  MOVLW  74
6E2C:  MOVWF  x62
6E2E:  MOVLW  65
6E30:  MOVWF  x63
6E32:  MOVLW  6E
6E34:  MOVWF  x64
6E36:  MOVLW  74
6E38:  MOVWF  x65
6E3A:  MOVLW  2D
6E3C:  MOVWF  x66
6E3E:  MOVLW  4C
6E40:  MOVWF  x67
6E42:  MOVLW  65
6E44:  MOVWF  x68
6E46:  MOVLW  6E
6E48:  MOVWF  x69
6E4A:  MOVLW  67
6E4C:  MOVWF  x6A
6E4E:  MOVLW  74
6E50:  MOVWF  x6B
6E52:  MOVLW  68
6E54:  MOVWF  x6C
6E56:  MOVLW  3A
6E58:  MOVWF  x6D
6E5A:  CLRF   x6E
6E5C:  CLRF   x6F
6E5E:  CLRF   x70
6E60:  CLRF   x71
6E62:  CLRF   x72
6E64:  CLRF   x73
6E66:  CLRF   x74
6E68:  CLRF   x75
6E6A:  CLRF   x76
6E6C:  CLRF   x77
6E6E:  CLRF   x78
6E70:  CLRF   x79
6E72:  CLRF   x7A
6E74:  CLRF   x7B
6E76:  CLRF   x7C
6E78:  CLRF   x7D
6E7A:  CLRF   x7E
6E7C:  CLRF   x7F
6E7E:  CLRF   x80
6E80:  CLRF   x81
6E82:  CLRF   x82
6E84:  CLRF   x83
6E86:  CLRF   x84
6E88:  CLRF   x85
6E8A:  CLRF   x86
6E8C:  CLRF   x87
6E8E:  CLRF   x88
6E90:  CLRF   x89
6E92:  CLRF   x8A
6E94:  CLRF   x8B
6E96:  CLRF   x8C
6E98:  CLRF   x8D
6E9A:  CLRF   x8E
6E9C:  CLRF   x8F
6E9E:  CLRF   x90
6EA0:  CLRF   x91
6EA2:  CLRF   x92
6EA4:  CLRF   x93
6EA6:  CLRF   x94
6EA8:  CLRF   x95
6EAA:  CLRF   x96
6EAC:  CLRF   x97
6EAE:  CLRF   x98
6EB0:  CLRF   x99
6EB2:  CLRF   x9A
6EB4:  CLRF   x9B
6EB6:  CLRF   x9C
6EB8:  CLRF   x9D
6EBA:  CLRF   x9E
6EBC:  CLRF   x9F
6EBE:  CLRF   xA0
6EC0:  CLRF   xA1
6EC2:  CLRF   xA2
6EC4:  CLRF   xA3
6EC6:  CLRF   xA4
6EC8:  CLRF   xA5
6ECA:  CLRF   xA6
6ECC:  CLRF   xA7
6ECE:  CLRF   xA8
6ED0:  CLRF   xA9
6ED2:  CLRF   xAA
6ED4:  CLRF   xAB
6ED6:  CLRF   xAC
6ED8:  CLRF   xAD
6EDA:  CLRF   xAE
6EDC:  CLRF   xAF
6EDE:  CLRF   xB0
6EE0:  CLRF   xB1
6EE2:  CLRF   xB2
6EE4:  CLRF   xB3
6EE6:  CLRF   xB4
6EE8:  CLRF   xB5
6EEA:  CLRF   xB6
6EEC:  CLRF   xB7
6EEE:  CLRF   xB8
6EF0:  CLRF   xB9
6EF2:  CLRF   xBA
6EF4:  CLRF   xBB
6EF6:  CLRF   xBC
6EF8:  CLRF   xBD
6EFA:  CLRF   xBE
6EFC:  CLRF   xBF
6EFE:  CLRF   xC0
6F00:  CLRF   xC1
6F02:  CLRF   xC2
6F04:  CLRF   xC3
6F06:  CLRF   xC4
6F08:  CLRF   xC5
6F0A:  CLRF   xC6
6F0C:  CLRF   xC7
6F0E:  CLRF   xC8
6F10:  CLRF   xC9
6F12:  CLRF   xCA
6F14:  CLRF   xCB
6F16:  CLRF   xCC
6F18:  CLRF   xCD
6F1A:  CLRF   xCE
6F1C:  CLRF   xCF
6F1E:  CLRF   xD0
6F20:  CLRF   xD1
6F22:  CLRF   xD2
6F24:  CLRF   xD3
6F26:  CLRF   xD4
6F28:  CLRF   xD5
6F2A:  CLRF   xD6
6F2C:  CLRF   xD7
6F2E:  CLRF   xD8
6F30:  CLRF   xD9
6F32:  CLRF   xDA
6F34:  CLRF   xDB
6F36:  CLRF   xDC
6F38:  CLRF   xDD
6F3A:  CLRF   xDE
6F3C:  CLRF   xDF
6F3E:  CLRF   xE0
6F40:  CLRF   xE1
6F42:  CLRF   xE2
6F44:  CLRF   xE3
6F46:  CLRF   xE4
6F48:  CLRF   xE5
6F4A:  CLRF   xE6
6F4C:  CLRF   xE7
6F4E:  CLRF   xE8
6F50:  CLRF   xE9
6F52:  CLRF   xEA
6F54:  CLRF   xEB
6F56:  CLRF   xEC
6F58:  CLRF   xED
6F5A:  CLRF   xEE
6F5C:  CLRF   xEF
6F5E:  CLRF   xF0
6F60:  CLRF   xF1
6F62:  CLRF   xF2
6F64:  CLRF   xF3
6F66:  CLRF   xF4
6F68:  CLRF   xF5
6F6A:  CLRF   xF6
6F6C:  CLRF   xF7
6F6E:  CLRF   xF8
6F70:  CLRF   xF9
6F72:  CLRF   xFA
6F74:  CLRF   xFB
6F76:  CLRF   xFC
6F78:  CLRF   xFD
6F7A:  CLRF   xFE
6F7C:  CLRF   xFF
6F7E:  MOVLB  2
6F80:  CLRF   x00
6F82:  CLRF   x01
6F84:  CLRF   x02
6F86:  CLRF   x03
6F88:  CLRF   x04
6F8A:  CLRF   x05
6F8C:  CLRF   x06
6F8E:  CLRF   x07
6F90:  CLRF   x08
6F92:  CLRF   x09
6F94:  CLRF   x0A
6F96:  CLRF   x0B
6F98:  CLRF   x0C
6F9A:  CLRF   x0D
6F9C:  CLRF   x0E
6F9E:  CLRF   x0F
6FA0:  CLRF   x10
6FA2:  CLRF   x11
6FA4:  CLRF   x12
6FA6:  CLRF   x13
6FA8:  CLRF   x14
6FAA:  CLRF   x15
6FAC:  CLRF   x16
6FAE:  CLRF   x17
6FB0:  CLRF   x18
6FB2:  CLRF   x19
6FB4:  CLRF   x1A
6FB6:  CLRF   x1B
6FB8:  CLRF   x1C
6FBA:  CLRF   x1D
6FBC:  CLRF   x1E
6FBE:  CLRF   x1F
6FC0:  CLRF   x20
6FC2:  CLRF   x21
6FC4:  CLRF   x22
6FC6:  CLRF   x23
6FC8:  CLRF   x24
6FCA:  CLRF   x25
6FCC:  CLRF   x26
6FCE:  CLRF   x27
6FD0:  CLRF   x28
6FD2:  CLRF   x29
6FD4:  CLRF   x2A
6FD6:  CLRF   x2B
6FD8:  CLRF   x2C
6FDA:  CLRF   x2D
6FDC:  CLRF   x2E
6FDE:  CLRF   x2F
6FE0:  CLRF   x30
6FE2:  CLRF   x31
6FE4:  CLRF   x32
6FE6:  CLRF   x33
6FE8:  CLRF   x34
6FEA:  CLRF   x35
6FEC:  CLRF   x36
6FEE:  CLRF   x37
6FF0:  CLRF   x38
6FF2:  CLRF   x39
6FF4:  CLRF   x3A
6FF6:  CLRF   x3B
6FF8:  CLRF   x3C
6FFA:  CLRF   x3D
6FFC:  CLRF   x3E
6FFE:  CLRF   x3F
7000:  CLRF   x40
7002:  CLRF   x41
7004:  CLRF   x42
7006:  CLRF   x43
7008:  CLRF   x44
700A:  CLRF   x45
700C:  CLRF   x46
700E:  CLRF   x47
7010:  CLRF   x48
7012:  CLRF   x49
7014:  CLRF   x4A
7016:  CLRF   x4B
7018:  CLRF   x4C
701A:  CLRF   x4D
701C:  CLRF   x4E
701E:  CLRF   x4F
7020:  CLRF   x50
7022:  CLRF   x51
7024:  CLRF   x52
7026:  CLRF   x53
7028:  CLRF   x54
702A:  CLRF   x55
702C:  CLRF   x56
702E:  CLRF   x57
7030:  CLRF   x58
7032:  CLRF   x59
7034:  CLRF   x5A
7036:  CLRF   x5B
7038:  CLRF   x5C
703A:  CLRF   x5D
703C:  CLRF   x5E
703E:  CLRF   x5F
7040:  CLRF   x60
7042:  CLRF   x61
7044:  CLRF   x62
7046:  CLRF   x63
7048:  CLRF   x64
704A:  CLRF   x65
704C:  CLRF   x66
704E:  CLRF   x67
7050:  CLRF   x68
7052:  CLRF   x69
7054:  CLRF   x6A
7056:  CLRF   x6B
7058:  CLRF   x6C
705A:  CLRF   x6D
705C:  CLRF   x6E
705E:  CLRF   x6F
7060:  CLRF   x70
7062:  CLRF   x71
7064:  CLRF   x72
7066:  CLRF   x73
7068:  CLRF   x74
706A:  CLRF   x75
706C:  CLRF   x76
706E:  CLRF   x77
7070:  CLRF   x82
7072:  CLRF   x83
7074:  CLRF   x84
7076:  CLRF   x85
7078:  CLRF   x86
707A:  CLRF   x87
707C:  CLRF   x88
707E:  CLRF   x89
7080:  CLRF   x8A
7082:  CLRF   x8B
7084:  CLRF   x8C
7086:  CLRF   x8D
7088:  CLRF   x8E
708A:  CLRF   x8F
708C:  CLRF   x90
708E:  CLRF   x91
7090:  CLRF   x92
7092:  CLRF   x93
7094:  CLRF   x94
7096:  CLRF   x95
7098:  CLRF   x96
709A:  CLRF   x97
709C:  CLRF   x98
709E:  CLRF   x99
70A0:  CLRF   x9A
70A2:  CLRF   x9B
70A4:  CLRF   x9C
70A6:  CLRF   x9D
70A8:  CLRF   x9E
70AA:  CLRF   x9F
70AC:  CLRF   xA0
70AE:  CLRF   xA1
70B0:  CLRF   xA2
70B2:  CLRF   xA3
70B4:  CLRF   xA4
70B6:  CLRF   xA5
70B8:  CLRF   xA6
70BA:  CLRF   xA7
70BC:  CLRF   xA8
70BE:  CLRF   xA9
70C0:  CLRF   xAA
70C2:  CLRF   xAB
70C4:  CLRF   xAC
70C6:  CLRF   xAD
70C8:  CLRF   xAE
70CA:  CLRF   xAF
70CC:  CLRF   xB0
70CE:  CLRF   xB1
70D0:  CLRF   xB2
70D2:  CLRF   xB3
70D4:  CLRF   xB4
70D6:  CLRF   xB5
70D8:  CLRF   xB6
70DA:  CLRF   xB7
70DC:  CLRF   xB8
70DE:  CLRF   xB9
70E0:  CLRF   xBA
70E2:  CLRF   xBB
70E4:  CLRF   xBC
70E6:  CLRF   xBD
70E8:  CLRF   xBE
70EA:  CLRF   xBF
70EC:  CLRF   xC0
70EE:  CLRF   xC1
70F0:  CLRF   xC2
70F2:  CLRF   xC3
70F4:  CLRF   xC4
70F6:  CLRF   xC5
70F8:  CLRF   xC6
70FA:  CLRF   xC7
70FC:  MOVLW  45
70FE:  MOVWF  xC8
7100:  CLRF   xC9
7102:  CLRF   xCA
7104:  MOVLW  20
7106:  MOVWF  xCB
7108:  CLRF   xCC
710A:  CLRF   xCD
710C:  CLRF   xCE
710E:  CLRF   xCF
7110:  MOVLW  64
7112:  MOVWF  xD0
7114:  MOVLW  11
7116:  MOVWF  xD1
7118:  MOVLW  2A
711A:  MOVWF  xD2
711C:  MOVLW  9D
711E:  MOVWF  xD3
7120:  MOVLW  0A
7122:  MOVWF  xD4
7124:  MOVLW  0B
7126:  MOVWF  xD5
7128:  MOVLW  0C
712A:  MOVWF  xD6
712C:  MOVLW  0D
712E:  MOVWF  xD7
7130:  MOVLW  0A
7132:  MOVWF  xD8
7134:  MOVLW  0B
7136:  MOVWF  xD9
7138:  MOVLW  0C
713A:  MOVWF  xDA
713C:  MOVLW  0E
713E:  MOVWF  xDB
7140:  MOVLW  04
7142:  MOVWF  xDC
7144:  CLRF   xDD
7146:  MOVWF  xDE
7148:  MOVLW  01
714A:  MOVWF  xDF
714C:  CLRF   xE0
714E:  MOVLW  08
7150:  MOVWF  xE1
7152:  CLRF   xE2
7154:  CLRF   xE3
7156:  MOVLW  01
7158:  MOVWF  xE4
715A:  MOVLW  02
715C:  MOVWF  xE5
715E:  MOVLW  03
7160:  MOVWF  xE6
7162:  MOVLW  04
7164:  MOVWF  xE7
7166:  MOVLW  2F
7168:  MOVWF  xE8
716A:  CLRF   xE9
716C:  MOVWF  xEA
716E:  MOVLW  61
7170:  MOVWF  xEB
7172:  MOVLW  6E
7174:  MOVWF  xEC
7176:  MOVLW  61
7178:  MOVWF  xED
717A:  MOVLW  6C
717C:  MOVWF  xEE
717E:  MOVLW  6F
7180:  MOVWF  xEF
7182:  MOVLW  67
7184:  MOVWF  xF0
7186:  CLRF   xF1
7188:  CLRF   xF2
718A:  CLRF   xF3
718C:  MOVLW  6C
718E:  MOVWF  xF4
7190:  MOVLW  65
7192:  MOVWF  xF5
7194:  MOVLW  64
7196:  MOVWF  xF6
7198:  MOVLW  31
719A:  MOVWF  xF7
719C:  CLRF   xF8
719E:  MOVLW  6C
71A0:  MOVWF  xF9
71A2:  MOVLW  65
71A4:  MOVWF  xFA
71A6:  MOVLW  64
71A8:  MOVWF  xFB
71AA:  MOVLW  32
71AC:  MOVWF  xFC
71AE:  CLRF   xFD
71B0:  MOVLW  6C
71B2:  MOVWF  xFE
71B4:  MOVLW  63
71B6:  MOVWF  xFF
71B8:  MOVLW  64
71BA:  MOVLB  3
71BC:  MOVWF  x00
71BE:  CLRF   x01
....................  
....................     
....................    setup_adc(ADC_CLOCK_INTERNAL); 
71C0:  BSF    FC0.0
71C2:  BSF    FC0.1
71C4:  BSF    FC0.2
71C6:  BSF    FC0.7
71C8:  BSF    FC2.0
....................    setup_adc_ports(AN0); 
71CA:  MOVF   FC1,W
71CC:  ANDLW  C0
71CE:  IORLW  0E
71D0:  MOVWF  FC1
....................    set_adc_channel(0); 
71D2:  MOVLW  00
71D4:  MOVWF  01
71D6:  MOVF   FC2,W
71D8:  ANDLW  C3
71DA:  IORWF  01,W
71DC:  MOVWF  FC2
....................    delay_ms(1); 
71DE:  MOVLW  01
71E0:  MOVWF  x2F
71E2:  MOVLB  0
71E4:  CALL   050E
....................     
....................     
....................    lcd_init(); 
71E8:  GOTO   062A
....................     
....................    delay_ms(10); 
71EC:  MOVLW  0A
71EE:  MOVLB  3
71F0:  MOVWF  x2F
71F2:  MOVLB  0
71F4:  CALL   050E
....................    lcd_gotoxy(0,0); 
71F8:  MOVLB  3
71FA:  CLRF   x2F
71FC:  CLRF   x30
71FE:  MOVLB  0
7200:  CALL   069E
....................    printf(lcd_putc,"PICHTTP CHORA FI"); 
7204:  MOVLB  3
7206:  CLRF   x02
7208:  MOVF   x02,W
720A:  MOVLB  0
720C:  CALL   01CC
7210:  MOVLB  3
7212:  INCF   x02,F
7214:  MOVWF  00
7216:  MOVWF  x2E
7218:  MOVLB  0
721A:  CALL   06C4
721E:  MOVLW  10
7220:  MOVLB  3
7222:  SUBWF  x02,W
7224:  BNZ   7208
....................     
....................    MACAddrInit(); 
7226:  MOVLB  0
7228:  GOTO   0720
....................    IPAddrInit(); 
722C:  GOTO   073A
....................    StackInit(); 
7230:  GOTO   1060
....................     
....................    delay_ms(10); 
7234:  MOVLW  0A
7236:  MOVLB  3
7238:  MOVWF  x2F
723A:  MOVLB  0
723C:  CALL   050E
....................     
....................    output_low(PIN_D0); 
7240:  BCF    F95.0
7242:  BCF    F8C.0
....................  
....................    while(TRUE) { 
....................       StackTask(); 
7244:  BRA    6B46
....................    } 
7246:  BRA    7244
.................... } 
7248:  SLEEP 

Configuration Fuses:
   Word  1: 0C20   NOIESO NOFCMEN HS PLL1 CPUDIV1 USBDIV
   Word  2: 1E3E   BROWNOUT NOWDT BORV20 PUT WDT32768 VREGEN
   Word  3: 8100   NOPBADEN CCP2C1 MCLR NOLPT1OSC RESERVED
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST NOICPRT RESERVED
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: A00F   NOWRT NOWRTD NOWRTC WRTB
   Word  7: 400F   NOEBTR NOEBTRB
